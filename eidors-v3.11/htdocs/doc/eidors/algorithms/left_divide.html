<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of left_divide</title>
  <meta name="keywords" content="left_divide">
  <meta name="description" content="[V] = LEFT_DIVIDE(E,I,tol,pp,V);">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">eidors</a> &gt; <a href="index.html">algorithms</a> &gt; left_divide.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/algorithms&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>left_divide
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>[V] = LEFT_DIVIDE(E,I,tol,pp,V);</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [V] = left_divide(E,I,tol,~,V) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">[V] = LEFT_DIVIDE(E,I,tol,pp,V);
[V] = LEFT_DIVIDE(E,I,fmdl)
 
 Implements left division for symmetric positive definite system solves
 such as the sparse forward solve and dense solve for a GN descent
 direction. LEFT_DIVIDE is optimised for symmetric matrices and overcomes
 small inefficiencies of matlab's mldivide. For non-symmetric solves 
 please use mldivide.

 Also uses conjugate gradients (for large problems).

 E   = The full rank system matrix
 I   = The currents matrix (RHS)
 tol = The tolerance in the forward solution, e.g. 1e-5

 pp,V are old options from previous solver. tilde used in arguments list
 to ignore pp and keep matlab's code analyzer happy</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="left_divide.html" class="code" title="function [V] = left_divide(E,I,tol,~,V)">left_divide</a>	[V] = LEFT_DIVIDE(E,I,tol,pp,V);</li><li><a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG eidors progress and status messages</li><li><a href="../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>	EIDORS_OBJ: maintains EIDORS internals</li><li><a href="../../eidors/models/mk_circ_tank.html" class="code" title="function param= mk_circ_tank(rings, levels, elec_spec );">mk_circ_tank</a>	MK_CIRC_TANK: make a cylindrical tank FEM geometry in 2D or 3D</li><li><a href="../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>	MK_IMAGE: create eidors image object</li><li><a href="../../eidors/models/mk_stim_patterns.html" class="code" title="function [stim, meas_sel]= mk_stim_patterns(n_elec, n_rings, inj, meas, options, amplitude)">mk_stim_patterns</a>	MK_STIM_PATTERNS: create an EIDORS stimulation pattern structure</li><li><a href="../../eidors/models/stim_meas_list.html" class="code" title="function [stim, meas_sel]= stim_meas_list( sp_mp , Nelec, current, gain);">stim_meas_list</a>	STIM_MEAS_LIST: mk stimulation pattern from list of electrodes</li><li><a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>	SPARSE Create sparse matrix (EIDORS overload).</li><li><a href="../../eidors/solvers/calc_RtR_prior.html" class="code" title="function RtR_prior = calc_RtR_prior( inv_model )">calc_RtR_prior</a>	RtR = calc_RtR_prior( inv_model )</li><li><a href="../../eidors/solvers/calc_hyperparameter.html" class="code" title="function hyperparameter = calc_hyperparameter( inv_model )">calc_hyperparameter</a>	CALC_HYPERPARAMETER: calculate hyperparameter value</li><li><a href="../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>	CALC_JACOBIAN: calculate jacobian from an inv_model</li><li><a href="../../eidors/solvers/calc_meas_icov.html" class="code" title="function meas_icov = calc_meas_icov( inv_model )">calc_meas_icov</a>	meas_icov = calc_meas_icov( inv_model )</li><li><a href="../../eidors/solvers/calc_system_mat.html" class="code" title="function system_mat = calc_system_mat( fwd_model, img)">calc_system_mat</a>	CALC_SYSTEM_MAT: calculate FEM system matrix from fwd_model and image</li><li><a href="../../eidors/solvers/forward/fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>	FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)</li><li><a href="../../eidors/solvers/forward/fwd_solve_1st_order.html" class="code" title="function data =fwd_solve_1st_order(fwd_model, img)">fwd_solve_1st_order</a>	FWD_SOLVE_1ST_ORDER: data= fwd_solve_1st_order( img)</li><li><a href="../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>	INV_SOLVE: calculate imag from an inv_model and data</li><li><a href="../../eidors/tools/eidors_default.html" class="code" title="function varargout = eidors_default(varargin)">eidors_default</a>	EIDORS_DEFAULT Default function handler.</li><li><a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>	UNIT_TEST_CMP: compare matrices in eidors output</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="left_divide.html" class="code" title="function [V] = left_divide(E,I,tol,~,V)">left_divide</a>	[V] = LEFT_DIVIDE(E,I,tol,pp,V);</li><li><a href="../../eidors/examples/demo_complex.html" class="code" title="">demo_complex</a>	This demo function shows how the EIT problem can be formulated in a complex</li><li><a href="../../eidors/examples/eidors2d_demo1.html" class="code" title="">eidors2d_demo1</a>	EidorsDemo1 Demonstrates the use of 2D EIT Package with linear basis</li><li><a href="../../eidors/solvers/forward/fwd_solve_1st_order.html" class="code" title="function data =fwd_solve_1st_order(fwd_model, img)">fwd_solve_1st_order</a>	FWD_SOLVE_1ST_ORDER: data= fwd_solve_1st_order( img)</li><li><a href="../../eidors/solvers/forward/fwd_solve_2p5d_1st_order.html" class="code" title="function data =fwd_solve_2p5d_1st_order(fwd_model, img)">fwd_solve_2p5d_1st_order</a>	FWD_SOLVE_2P5D_1ST_ORDER: data= fwd_solve_2p5d_1st_order( img)</li><li><a href="../../eidors/solvers/forward/fwd_solve_higher_order.html" class="code" title="function[data] = fwd_solve_higher_order(fwd_model,img)">fwd_solve_higher_order</a>	Solve for voltages (nodes/electrodes) for a forward model.</li><li><a href="../../eidors/solvers/forward/jacobian_adjoint.html" class="code" title="function J= jacobian_adjoint( fwd_model, img)">jacobian_adjoint</a>	JACOBIAN_ADJOINT: J= jacobian_adjoint( img )</li><li><a href="../../eidors/solvers/forward/jacobian_adjoint_2p5d_1st_order.html" class="code" title="function J= jacobian_adjoint_2p5d_1st_order( fwd_model, img)">jacobian_adjoint_2p5d_1st_order</a>	JACOBIAN_ADJOINT_2P5D: J= jacobian_adjoint_2p5d_1st_order( img )</li><li><a href="../../eidors/solvers/forward/jacobian_adjoint_higher_order.html" class="code" title="function J = jacobian_adjoint_higher_order(fwd_model,img)">jacobian_adjoint_higher_order</a>	Find the Jacobian associated with an image (and forward model)</li><li><a href="../../eidors/solvers/forward/jacobian_elem2nodes.html" class="code" title="function J= jacobian_elem2nodes( fwd_model, img)">jacobian_elem2nodes</a>	JACOBIAN_ELEM2NODES: calculate Jacobian on Nodes from Elem solver</li><li><a href="../../eidors/solvers/forward/jacobian_movement_2p5d_1st_order.html" class="code" title="function J = jacobian_movement_2p5d_1st_order( fwd_model, img)">jacobian_movement_2p5d_1st_order</a>	JACOBIAN_MOVEMENT_2P5D: J = jacobian_movement_2p5d_1st_order( img )</li><li><a href="../../eidors/solvers/forward/tools-beta/calc_error_norms_for_square_domain.html" class="code" title="function [L2_tot_error,H1semi_tot_error,H1_tot_error,I_err,U_errS,U_errM,U_errSM,timing_solver,DOF]=error_2D_squ_CEM(img,eletype,plot_on)">calc_error_norms_for_square_domain</a>	Get forward model of the img and the conductivity per element</li><li><a href="../../eidors/solvers/inverse/calc_GREIT_RM.html" class="code" title="function [RM, PJt, M] = calc_GREIT_RM(vh,vi, xyc, radius, weight, options)">calc_GREIT_RM</a>	CALCULATE GREIT reconstruction matrix</li><li><a href="../../eidors/solvers/inverse/inv_solve_core.html" class="code" title="function img= inv_solve_core( inv_model, data0, data1);">inv_solve_core</a>	INV_SOLVE_CORE Solver using a generic iterative algorithm</li><li><a href="../../eidors/solvers/inverse/inv_solve_diff_GN_one_step.html" class="code" title="function img= inv_solve_diff_GN_one_step( inv_model, data1, data2)">inv_solve_diff_GN_one_step</a>	INV_SOLVE_DIFF_GN_ONE_STEP inverse solver using approach of Adler&Guardo 1996</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function V= non_iterative(E,I);</a></li><li><a href="#_sub2" class="code">function V=iterative_solve(E,I,tol,V,fmdl)</a></li><li><a href="#_sub3" class="code">function do_unit_test</a></li><li><a href="#_sub4" class="code">function do_timing_unit_tests</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [V] = left_divide(E,I,tol,~,V)</a>
0002 <span class="comment">%[V] = LEFT_DIVIDE(E,I,tol,pp,V);</span>
0003 <span class="comment">%[V] = LEFT_DIVIDE(E,I,fmdl)</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% Implements left division for symmetric positive definite system solves</span>
0006 <span class="comment">% such as the sparse forward solve and dense solve for a GN descent</span>
0007 <span class="comment">% direction. LEFT_DIVIDE is optimised for symmetric matrices and overcomes</span>
0008 <span class="comment">% small inefficiencies of matlab's mldivide. For non-symmetric solves</span>
0009 <span class="comment">% please use mldivide.</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% Also uses conjugate gradients (for large problems).</span>
0012 <span class="comment">%</span>
0013 <span class="comment">% E   = The full rank system matrix</span>
0014 <span class="comment">% I   = The currents matrix (RHS)</span>
0015 <span class="comment">% tol = The tolerance in the forward solution, e.g. 1e-5</span>
0016 <span class="comment">%</span>
0017 <span class="comment">% pp,V are old options from previous solver. tilde used in arguments list</span>
0018 <span class="comment">% to ignore pp and keep matlab's code analyzer happy</span>
0019 
0020 <span class="comment">% (c) N. Polydorides 2003 % Copying permitted under terms of GNU GPL</span>
0021 <span class="comment">% $Id: left_divide.m 6442 2022-12-02 00:37:28Z aadler $</span>
0022 
0023 <span class="keyword">if</span> ischar(E) &amp;&amp; strcmp(E,<span class="string">'UNIT_TEST'</span>); <a href="#_sub3" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0024 
0025 <span class="keyword">if</span> nargin&lt;3;
0026    tol=1e-8;
0027 <span class="keyword">end</span>
0028 do_pcg = false;
0029 <span class="keyword">if</span> isstruct(tol);
0030    fmdl = tol;
0031    <span class="keyword">try</span>
0032       do_pcg = fmdl.left_divide.do_pcg;
0033    <span class="keyword">catch</span>
0034    <span class="keyword">end</span>
0035    <span class="keyword">try</span> 
0036       tol = fmdl.left_divide.tol;
0037    <span class="keyword">catch</span>
0038       tol = 1e-8;
0039    <span class="keyword">end</span>
0040    <span class="keyword">try</span> 
0041       V = fmdl.left_divide.V_initial;
0042    <span class="keyword">catch</span>
0043       sz= [size(E),size(I)];
0044       V = <a href="../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>(<span class="string">'get-cache'</span>, sz, <span class="string">'left_divide_V'</span>);
0045       <span class="keyword">if</span> isempty(V); V = zeros(size(E,1),size(I,2)); <span class="keyword">end</span>
0046    <span class="keyword">end</span>
0047 <span class="keyword">end</span>
0048 
0049 <span class="keyword">if</span> ~do_pcg
0050    <span class="keyword">try</span>
0051      V= <a href="#_sub1" class="code" title="subfunction V= non_iterative(E,I);">non_iterative</a>(E,I);
0052    <span class="keyword">catch</span> excp
0053        <span class="comment">% TODO: check if this catch block is needed</span>
0054        <span class="keyword">if</span> ~strcmp(excp.identifier , <span class="string">'MATLAB:nomem'</span>)
0055            rethrow(excp); <span class="comment">% rethrow error</span>
0056        <span class="keyword">end</span>
0057        
0058        <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'Memory exhausted for inverse. Trying PCG'</span>,2);
0059        V=<a href="#_sub2" class="code" title="subfunction V=iterative_solve(E,I,tol,V,fmdl)">iterative_solve</a>(E,I,tol,V,fmdl);
0060    <span class="keyword">end</span>
0061 <span class="keyword">else</span>
0062    V=<a href="#_sub2" class="code" title="subfunction V=iterative_solve(E,I,tol,V,fmdl)">iterative_solve</a>(E,I,tol,V,fmdl);
0063 <span class="keyword">end</span>
0064 
0065 <a name="_sub1" href="#_subfunctions" class="code">function V= non_iterative(E,I);</a>
0066     <span class="comment">% V= E\I;</span>
0067     <span class="comment">% This takes MUCH longer when you have  more vectors in I,</span>
0068     <span class="comment">%  even if they are repeated. There must be some way to simplify</span>
0069     <span class="comment">%  this to speed it up. Matlab's sparse operators really should</span>
0070     <span class="comment">%  do this for you.</span>
0071     
0072     <span class="comment">% TODO:</span>
0073     <span class="comment">% 1. change from QR implementation to basis implementation</span>
0074     <span class="comment">% 2. implement selection for required nodal values</span>
0075     <span class="comment">% 3. cache basis solve</span>
0076     <span class="comment">% 4. possibly change to itterative for successive solves on the same</span>
0077     <span class="comment">%    mesh</span>
0078     <span class="keyword">if</span> issparse(E)
0079         
0080         inotzeros = logical(any(I,2));
0081         <span class="comment">% Don't need to cache, this is fast</span>
0082         [Qi,R] = qr(I(inotzeros,:),0);
0083         rnotzeros = logical(any(R,2));
0084         <span class="comment">% Bug in octave sparse for v6.4</span>
0085         <span class="comment">% Not needed for v7.3</span>
0086         <span class="comment">% if exist('OCTAVE_VERSION')</span>
0087         <span class="comment">%    rnotzeros = full(rnotzeros);</span>
0088         <span class="comment">% end</span>
0089         R= R(rnotzeros,:);
0090         Q = zeros(size(I,1), size(R,1)); <span class="comment">% Faster if not sparse</span>
0091         Q(inotzeros,:) = Qi(:,rnotzeros);
0092         <span class="comment">%disp([size(I), size(Qi), size(R)])</span>
0093 <span class="comment">%        [Q,R] = qr(I,0);</span>
0094 <span class="comment">%        rnotzeros = any(R~=0,2);</span>
0095 <span class="comment">%        Q= Q(:,rnotzeros);</span>
0096 <span class="comment">%        R= R(rnotzeros,:);</span>
0097         V= (E \ Q)*R;
0098         
0099     <span class="keyword">else</span>
0100         <span class="keyword">if</span> isreal(E)
0101             <span class="keyword">try</span>
0102                 <span class="comment">% for dense solve of tikhonov regularised least squares</span>
0103                 <span class="comment">% matrix E is symmetric if it is of the form</span>
0104                 <span class="comment">% (J.'*W*J + hp^2*R.'R) and is real</span>
0105                 opts.SYM=true;
0106                 opts.POSDEF=true;
0107                 
0108                 V= linsolve(E,I,opts);
0109             <span class="keyword">catch</span> Mexcp
0110                 
0111                 <span class="comment">% error handling</span>
0112                 <span class="keyword">if</span>(strcmp(Mexcp.identifier,<span class="string">'MATLAB:posdef'</span>))
0113                     
0114                     warning(<span class="string">'EIDORS:leftDivideSymmetry'</span>,<span class="keyword">...</span>
0115                         [<span class="string">'left_divide is optimised for symmetric '</span>,<span class="keyword">...</span>
0116                         <span class="string">'positive definite matrices.'</span>]);
0117                     
0118                 <span class="keyword">else</span> 
0119                     warning([<span class="string">'Error with linsolve in left_divide, trying backslash.\n'</span>,<span class="keyword">...</span>
0120                         <span class="string">'Error identifier: '</span>,Mexcp.identifier]);
0121                 <span class="keyword">end</span>
0122                 
0123                 <span class="comment">% continue solve with backslash</span>
0124                 V=E\I;
0125             <span class="keyword">end</span>
0126         <span class="keyword">else</span>
0127             <span class="comment">% cholesky only works for real valued system matrices</span>
0128             V=E\I;
0129         <span class="keyword">end</span>
0130     <span class="keyword">end</span>
0131     
0132     <span class="comment">% TODO: Iteratively refine</span>
0133     <span class="comment">%  From GH Scott: &quot;once we have</span>
0134     <span class="comment">%   computed the approximate solution x, we perform one step</span>
0135     <span class="comment">%   of iterative refinement by computing the residual: r = Ax - b</span>
0136     <span class="comment">%   and then recalling the solve routine to solve</span>
0137     <span class="comment">%   Adx = r for the correction dx.</span>
0138     <span class="comment">% However, we don't want to repeat the '\', so we implement</span>
0139     <span class="comment">%   the underlying algorithm:</span>
0140     <span class="comment">%   If A is sparse, then MATLAB software uses CHOLMOD (after 7.2) to compute X.</span>
0141     <span class="comment">%    The computations result in  P'*A*P = R'*R</span>
0142     <span class="comment">%   where P is a permutation matrix generated by amd, and R is</span>
0143     <span class="comment">%   an upper triangular matrix. In this case, X = P*(R\(R'\(P'*B)))</span>
0144     <span class="comment">%</span>
0145     <span class="comment">% See also:</span>
0146     <span class="comment">% http://www.cs.berkeley.edu/~wkahan/MxMulEps.pdf</span>
0147     <span class="comment">% especially page 15 where it discusses the value of iterative refinement</span>
0148     <span class="comment">%  without extra precision bits.  ALso, we need to enable</span>
0149     
0150 <a name="_sub2" href="#_subfunctions" class="code">function V=iterative_solve(E,I,tol,V,fmdl)</a>
0151     
0152     [n_nodes,n_stims] = size(I);
0153     <span class="keyword">if</span> isreal(E)
0154         opts.droptol = tol*100;
0155         opts.type = <span class="string">'ict'</span>;
0156         U = ichol(E, opts);
0157         L = U';
0158         cgsolver = @pcg;
0159     <span class="keyword">else</span> <span class="comment">%Complex</span>
0160         opts.droptol = tol/10;
0161         [L,U] = ilu(E, opts);
0162         cgsolver = @bicgstab;
0163     <span class="keyword">end</span>
0164     
0165     <span class="keyword">for</span> i=1:n_stims
0166         [V(:,i),~] = feval( cgsolver, E,I(:,i), <span class="keyword">...</span>
0167             tol*norm(I(:,i)),n_nodes,L,U,V(:,i));
0168     <span class="keyword">end</span>
0169     sz= [size(E),size(I)];
0170     <a href="../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>(<span class="string">'set-cache'</span>, sz, <span class="string">'left_divide_V'</span>, V);
0171     
0172 
0173 <span class="comment">% Test code</span>
0174 <a name="_sub3" href="#_subfunctions" class="code">function do_unit_test</a>
0175 <span class="comment">%do_timing_unit_tests; return</span>
0176 
0177 <span class="comment">% test solvers are unaffected</span>
0178 <a href="../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(<span class="string">'UNIT_TEST'</span>)
0179 <a href="../../eidors/solvers/forward/fwd_solve_1st_order.html" class="code" title="function data =fwd_solve_1st_order(fwd_model, img)">fwd_solve_1st_order</a>(<span class="string">'UNIT_TEST'</span>)
0180 
0181 <span class="comment">% test non-symmetric handling</span>
0182 s=warning(<span class="string">'QUERY'</span>,<span class="string">'EIDORS:leftDivideSymmetry'</span>);
0183 warning(<span class="string">'OFF'</span>,<span class="string">'EIDORS:leftDivideSymmetry'</span>)
0184 lastwarn(<span class="string">''</span>)
0185 A=rand(1e3);
0186 b=rand(1e3);
0187 
0188 <a href="left_divide.html" class="code" title="function [V] = left_divide(E,I,tol,~,V)">left_divide</a>(A,b);
0189 [~, LASTID] = lastwarn;
0190 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'sym warn'</span>,LASTID,<span class="string">'EIDORS:leftDivideSymmetry'</span>)
0191 warning(s);
0192 
0193 <span class="comment">% test dense sym posdef solve</span>
0194 imdl=<a href="../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'n3r2'</span>,[16,2]);
0195 img=<a href="../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(imdl,1);
0196 img.elem_data=1+0.1*rand(size(img.elem_data));
0197 J   = <a href="../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>(img);
0198 RtR = <a href="../../eidors/solvers/calc_RtR_prior.html" class="code" title="function RtR_prior = calc_RtR_prior( inv_model )">calc_RtR_prior</a>(imdl);
0199 W   = <a href="../../eidors/solvers/calc_meas_icov.html" class="code" title="function meas_icov = calc_meas_icov( inv_model )">calc_meas_icov</a>(imdl);
0200 hp  = <a href="../../eidors/solvers/calc_hyperparameter.html" class="code" title="function hyperparameter = calc_hyperparameter( inv_model )">calc_hyperparameter</a>(imdl);
0201 LHS = (J'*W*J +  hp^2*RtR);
0202 RHS = J'*W;
0203 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'dense chol'</span>,LHS\RHS,<a href="left_divide.html" class="code" title="function [V] = left_divide(E,I,tol,~,V)">left_divide</a>(LHS,RHS),1e-13)
0204 
0205 
0206 <a name="_sub4" href="#_subfunctions" class="code">function do_timing_unit_tests</a>
0207 <span class="comment">% The point of these tests are to verify which</span>
0208 <span class="comment">%  matrices should be sparse and which full.</span>
0209 <span class="comment">% Conclusion is that Q should be full - AA (jun 2022)</span>
0210 
0211 <span class="comment">%eidors_cache off</span>
0212 Nel = 64;
0213 <span class="keyword">for</span> mn = 1:4; <span class="keyword">switch</span> mn
0214     <span class="keyword">case</span> 1;
0215         fmdl = <a href="../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'d2c0'</span>,64);
0216         fmdl = fmdl.fwd_model;
0217     <span class="keyword">case</span> 2;
0218         fmdl = <a href="../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'l2c0'</span>,64);
0219         fmdl = fmdl.fwd_model;
0220     <span class="keyword">case</span> 3;
0221         fmdl = <a href="../../eidors/models/mk_circ_tank.html" class="code" title="function param= mk_circ_tank(rings, levels, elec_spec );">mk_circ_tank</a>(16, linspace(-1,1,41), {<span class="string">'planes'</span>,Nel, 21});
0222         fmdl.solve = @<a href="../../eidors/tools/eidors_default.html" class="code" title="function varargout = eidors_default(varargin)">eidors_default</a>;
0223         fmdl.system_mat = @<a href="../../eidors/tools/eidors_default.html" class="code" title="function varargout = eidors_default(varargin)">eidors_default</a>;
0224     <span class="keyword">case</span> 4;
0225         fmdl = <a href="../../eidors/models/mk_circ_tank.html" class="code" title="function param= mk_circ_tank(rings, levels, elec_spec );">mk_circ_tank</a>(32, linspace(-1,1,41), {<span class="string">'planes'</span>,Nel, 21});
0226         fmdl.solve = @<a href="../../eidors/tools/eidors_default.html" class="code" title="function varargout = eidors_default(varargin)">eidors_default</a>;
0227         fmdl.system_mat = @<a href="../../eidors/tools/eidors_default.html" class="code" title="function varargout = eidors_default(varargin)">eidors_default</a>;
0228     <span class="keyword">end</span>
0229     stim= <a href="../../eidors/models/mk_stim_patterns.html" class="code" title="function [stim, meas_sel]= mk_stim_patterns(n_elec, n_rings, inj, meas, options, amplitude)">mk_stim_patterns</a>(Nel,1,[0,3],[0,3],{},1);
0230     <span class="keyword">for</span> sp = 1:2; <span class="keyword">switch</span> sp;
0231        <span class="keyword">case</span> 1; 
0232            fmdl.stimulation = stim; 
0233        <span class="keyword">case</span> 2;
0234             SSMM = <a href="../../eidors/models/stim_meas_list.html" class="code" title="function [stim, meas_sel]= stim_meas_list( sp_mp , Nelec, current, gain);">stim_meas_list</a>(stim);
0235             [~,idx] = sort(rand(size(SSMM,1),1));
0236             fmdl.stimulation = <a href="../../eidors/models/stim_meas_list.html" class="code" title="function [stim, meas_sel]= stim_meas_list( sp_mp , Nelec, current, gain);">stim_meas_list</a>(SSMM(idx,:)); 
0237         <span class="keyword">end</span>;
0238         img = <a href="../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(fmdl,1);
0239 <span class="comment">%       fwd_solve(img);</span>
0240         s_mat = <a href="../../eidors/solvers/calc_system_mat.html" class="code" title="function system_mat = calc_system_mat( fwd_model, img)">calc_system_mat</a>(img);
0241         idx= 1:size(s_mat.E,1);
0242         idx(img.fwd_model.gnd_node) = [];
0243         E = s_mat.E(idx,idx);
0244         pp= <a href="../../eidors/solvers/forward/fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>( img.fwd_model, <span class="string">'skip_VOLUME'</span> );
0245         I = pp.QQ(idx,:); 
0246 
0247         inotzeros = logical(any(I,2));
0248         [Qi,R] = qr(I(inotzeros,:),0);
0249         rnotzeros = logical(any(R,2));
0250         R= R(rnotzeros,:);
0251         Q = <a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(size(I,1), size(R,1));
0252         Q(inotzeros,:) = Qi(:,rnotzeros);
0253         t=[];
0254         tic; T = E \ Q; t(end+1) = toc;
0255         tic; V = T * R; t(end+1) = toc;
0256         tic; T = full(E \ Q); t(end+1) = toc;
0257         tic; V = T * R; t(end+1) = toc;
0258         tic; T = E \ full(Q); t(end+1) = toc;
0259         tic; V = T * R; t(end+1) = toc;
0260         disp(t)
0261     <span class="keyword">end</span>
0262 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 30-Dec-2022 20:46:51 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>
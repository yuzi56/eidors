<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of GREIT_desired_img_sigmoid</title>
  <meta name="keywords" content="GREIT_desired_img_sigmoid">
  <meta name="description" content="GREIT_DESIRED_IMG_SIGMOID sigmoid-decay desired image function for GREIT">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">eidors</a> &gt; <a href="../index.html">solvers</a> &gt; <a href="index.html">inverse</a> &gt; GREIT_desired_img_sigmoid.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/solvers/inverse&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>GREIT_desired_img_sigmoid
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>GREIT_DESIRED_IMG_SIGMOID sigmoid-decay desired image function for GREIT</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function PSF = GREIT_desired_img_sigmoid(xyz,radius, opt) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">GREIT_DESIRED_IMG_SIGMOID sigmoid-decay desired image function for GREIT 
 PSF= GREIT_desired_img_sigmoid(xyc, radius, opt)
   xyz     - array of centers of desired target images
               [2xN] - xy only
               [3xN] - xyz or, if radius = [], xyr
               [4xN] - xyzr (radius is ignored)
   radius  - the radius of the target on the desired image as a fraction
             of the model radius (half the larger dimension in xy)
   opt     - a struct with these fields:
      .rec_model   a 2D or 3D model as generated by MK_GRID_MODEL that may
                   have had some pixels/voxels removed (a rec_model that 
                   is not a complete rectangle/parallelepiped). 
      .steepness   [optional] a factor controling the amount of blur, see
                   below for details. Lower steepness gives more blur, but
                   if the value is too low, image may not reach the value 
                   of 1 at the center of the target. 
                   May be specified as a scalar, a [1xN] vector, or a
                   function handle with the signature:
                        func(pts)
                   where pts is either [2xN] or [3xN], dependig on the xyz
                   function input, e.g. @(xyz) 50./(xyz(3,:))
                   Default: 10./radius
      .desired_img_radius
                   [optional] Overwrites the radius input. May be 
                   specified as a scalar, a [1xN] vector or a function 
                   handle with the signature:
                        func(pts)
                   where pts is either [2xN] or [3xN], dependig on the xyz
                   function input, e.g. @(xyz) abs(xyz(3,:))/5
      .threshold   [optional] voxels where the function is smaller than
                   threshold will be set 0. Values bigger than 1-threshold
                   will be 1. The smaller the threshold the more
                   computationally expensive is the evaluation. 
                   Default: 1e-4;

 The desired images approximate in each pixel the area integral of:
       f(r) = 1 / (1 + exp(s*(|r-r0| - radius)))
 where
       r   - position vector in 2D/3D space
       s   - opt.steepness
       r0  - target center
 For |r-r0| = radius, f(r) = 0.5.
 
 As of 2015-03-29, this is the default desired image function used by
 MK_GREIT_MODEL.

 See also: <a href="calc_GREIT_RM.html" class="code" title="function [RM, PJt, M] = calc_GREIT_RM(vh,vi, xyc, radius, weight, options)">CALC_GREIT_RM</a>, MK_GREIT_MODEL, MK_PIXEL_SLICE</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG eidors progress and status messages</li><li><a href="../../../eidors/graphics/matlab/show_3d_slices.html" class="code" title="function h = show_3d_slices(img, varargin);">show_3d_slices</a>	show_3d_slices(img, z_cuts, x_cuts, y_cuts, any_cuts)</li><li><a href="../../../eidors/models/get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>	GET_ELEM_VOLUME: VOL = get_elem_volume(fwd_model, map_node )</li><li><a href="../../../eidors/models/mdl_dim.html" class="code" title="function num = mdl_dim( mdl );">mdl_dim</a>	MDL_DIM: dimension of model space (are nodes in 2D or 3D space)</li><li><a href="../../../eidors/models/mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>	MK_GRID_MODEL: Create reconstruction model on pixelated grid</li><li><a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>	MK_IMAGE: create eidors image object</li><li><a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>	SPARSE Create sparse matrix (EIDORS overload).</li><li><a href="GREIT_desired_img_sigmoid.html" class="code" title="function PSF = GREIT_desired_img_sigmoid(xyz,radius, opt)">GREIT_desired_img_sigmoid</a>	GREIT_DESIRED_IMG_SIGMOID sigmoid-decay desired image function for GREIT</li><li><a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>	EIDORS_CACHE Control eidors caching</li><li><a href="../../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>	PROGRESS_MSG Progress messages and timing.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="GREIT_desired_img_sigmoid.html" class="code" title="function PSF = GREIT_desired_img_sigmoid(xyz,radius, opt)">GREIT_desired_img_sigmoid</a>	GREIT_DESIRED_IMG_SIGMOID sigmoid-decay desired image function for GREIT</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function PSF = desired_soln(xyz, radius, opt)</a></li><li><a href="#_sub2" class="code">function [X, Y, Z] = voxnodes(mdl)</a></li><li><a href="#_sub3" class="code">function [x,y,z] = interp_elem_new(mdl,e,radius,opt)</a></li><li><a href="#_sub4" class="code">function [x,y,z] = interp_elem(mdl,e,radius, opt)</a></li><li><a href="#_sub5" class="code">function out = linvec(v1, v2, N)</a></li><li><a href="#_sub6" class="code">function [x, y] = grid2d(vx, vy)</a></li><li><a href="#_sub7" class="code">function [x, y, z] = grid3d(vx,vy,vz)</a></li><li><a href="#_sub8" class="code">function farel = far_elems(Xnodes,Ynodes,Znodes,xyz,radius, th)</a></li><li><a href="#_sub9" class="code">function farel = close_elems(Xnodes,Ynodes,Znodes,xyz,radius, th)</a></li><li><a href="#_sub10" class="code">function [xyz, radius, opt] = parse_opt(xyz, radius, opt)</a></li><li><a href="#_sub11" class="code">function do_unit_test</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function PSF = GREIT_desired_img_sigmoid(xyz,radius, opt)</a>
0002 <span class="comment">%GREIT_DESIRED_IMG_SIGMOID sigmoid-decay desired image function for GREIT</span>
0003 <span class="comment">% PSF= GREIT_desired_img_sigmoid(xyc, radius, opt)</span>
0004 <span class="comment">%   xyz     - array of centers of desired target images</span>
0005 <span class="comment">%               [2xN] - xy only</span>
0006 <span class="comment">%               [3xN] - xyz or, if radius = [], xyr</span>
0007 <span class="comment">%               [4xN] - xyzr (radius is ignored)</span>
0008 <span class="comment">%   radius  - the radius of the target on the desired image as a fraction</span>
0009 <span class="comment">%             of the model radius (half the larger dimension in xy)</span>
0010 <span class="comment">%   opt     - a struct with these fields:</span>
0011 <span class="comment">%      .rec_model   a 2D or 3D model as generated by MK_GRID_MODEL that may</span>
0012 <span class="comment">%                   have had some pixels/voxels removed (a rec_model that</span>
0013 <span class="comment">%                   is not a complete rectangle/parallelepiped).</span>
0014 <span class="comment">%      .steepness   [optional] a factor controling the amount of blur, see</span>
0015 <span class="comment">%                   below for details. Lower steepness gives more blur, but</span>
0016 <span class="comment">%                   if the value is too low, image may not reach the value</span>
0017 <span class="comment">%                   of 1 at the center of the target.</span>
0018 <span class="comment">%                   May be specified as a scalar, a [1xN] vector, or a</span>
0019 <span class="comment">%                   function handle with the signature:</span>
0020 <span class="comment">%                        func(pts)</span>
0021 <span class="comment">%                   where pts is either [2xN] or [3xN], dependig on the xyz</span>
0022 <span class="comment">%                   function input, e.g. @(xyz) 50./(xyz(3,:))</span>
0023 <span class="comment">%                   Default: 10./radius</span>
0024 <span class="comment">%      .desired_img_radius</span>
0025 <span class="comment">%                   [optional] Overwrites the radius input. May be</span>
0026 <span class="comment">%                   specified as a scalar, a [1xN] vector or a function</span>
0027 <span class="comment">%                   handle with the signature:</span>
0028 <span class="comment">%                        func(pts)</span>
0029 <span class="comment">%                   where pts is either [2xN] or [3xN], dependig on the xyz</span>
0030 <span class="comment">%                   function input, e.g. @(xyz) abs(xyz(3,:))/5</span>
0031 <span class="comment">%      .threshold   [optional] voxels where the function is smaller than</span>
0032 <span class="comment">%                   threshold will be set 0. Values bigger than 1-threshold</span>
0033 <span class="comment">%                   will be 1. The smaller the threshold the more</span>
0034 <span class="comment">%                   computationally expensive is the evaluation.</span>
0035 <span class="comment">%                   Default: 1e-4;</span>
0036 <span class="comment">%</span>
0037 <span class="comment">% The desired images approximate in each pixel the area integral of:</span>
0038 <span class="comment">%       f(r) = 1 / (1 + exp(s*(|r-r0| - radius)))</span>
0039 <span class="comment">% where</span>
0040 <span class="comment">%       r   - position vector in 2D/3D space</span>
0041 <span class="comment">%       s   - opt.steepness</span>
0042 <span class="comment">%       r0  - target center</span>
0043 <span class="comment">% For |r-r0| = radius, f(r) = 0.5.</span>
0044 <span class="comment">%</span>
0045 <span class="comment">% As of 2015-03-29, this is the default desired image function used by</span>
0046 <span class="comment">% MK_GREIT_MODEL.</span>
0047 <span class="comment">%</span>
0048 <span class="comment">% See also: CALC_GREIT_RM, MK_GREIT_MODEL, MK_PIXEL_SLICE</span>
0049 
0050 <span class="comment">% (C) 2015 Bartlomiej Grychtol - all rights reserved Swisstom AG.</span>
0051 <span class="comment">% License: GPL version 2 or 3</span>
0052 <span class="comment">% $Id: GREIT_desired_img_sigmoid.m 6367 2022-05-05 14:03:03Z aadler $</span>
0053 
0054 <span class="comment">% &gt;&gt; SWISSTOM CONTRIBUTION &lt;&lt;</span>
0055 
0056 <span class="keyword">if</span> ischar(xyz) &amp;&amp; strcmp(xyz,<span class="string">'UNIT_TEST'</span>), <a href="#_sub11" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>, <span class="keyword">end</span>
0057 
0058 [xyzr, radius, opt] = <a href="#_sub10" class="code" title="subfunction [xyz, radius, opt] = parse_opt(xyz, radius, opt)">parse_opt</a>(xyz, radius, opt);
0059 
0060 copt.cache_obj = {xyzr, radius, opt.rec_model.nodes, opt.rec_model.elems, opt.steepness};
0061 copt.fstr = <span class="string">'GREIT_desired_img_sigmoid'</span>;
0062 PSF = <a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub1" class="code" title="subfunction PSF = desired_soln(xyz, radius, opt)">desired_soln</a>,{xyzr, radius, opt},copt);
0063 
0064 
0065 <span class="keyword">end</span>
0066 
0067 <span class="comment">%-------------------------------------------------------------------------%</span>
0068 <span class="comment">% The main function</span>
0069 <a name="_sub1" href="#_subfunctions" class="code">function PSF = desired_soln(xyz, radius, opt)</a>
0070    num_it = size(xyz,2);
0071     <a href="../../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Composing desired images:'</span>,0,num_it);
0072     mdl = opt.rec_model;
0073     <span class="keyword">switch</span> opt.n_dim
0074         <span class="keyword">case</span> 3
0075             mdl.vox = [mdl.elems(1:6:<span class="keyword">end</span>,:) mdl.elems(6:6:<span class="keyword">end</span>,:)];
0076 
0077             min_vox_edge = min( [min(diff(unique(mdl.nodes(:,1)))), <span class="keyword">...</span>
0078                                  min(diff(unique(mdl.nodes(:,2)))), <span class="keyword">...</span>
0079                                  min(diff(unique(mdl.nodes(:,3))))] );
0080         <span class="keyword">case</span> 2
0081             mdl.vox = [mdl.elems(1:2:<span class="keyword">end</span>,:) mdl.elems(2:2:<span class="keyword">end</span>,:)];
0082             min_vox_edge = min( [min(diff(unique(mdl.nodes(:,1)))), <span class="keyword">...</span>
0083                                  min(diff(unique(mdl.nodes(:,2))))] );
0084 
0085     <span class="keyword">end</span>
0086     [Xnodes,Ynodes,Znodes] = <a href="#_sub2" class="code" title="subfunction [X, Y, Z] = voxnodes(mdl)">voxnodes</a>(mdl);
0087     
0088 
0089     
0090     warned = false;
0091     <a href="#_sub3" class="code" title="subfunction [x,y,z] = interp_elem_new(mdl,e,radius,opt)">interp_elem_new</a>(<span class="string">'reset'</span>,size(mdl.vox,1),[],opt);
0092     
0093     <span class="comment">% estimate the amount of memory needed to store PSF</span>
0094     n_el = size(mdl.vox,1);
0095     n_pt = size(xyz,2);
0096     n_ep = n_el*n_pt;
0097     ll = <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>,0);
0098     vox_box = sum(<a href="../../../eidors/models/get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>(mdl));
0099     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>,ll);
0100     tgt_box = (2*mean(radius+opt.threshold./opt.steepness))^3;
0101     n_nz = ceil(n_ep*tgt_box/vox_box);
0102     SPARSE_STEP = ceil(n_nz/5);
0103     PSF = spalloc(n_el,n_pt,n_nz);
0104     
0105     Npts = size(xyz,2);
0106     Nfailed = 0;
0107     <span class="keyword">for</span> i=1:Npts
0108         <span class="keyword">if</span> nnz(PSF) &gt; n_nz
0109            n_nz = nnz(PSF) + SPARSE_STEP;
0110            [r,c,v] = find(PSF);
0111            PSF = <a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(r,c,v,n_el,n_pt,n_nz); 
0112         <span class="keyword">end</span>
0113         th = opt.threshold/opt.steepness(i);
0114         <a href="../../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(i,num_it);
0115         farel = <a href="#_sub8" class="code" title="subfunction farel = far_elems(Xnodes,Ynodes,Znodes,xyz,radius, th)">far_elems</a>(Xnodes,Ynodes,Znodes, xyz(:,i), radius(i), th);
0116         <span class="comment">% also check for elements so close to the center they are approx 1</span>
0117         close_el = false(size(farel));
0118         <span class="keyword">if</span> radius(i) - th &gt; min_vox_edge
0119            close_el = <a href="#_sub9" class="code" title="subfunction farel = close_elems(Xnodes,Ynodes,Znodes,xyz,radius, th)">close_elems</a>(Xnodes,Ynodes,Znodes, xyz(:,i), radius(i), th);
0120         <span class="keyword">end</span>
0121         el_idx = find(~farel &amp; ~close_el);
0122         <span class="comment">% start with an initial size</span>
0123         STEP = 1000;
0124         idx = zeros(STEP,1);
0125         factor = zeros(STEP,1);
0126         X = zeros(STEP,1);
0127         Y = zeros(STEP,1);
0128         Z = zeros(STEP,1);
0129         L = STEP;
0130         N = 1;
0131 
0132         <span class="keyword">for</span> e = el_idx'
0133             [x,y,z] = <a href="#_sub3" class="code" title="subfunction [x,y,z] = interp_elem_new(mdl,e,radius,opt)">interp_elem_new</a>(mdl,e,radius(i), opt);
0134             n = numel(x);
0135             N1 = N; 
0136             N = N+n;
0137             <span class="keyword">if</span> N &gt; L <span class="comment">% expand arrays as needed</span>
0138                 fill = zeros(STEP,1);
0139                 idx = [idx; fill];
0140                 factor = [factor; fill];
0141                 X = [X; fill]; Y = [Y; fill]; Z = [Z; fill];
0142                 L = L + STEP;
0143             <span class="keyword">end</span>
0144             v = N1:N-1;
0145             idx(v) = e;
0146             factor(v) = 1/n;
0147             X(v) = x; Y(v) = y; Z(v) = z;
0148         <span class="keyword">end</span>
0149         <span class="comment">% remove spare length</span>
0150         v = N:L;
0151         idx(v) = [];
0152         factor(v) = [];
0153         X(v) = []; Y(v) = []; Z(v) = [];
0154         
0155         <span class="keyword">if</span> isempty(X)
0156 <span class="comment">%  REMOVED: Now only one warning at the end</span>
0157 <span class="comment">%           if 0 &amp;&amp; ~warned</span>
0158 <span class="comment">%              warning('EIDORS:OutsidePoint',...</span>
0159 <span class="comment">%                 'Desired image generation failed for point %d (and maybe others)',i);</span>
0160 <span class="comment">%              warned = true;</span>
0161 <span class="comment">%           end</span>
0162             <span class="comment">% PSF(:,i) = 0; % not needed</span>
0163             Nfailed = Nfailed + 1;
0164             <span class="keyword">continue</span>;
0165         <span class="keyword">end</span>
0166         V = [X Y Z];
0167         D = sqrt(sum(bsxfun(@minus,V(:,1:opt.n_dim),xyz(1:opt.n_dim,i)').^2, 2));
0168         x = D - radius(i);
0169         tmp = 1 ./ (1 + exp( opt.steepness(i) * x));
0170         PSF(:,i) = <a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(idx,1,tmp(:) .* factor,size(mdl.vox,1),1);
0171         PSF(close_el,i) = 1;
0172     <span class="keyword">end</span>
0173     <a href="#_sub3" class="code" title="subfunction [x,y,z] = interp_elem_new(mdl,e,radius,opt)">interp_elem_new</a>(<span class="string">'clear'</span>);
0174     <span class="keyword">if</span> Nfailed==0
0175         <a href="../../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(Inf);
0176     <span class="keyword">else</span>
0177         <a href="../../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(sprintf( <span class="keyword">...</span>
0178       <span class="string">'Interpolation failed for %d of %d points'</span>, <span class="keyword">...</span>
0179                 Nfailed,Npts), Inf);
0180     <span class="keyword">end</span>
0181   
0182 <span class="keyword">end</span>
0183 
0184 <span class="comment">%-------------------------------------------------------------------------%</span>
0185 <span class="comment">% Generate internal points in elements</span>
0186 <a name="_sub2" href="#_subfunctions" class="code">function [X, Y, Z] = voxnodes(mdl)</a>
0187     x = mdl.nodes(:,1); X = x(mdl.vox);
0188     y = mdl.nodes(:,2); Y = y(mdl.vox);
0189     <span class="keyword">try</span>
0190         z = mdl.nodes(:,3); Z = z(mdl.vox);
0191     <span class="keyword">catch</span>
0192         Z = [];
0193     <span class="keyword">end</span>  
0194 <span class="keyword">end</span>
0195 
0196 <a name="_sub3" href="#_subfunctions" class="code">function [x,y,z] = interp_elem_new(mdl,e,radius,opt)</a>
0197     <span class="keyword">persistent</span> N_entries X  Y Z MAP N minnode maxnode done_elems sep
0198     <span class="keyword">if</span> ischar(mdl) &amp;&amp; strcmp(mdl,<span class="string">'reset'</span>)
0199         N_entries = 0; X = []; Y = []; Z = []; MAP = [];
0200         N       = ones(1,3);
0201         minnode = zeros(e,opt.n_dim);
0202         maxnode = zeros(e,opt.n_dim);
0203         sep     = zeros(e,opt.n_dim);
0204         done_elems = false(e,1);
0205         <span class="keyword">return</span>;
0206     <span class="keyword">end</span>
0207     <span class="keyword">if</span> ischar(mdl) &amp;&amp; strcmp(mdl,<span class="string">'clear'</span>)
0208        clear N_entries X  Y Z MAP N minnode maxnode done_elems sep
0209        <span class="keyword">return</span>;
0210     <span class="keyword">end</span>
0211     maxsep = radius/5;
0212     
0213     <span class="keyword">if</span> ~done_elems(e)
0214        minnode(e,:) = min(mdl.nodes(mdl.vox(e,:),:));
0215        maxnode(e,:) = max(mdl.nodes(mdl.vox(e,:),:));
0216        sep(e,:) = maxnode(e,:) - minnode(e,:);
0217        done_elems(e) = true;
0218     <span class="keyword">end</span>
0219     
0220     N(1:opt.n_dim) = max(3, ceil(sep(e,:)/maxsep)+1);
0221     
0222     <span class="keyword">try</span>
0223         entry = MAP(N(1),N(2),N(3));
0224         x = X{entry};
0225         y = Y{entry};
0226         z = Z{entry};
0227     <span class="keyword">catch</span>
0228         entry = N_entries+1;
0229         
0230         vx = <a href="#_sub5" class="code" title="subfunction out = linvec(v1, v2, N)">linvec</a>(0,1,N(1));
0231         vx = vx + .5*(vx(2) -vx(1));
0232         
0233         vy = <a href="#_sub5" class="code" title="subfunction out = linvec(v1, v2, N)">linvec</a>(0,1,N(2));
0234         vy = vy + .5*(vy(2) -vy(1));
0235         
0236         
0237         <span class="keyword">switch</span> opt.n_dim
0238             <span class="keyword">case</span> 2
0239                 [x, y] = <a href="#_sub6" class="code" title="subfunction [x, y] = grid2d(vx, vy)">grid2d</a>(vx,vy);
0240                 z = zeros(size(x));
0241             <span class="keyword">case</span> 3
0242                 vz = <a href="#_sub5" class="code" title="subfunction out = linvec(v1, v2, N)">linvec</a>(0,1,N(3));
0243                 vz = vz + .5*(vz(2) -vz(1));
0244                 [x, y, z] = <a href="#_sub7" class="code" title="subfunction [x, y, z] = grid3d(vx,vy,vz)">grid3d</a>(vx,vy,vz);
0245         <span class="keyword">end</span>
0246         X{entry} = x;
0247         Y{entry} = y;
0248         Z{entry} = z;
0249         N_entries = entry;
0250         MAP(N(1),N(2),N(3)) = entry;
0251     <span class="keyword">end</span>
0252     x = x*sep(e,1) + minnode(e,1);
0253     y = y*sep(e,2) + minnode(e,2);
0254     <span class="keyword">if</span> opt.n_dim == 3
0255        z = z*sep(e,3) + minnode(e,3);
0256     <span class="keyword">end</span>
0257     
0258 <span class="keyword">end</span>
0259 
0260 <span class="comment">%-------------------------------------------------------------------------%</span>
0261 <span class="comment">% Generate internal points in elements</span>
0262 <a name="_sub4" href="#_subfunctions" class="code">function [x,y,z] = interp_elem(mdl,e,radius, opt)</a>
0263     maxsep = radius/5;
0264 
0265     minnode = min(mdl.nodes(mdl.vox(e,:),:));
0266     maxnode = max(mdl.nodes(mdl.vox(e,:),:));
0267     
0268     sep = maxnode - minnode;
0269     N = max(3, ceil(sep/maxsep)+1);
0270 
0271     vx = <a href="#_sub5" class="code" title="subfunction out = linvec(v1, v2, N)">linvec</a>(minnode(1),maxnode(1),N(1));
0272     vx = vx + .5*(vx(2) -vx(1));
0273         
0274     vy = <a href="#_sub5" class="code" title="subfunction out = linvec(v1, v2, N)">linvec</a>(minnode(2),maxnode(2),N(2));
0275     vy = vy + .5*(vy(2) -vy(1));
0276     
0277 
0278     <span class="keyword">switch</span> opt.n_dim
0279         <span class="keyword">case</span> 2
0280             [x, y] = <a href="#_sub6" class="code" title="subfunction [x, y] = grid2d(vx, vy)">grid2d</a>(vx,vy);
0281             z = [];
0282         <span class="keyword">case</span> 3
0283             vz = <a href="#_sub5" class="code" title="subfunction out = linvec(v1, v2, N)">linvec</a>(minnode(3),maxnode(3),N(3));
0284             vz = vz + .5*(vz(2) -vz(1));
0285             [x, y, z] = <a href="#_sub7" class="code" title="subfunction [x, y, z] = grid3d(vx,vy,vz)">grid3d</a>(vx,vy,vz);
0286     <span class="keyword">end</span>
0287 <span class="keyword">end</span>
0288 
0289 
0290 <a name="_sub5" href="#_subfunctions" class="code">function out = linvec(v1, v2, N)</a>
0291 <span class="comment">% equivalent to out= linspace(v1,v2,N); out(end) = []; minus error checking</span>
0292 out = v1 + (0:(N-2)).*(v2-v1)/(N-1);
0293 
0294 <span class="keyword">end</span>
0295 
0296 <a name="_sub6" href="#_subfunctions" class="code">function [x, y] = grid2d(vx, vy)</a>
0297 <span class="comment">% ndgrid minus overhead, asumes both vx and vy are row vectors</span>
0298     vx = vx.';
0299     x = repmat(vx,size(vy));
0300     y = repmat(vy,size(vx));
0301 <span class="keyword">end</span>
0302 
0303 <a name="_sub7" href="#_subfunctions" class="code">function [x, y, z] = grid3d(vx,vy,vz)</a>
0304 <span class="comment">% ndgrid minus overhead</span>
0305     sz = [numel(vx) numel(vy) numel(vz)];
0306     x = reshape(vx,[sz(1) 1 1]);
0307     x = repmat(x,[1 sz(2) sz(3)]);
0308     
0309     y = reshape(vy,[1 sz(2) 1]);
0310     y = repmat(y,[sz(1) 1 sz(3)]);
0311     
0312     z = reshape(vz,[1 1 sz(3)]);
0313     z = repmat(z,[sz(1) sz(2) 1]);
0314     
0315 
0316 <span class="keyword">end</span>
0317 
0318 
0319 <span class="comment">%-------------------------------------------------------------------------%</span>
0320 <span class="comment">% Find elements where the function value is negligable</span>
0321 <a name="_sub8" href="#_subfunctions" class="code">function farel = far_elems(Xnodes,Ynodes,Znodes,xyz,radius, th)</a>
0322     farel = false(size(Xnodes,1),1);
0323 
0324     nodes_test = Xnodes &lt; xyz(1) - radius - th;
0325     farel = farel | all(nodes_test,2);
0326     <span class="keyword">if</span> all(farel), <span class="keyword">return</span>, <span class="keyword">end</span>;
0327     nodes_test = Xnodes &gt; xyz(1) + radius + th;
0328     farel = farel | all(nodes_test,2);
0329     <span class="keyword">if</span> all(farel), <span class="keyword">return</span>, <span class="keyword">end</span>;
0330     nodes_test = Ynodes &lt; xyz(2) - radius - th;
0331     farel = farel | all(nodes_test,2);
0332     <span class="keyword">if</span> all(farel), <span class="keyword">return</span>, <span class="keyword">end</span>;
0333     nodes_test = Ynodes &gt; xyz(2) + radius + th;
0334     farel = farel | all(nodes_test,2);
0335     <span class="keyword">if</span> all(farel), <span class="keyword">return</span>, <span class="keyword">end</span>;
0336     <span class="keyword">if</span> ~isempty(Znodes)
0337         nodes_test  = Znodes &gt; xyz(3) + radius + th;
0338         farel = farel | all(nodes_test,2);
0339         <span class="keyword">if</span> all(farel), <span class="keyword">return</span>, <span class="keyword">end</span>;
0340         nodes_test  = Znodes &lt; xyz(3) - radius - th;
0341         farel = farel | all(nodes_test,2);
0342         <span class="keyword">if</span> all(farel), <span class="keyword">return</span>, <span class="keyword">end</span>;
0343     <span class="keyword">end</span>
0344     idx = find(~farel);
0345 <span class="keyword">end</span>
0346 
0347 <span class="comment">%-------------------------------------------------------------------------%</span>
0348 <span class="comment">% Find elements where the function value is essentially 1</span>
0349 <a name="_sub9" href="#_subfunctions" class="code">function farel = close_elems(Xnodes,Ynodes,Znodes,xyz,radius, th)</a>
0350   
0351    farel = true(size(Xnodes,1),1);
0352 
0353     nodes_test = Xnodes &lt; xyz(1) + radius - th;
0354     farel = farel &amp; all(nodes_test,2);
0355     <span class="keyword">if</span> ~any(farel), <span class="keyword">return</span>, <span class="keyword">end</span>;
0356     nodes_test = Xnodes &gt; xyz(1) - radius + th;
0357     farel = farel &amp; all(nodes_test,2);
0358     <span class="keyword">if</span> ~any(farel), <span class="keyword">return</span>, <span class="keyword">end</span>;
0359     nodes_test = Ynodes &lt; xyz(2) + radius - th;
0360     farel = farel &amp; all(nodes_test,2);
0361     <span class="keyword">if</span> ~any(farel), <span class="keyword">return</span>, <span class="keyword">end</span>;
0362     nodes_test = Ynodes &gt; xyz(2) - radius + th;
0363     farel = farel &amp; all(nodes_test,2);
0364     <span class="keyword">if</span> ~any(farel), <span class="keyword">return</span>, <span class="keyword">end</span>;
0365     <span class="keyword">if</span> ~isempty(Znodes)
0366         nodes_test  = Znodes &gt; xyz(3) - radius + th;
0367         farel = farel &amp; all(nodes_test,2);
0368         <span class="keyword">if</span> ~any(farel), <span class="keyword">return</span>, <span class="keyword">end</span>;
0369         nodes_test  = Znodes &lt; xyz(3) + radius - th;
0370         farel = farel &amp; all(nodes_test,2);
0371         <span class="keyword">if</span> ~any(farel), <span class="keyword">return</span>, <span class="keyword">end</span>;
0372     <span class="keyword">end</span>
0373     idx = find(farel);
0374 <span class="keyword">end</span>
0375 
0376 
0377 <span class="comment">%-------------------------------------------------------------------------%</span>
0378 <span class="comment">% Parse options</span>
0379 <a name="_sub10" href="#_subfunctions" class="code">function [xyz, radius, opt] = parse_opt(xyz, radius, opt)</a>
0380 
0381     scale_radius = false;
0382     <span class="keyword">if</span> isempty(radius)
0383         radius = xyz(<span class="keyword">end</span>,:);
0384         scale_radius = true;
0385         xyz(<span class="keyword">end</span>,:) = [];
0386     <span class="keyword">end</span>
0387     
0388     <span class="keyword">if</span> isfield(opt,<span class="string">'desired_img_radius'</span>)
0389        scale_radius = false;
0390        <span class="keyword">if</span> isnumeric(opt.desired_img_radius)
0391           radius = opt.desired_img_radius;
0392        <span class="keyword">end</span>
0393        <span class="keyword">if</span> isa(opt.desired_img_radius, <span class="string">'function_handle'</span>)
0394           radius = feval(opt.desired_img_radius,xyz);
0395        <span class="keyword">end</span>
0396     <span class="keyword">end</span>
0397         
0398  
0399     
0400     mdl = opt.rec_model; <span class="comment">% must exist</span>
0401     opt.n_dim =<a href="../../../eidors/models/mdl_dim.html" class="code" title="function num = mdl_dim( mdl );">mdl_dim</a>(mdl);
0402     xyz = xyz(1:opt.n_dim, :); <span class="comment">% ingore z if model is 2D</span>
0403 
0404     
0405 
0406     opt.meshsz = [];
0407     <span class="keyword">try</span>
0408         <span class="keyword">for</span> i = 1:3
0409             opt.meshsz = [opt.meshsz min(mdl.nodes(:,i)) max(mdl.nodes(:,i))];
0410         <span class="keyword">end</span>
0411     <span class="keyword">end</span>
0412     
0413     opt.n_dim = length(opt.meshsz)/2;
0414     opt.meshsz = reshape(opt.meshsz,2,[])';
0415 
0416     opt.minpt = opt.meshsz(:,1);
0417     opt.maxpt = opt.meshsz(:,2);
0418     opt.range = opt.maxpt - opt.minpt;
0419     opt.maxrange = max(opt.range(1:2));
0420 
0421     <span class="comment">%rescale points to between -1 and 1 in the x-y plane</span>
0422     xyz = 2*bsxfun(@minus, xyz, mean(opt.meshsz,2))/opt.maxrange;
0423     mdl.nodes = 2*bsxfun(@minus, mdl.nodes, mean(opt.meshsz(1:size(mdl.nodes,2),:),2)')/opt.maxrange;
0424     opt.rec_model = mdl;
0425     <span class="keyword">if</span> scale_radius
0426         radius = 2*radius / opt.maxrange;
0427     <span class="keyword">end</span>
0428 
0429     <span class="keyword">if</span> ~isfield(opt, <span class="string">'steepness'</span>)
0430         opt.steepness = 10./radius;
0431     <span class="keyword">elseif</span> isa(opt.steepness,<span class="string">'function_handle'</span>)
0432         opt.steepness = feval(opt.steepness,xyz);
0433     <span class="keyword">end</span>
0434     
0435     <span class="keyword">if</span> numel(opt.steepness) == 1
0436        opt.steepness = ones(1,size(xyz,2)) * opt.steepness;
0437     <span class="keyword">end</span>
0438     
0439     <span class="keyword">if</span> numel(radius) == 1
0440         radius = ones(1,size(xyz,2)) * radius;
0441     <span class="keyword">end</span>
0442     
0443     <span class="keyword">if</span> opt.n_dim == 2
0444        xyz(3,:) = 0;
0445     <span class="keyword">end</span>
0446    
0447     <span class="keyword">if</span> ~isfield(opt, <span class="string">'threshold'</span>)
0448        opt.threshold = 1e-4;
0449     <span class="keyword">end</span>
0450     
0451     opt.threshold = log(1/opt.threshold - 1); 
0452     
0453 <span class="keyword">end</span>
0454 
0455 <span class="comment">%-------------------------------------------------------------------------%</span>
0456 <span class="comment">% UNIT_TEST</span>
0457 <a name="_sub11" href="#_subfunctions" class="code">function do_unit_test</a>
0458     <a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a> clear_name <a href="GREIT_desired_img_sigmoid.html" class="code" title="function PSF = GREIT_desired_img_sigmoid(xyz,radius, opt)">GREIT_desired_img_sigmoid</a>
0459     v = linspace(-1,1,32);
0460     mdl= <a href="../../../eidors/models/mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>([],v,v,[0 .7 1:.2:2 2.3 3]);
0461     opt.rec_model = mdl;
0462     opt.steepness = @(xyz) 50./xyz(3,:);
0463     opt.desired_img_radius = @(xyz) xyz(3,:)/5;
0464 <span class="comment">%     xyzr = zeros(5,4);</span>
0465     xyzr(:,3) = .5:.5:2.5;
0466     xyzr(:,4) = .25;
0467     sol = <a href="GREIT_desired_img_sigmoid.html" class="code" title="function PSF = GREIT_desired_img_sigmoid(xyz,radius, opt)">GREIT_desired_img_sigmoid</a>(xyzr',[],opt);
0468     img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(mdl,0);
0469     <span class="keyword">for</span> i = 1:5
0470         subplot(2,3,i)
0471         img.elem_data= sol(:,i);
0472         <a href="../../../eidors/graphics/matlab/show_3d_slices.html" class="code" title="function h = show_3d_slices(img, varargin);">show_3d_slices</a>(img,xyzr(i,3),xyzr(i,2),xyzr(i,1));
0473     <span class="keyword">end</span>
0474     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'UNIT_TEST: Showed %d images to verify'</span>,i,0);
0475     <a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a> on <a href="GREIT_desired_img_sigmoid.html" class="code" title="function PSF = GREIT_desired_img_sigmoid(xyz,radius, opt)">GREIT_desired_img_sigmoid</a>
0476 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 30-Dec-2022 20:46:51 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>
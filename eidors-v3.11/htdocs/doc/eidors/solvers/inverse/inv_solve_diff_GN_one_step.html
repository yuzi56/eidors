<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of inv_solve_diff_GN_one_step</title>
  <meta name="keywords" content="inv_solve_diff_GN_one_step">
  <meta name="description" content="INV_SOLVE_DIFF_GN_ONE_STEP inverse solver using approach of Adler&amp;Guardo 1996">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">eidors</a> &gt; <a href="../index.html">solvers</a> &gt; <a href="index.html">inverse</a> &gt; inv_solve_diff_GN_one_step.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/solvers/inverse&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>inv_solve_diff_GN_one_step
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>INV_SOLVE_DIFF_GN_ONE_STEP inverse solver using approach of Adler&amp;Guardo 1996</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function img= inv_solve_diff_GN_one_step( inv_model, data1, data2) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> INV_SOLVE_DIFF_GN_ONE_STEP inverse solver using approach of Adler&amp;Guardo 1996
 img= inv_solve_diff_GN_one_step( inv_model, data1, data2)
 img        =&gt; output image (or vector of images)
 inv_model  =&gt; inverse model struct
 data1      =&gt; differential data at earlier time
 data2      =&gt; differential data at later time

 both data1 and data2 may be matrices (MxT) each of
  M measurements at T times
 if either data1 or data2 is a vector, then it is expanded
  to be the same size matrix

 By default, the correct scaling of the solution that best fits the data
 is not calculated, possibly resulting in high solution errors reported by
 inv_solve. 
 To calculate the correct scaling, specify
     inv_model.inv_solve_diff_GN_one_step.calc_step_size = 1;
 To provide a pre-calculated scaling, specify
     inv_model.inv_solve_diff_GN_one_step.calc_step_size = 0;
     inv_model.inv_solve_diff_GN_one_step.step_size = 0.8;
 The search for correct step_size is performed using FMINBND. The default
 search interval is [1e-5 1e1]. You can modify it by specifying:
     inv_model.inv_solve_diff_GN_one_step.bounds = [10 200];
 Additional options for FMINBD can be passed as:
     inv_model.inv_solve_diff_GN_one_step.fminbnd.MaxIter = 10;

 The optimal step_size is returned in img.info.step_size.

 See also INV_SOLVE, <a href="calc_solution_error.html" class="code" title="function [e res] = calc_solution_error(imgc, imdl, vh, vi)">CALC_SOLUTION_ERROR</a>, FMINBND</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/algorithms/left_divide.html" class="code" title="function [V] = left_divide(E,I,tol,~,V)">left_divide</a>	[V] = LEFT_DIVIDE(E,I,tol,pp,V);</li><li><a href="../../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG eidors progress and status messages</li><li><a href="../../../eidors/models/data_mapper.html" class="code" title="function img = data_mapper(img, reverse)">data_mapper</a>	DATA_MAPPER maps img.params data to elem or node data</li><li><a href="../../../eidors/overloads/octave/fminbnd.html" class="code" title="">fminbnd</a>	</li><li><a href="../../../eidors/solvers/calc_RtR_prior.html" class="code" title="function RtR_prior = calc_RtR_prior( inv_model )">calc_RtR_prior</a>	RtR = calc_RtR_prior( inv_model )</li><li><a href="../../../eidors/solvers/calc_difference_data.html" class="code" title="function dva = calc_difference_data( data1, data2, fwd_model)">calc_difference_data</a>	CALC_DIFFERENCE_DATA: calculate difference data between</li><li><a href="../../../eidors/solvers/calc_hyperparameter.html" class="code" title="function hyperparameter = calc_hyperparameter( inv_model )">calc_hyperparameter</a>	CALC_HYPERPARAMETER: calculate hyperparameter value</li><li><a href="../../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>	CALC_JACOBIAN: calculate jacobian from an inv_model</li><li><a href="../../../eidors/solvers/calc_jacobian_bkgnd.html" class="code" title="function img_bkgnd = calc_jacobian_bkgnd( inv_model )">calc_jacobian_bkgnd</a>	CALC_JACOBIAN_BKGND: calculate background image around</li><li><a href="../../../eidors/solvers/calc_meas_icov.html" class="code" title="function meas_icov = calc_meas_icov( inv_model )">calc_meas_icov</a>	meas_icov = calc_meas_icov( inv_model )</li><li><a href="calc_solution_error.html" class="code" title="function [e res] = calc_solution_error(imgc, imdl, vh, vi)">calc_solution_error</a>	CALC_SOLUTION_ERROR Calculate residuals for a solution</li><li><a href="get_RM.html" class="code" title="function [RM, J, RtR, W, Jfine] = get_RM(inv_model)">get_RM</a>	% GET_RM: obtains the reconstruction matrix from a given inverse model</li><li><a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>	EIDORS_CACHE Control eidors caching</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/deprecated/aa_inv_solve.html" class="code" title="function img= inv_solve_diff_GN_one_step( varargin )">aa_inv_solve</a>	AA_INV_SOLVE inverse solver using approach of Adler&Guardo 1996</li><li><a href="../../../eidors/examples/demo_3d_simdata.html" class="code" title="">demo_3d_simdata</a>	How to make simulation data using EIDORS3D</li><li><a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="../../../eidors/models/select_imdl.html" class="code" title="function inv_mdl= select_imdl( mdl, options )">select_imdl</a>	SELECT_IMDL: select pre-packaged inverse model features</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function RM = get_RM( inv_model )</a></li><li><a href="#_sub2" class="code">function [img, step_size] = scale_to_fit_data(img, inv_model, data1, data2)</a></li><li><a href="#_sub3" class="code">function out = to_optimize(img, inv_model, data1, data2, x)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function img= inv_solve_diff_GN_one_step( inv_model, data1, data2)</a>
0002 <span class="comment">% INV_SOLVE_DIFF_GN_ONE_STEP inverse solver using approach of Adler&amp;Guardo 1996</span>
0003 <span class="comment">% img= inv_solve_diff_GN_one_step( inv_model, data1, data2)</span>
0004 <span class="comment">% img        =&gt; output image (or vector of images)</span>
0005 <span class="comment">% inv_model  =&gt; inverse model struct</span>
0006 <span class="comment">% data1      =&gt; differential data at earlier time</span>
0007 <span class="comment">% data2      =&gt; differential data at later time</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% both data1 and data2 may be matrices (MxT) each of</span>
0010 <span class="comment">%  M measurements at T times</span>
0011 <span class="comment">% if either data1 or data2 is a vector, then it is expanded</span>
0012 <span class="comment">%  to be the same size matrix</span>
0013 <span class="comment">%</span>
0014 <span class="comment">% By default, the correct scaling of the solution that best fits the data</span>
0015 <span class="comment">% is not calculated, possibly resulting in high solution errors reported by</span>
0016 <span class="comment">% inv_solve.</span>
0017 <span class="comment">% To calculate the correct scaling, specify</span>
0018 <span class="comment">%     inv_model.inv_solve_diff_GN_one_step.calc_step_size = 1;</span>
0019 <span class="comment">% To provide a pre-calculated scaling, specify</span>
0020 <span class="comment">%     inv_model.inv_solve_diff_GN_one_step.calc_step_size = 0;</span>
0021 <span class="comment">%     inv_model.inv_solve_diff_GN_one_step.step_size = 0.8;</span>
0022 <span class="comment">% The search for correct step_size is performed using FMINBND. The default</span>
0023 <span class="comment">% search interval is [1e-5 1e1]. You can modify it by specifying:</span>
0024 <span class="comment">%     inv_model.inv_solve_diff_GN_one_step.bounds = [10 200];</span>
0025 <span class="comment">% Additional options for FMINBD can be passed as:</span>
0026 <span class="comment">%     inv_model.inv_solve_diff_GN_one_step.fminbnd.MaxIter = 10;</span>
0027 <span class="comment">%</span>
0028 <span class="comment">% The optimal step_size is returned in img.info.step_size.</span>
0029 <span class="comment">%</span>
0030 <span class="comment">% See also INV_SOLVE, CALC_SOLUTION_ERROR, FMINBND</span>
0031 
0032 <span class="comment">% (C) 2005-2013 Andy Adler and Bartlomiej Grychtol.</span>
0033 <span class="comment">% License: GPL version 2 or version 3</span>
0034 <span class="comment">% $Id: inv_solve_diff_GN_one_step.m 5611 2017-06-27 12:02:50Z htregidgo $</span>
0035 
0036 <span class="comment">% TODO:</span>
0037 <span class="comment">% Test whether Wiener filter form or Tikhonov form are faster</span>
0038 <span class="comment">%  Tikhonov: RM= (J'*W*J +  hp^2*RtR)\J'*W;</span>
0039 <span class="comment">%  Wiener:   P= inv(RtR); V = inv(W); RM = P*J'/(J*P*J' + hp^2*V)</span>
0040 
0041 dv = <a href="../../../eidors/solvers/calc_difference_data.html" class="code" title="function dva = calc_difference_data( data1, data2, fwd_model)">calc_difference_data</a>( data1, data2, inv_model.fwd_model);
0042 sol = <a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="get_RM.html" class="code" title="function [RM, J, RtR, W, Jfine] = get_RM(inv_model)">get_RM</a>, inv_model,<span class="string">'inv_solve_diff_GN_one_step'</span> ) * dv;
0043 
0044 
0045 
0046 img = <a href="../../../eidors/models/data_mapper.html" class="code" title="function img = data_mapper(img, reverse)">data_mapper</a>(<a href="../../../eidors/solvers/calc_jacobian_bkgnd.html" class="code" title="function img_bkgnd = calc_jacobian_bkgnd( inv_model )">calc_jacobian_bkgnd</a>( inv_model ));
0047 img.name= <span class="string">'solved by inv_solve_diff_GN_one_step'</span>;
0048 img.elem_data = sol;
0049 img.fwd_model= inv_model.fwd_model;
0050 img = <a href="../../../eidors/models/data_mapper.html" class="code" title="function img = data_mapper(img, reverse)">data_mapper</a>(img,1);
0051 
0052 img = <a href="#_sub2" class="code" title="subfunction [img, step_size] = scale_to_fit_data(img, inv_model, data1, data2)">scale_to_fit_data</a>(img, inv_model, data1, data2);
0053 
0054 
0055 <a name="_sub1" href="#_subfunctions" class="code">function RM = get_RM( inv_model )</a>
0056    img_bkgnd= <a href="../../../eidors/solvers/calc_jacobian_bkgnd.html" class="code" title="function img_bkgnd = calc_jacobian_bkgnd( inv_model )">calc_jacobian_bkgnd</a>( inv_model );
0057    J = <a href="../../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>( img_bkgnd);
0058 
0059    RtR = <a href="../../../eidors/solvers/calc_RtR_prior.html" class="code" title="function RtR_prior = calc_RtR_prior( inv_model )">calc_RtR_prior</a>( inv_model );
0060    W   = <a href="../../../eidors/solvers/calc_meas_icov.html" class="code" title="function meas_icov = calc_meas_icov( inv_model )">calc_meas_icov</a>( inv_model );
0061    hp  = <a href="../../../eidors/solvers/calc_hyperparameter.html" class="code" title="function hyperparameter = calc_hyperparameter( inv_model )">calc_hyperparameter</a>( inv_model );
0062     
0063    <span class="comment">% left_divide now has handling to force symmetric methods when matrices</span>
0064    <span class="comment">% are symmetric up to floating point error.</span>
0065    RM  = <a href="../../../eidors/algorithms/left_divide.html" class="code" title="function [V] = left_divide(E,I,tol,~,V)">left_divide</a>((J'*W*J +  hp^2*RtR),J'*W);
0066    
0067    
0068 
0069    
0070    
0071 <a name="_sub2" href="#_subfunctions" class="code">function [img, step_size] = scale_to_fit_data(img, inv_model, data1, data2)</a>
0072    <span class="comment">% find the step size to multiply sol by to best fit data</span>
0073    step_size = 1;
0074    do_step   = false;
0075    <span class="comment">% If calc_step_size, ignore specified step_size</span>
0076    <span class="keyword">try</span> do_step = inv_model.inv_solve_diff_GN_one_step.calc_step_size; <span class="keyword">end</span>
0077    
0078    <span class="keyword">if</span> do_step
0079       <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'inv_solve_diff_GN_one_step: Calculating optimal step size to fit data'</span>,2);
0080       <span class="comment">% options for fminbnd</span>
0081       <span class="keyword">try</span> 
0082          opt = inv_model.inv_solve_diff_GN_one_step.fminbnd;
0083       <span class="keyword">catch</span>
0084          opt.Display = <span class="string">'iter'</span>;
0085       <span class="keyword">end</span>
0086       <span class="comment">% range for fminbnd</span>
0087       <span class="keyword">try</span>
0088          range = inv_model.inv_solve_diff_GN_one_step.bounds;
0089       <span class="keyword">catch</span>
0090          range = [1e-5 1e1];
0091       <span class="keyword">end</span>
0092       step_size = <a href="../../../eidors/overloads/octave/fminbnd.html" class="code" title="">fminbnd</a>(@(x) <a href="#_sub3" class="code" title="subfunction out = to_optimize(img, inv_model, data1, data2, x)">to_optimize</a>(img,inv_model,data1,data2, x), <span class="keyword">...</span>
0093                            range(1), range(2), opt);
0094    <span class="keyword">else</span>
0095       <span class="comment">% if not calculating, check if step_size provided</span>
0096       <span class="keyword">try</span>
0097          step_size = inv_model.inv_solve_diff_GN_one_step.step_size;
0098       <span class="keyword">end</span>
0099    <span class="keyword">end</span>
0100    img.elem_data = img.elem_data * step_size;
0101    img.info.step_size = step_size;
0102 
0103 <a name="_sub3" href="#_subfunctions" class="code">function out = to_optimize(img, inv_model, data1, data2, x)</a>
0104    img.elem_data = img.elem_data*x;
0105    out = <a href="calc_solution_error.html" class="code" title="function [e res] = calc_solution_error(imgc, imdl, vh, vi)">calc_solution_error</a>(img, inv_model, data1, data2);
0106</pre></div>
<hr><address>Generated on Fri 30-Dec-2022 20:46:51 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>
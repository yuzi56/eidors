<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of prior_gaussian_HPF</title>
  <meta name="keywords" content="prior_gaussian_HPF">
  <meta name="description" content="PRIOR_GAUSSIAN_HPF calculate image prior">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">eidors</a> &gt; <a href="../index.html">solvers</a> &gt; <a href="index.html">inverse</a> &gt; prior_gaussian_HPF.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/solvers/inverse&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>prior_gaussian_HPF
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>PRIOR_GAUSSIAN_HPF calculate image prior</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function Reg= prior_gaussian_HPF( fwd_model ); </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> PRIOR_GAUSSIAN_HPF calculate image prior
 Reg= prior_gaussian_HPF( fwd_model )
     or accepts inv_model
 Reg        =&gt; output regularization term
 fwd_model  =&gt; forward model struct
 Parameters:
   diam_frac= fwd_model.prior_gaussian_HPF.diam_frac DEFAULT 0.1
   zero_thresh=fwd_model.prior_gaussian_HPF.zero_thresh DEFAULT 0.0001


 prior_gaussian_HPF is designed to be used as an R_prior, rather than a RtR_prior

 CITATION_REQUEST:
 AUTHOR: A Adler &amp; R Guardo
 YEAR: 1996
 TITLE: Electrical impedance tomography: regularized imaging and contrast
 detection 
 JOURNAL: IEEE transactions on medical imaging
 VOL: 15
 NUM: 2
 PAGE: 170–9
 LINK: http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=491418</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/models/elem_dim.html" class="code" title="function num = elem_dim( mdl );">elem_dim</a>	ELEM_DIM: dimension of elements in space (are elements in 2D or 3D space)</li><li><a href="../../../eidors/models/get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>	GET_ELEM_VOLUME: VOL = get_elem_volume(fwd_model, map_node )</li><li><a href="../../../eidors/models/interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>	INTERP_MESH: calculate interpolation points onto mdl elements</li><li><a href="../../../eidors/models/mdl_dim.html" class="code" title="function num = mdl_dim( mdl );">mdl_dim</a>	MDL_DIM: dimension of model space (are nodes in 2D or 3D space)</li><li><a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="../../../eidors/models/mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>	MK_GRID_MODEL: Create reconstruction model on pixelated grid</li><li><a href="../../../eidors/models/num_elems.html" class="code" title="function num = num_elems( mdl );">num_elems</a>	NUM_ELEMS: number of elemnts in a (fwd or inv model or image)</li><li><a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>	SPARSE Create sparse matrix (EIDORS overload).</li><li><a href="prior_gaussian_HPF.html" class="code" title="function Reg= prior_gaussian_HPF( fwd_model );">prior_gaussian_HPF</a>	PRIOR_GAUSSIAN_HPF calculate image prior</li><li><a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>	EIDORS_CACHE Control eidors caching</li><li><a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>	UNIT_TEST_CMP: compare matrices in eidors output</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/deprecated/gaussian_HPF_prior.html" class="code" title="function Reg= gaussian_HPF_prior( inv_model );">gaussian_HPF_prior</a>	GAUSSIAN_HPF_PRIOR calculate image prior</li><li><a href="prior_gaussian_HPF.html" class="code" title="function Reg= prior_gaussian_HPF( fwd_model );">prior_gaussian_HPF</a>	PRIOR_GAUSSIAN_HPF calculate image prior</li><li><a href="../../../eidors/tests/calc_model_prior_test.html" class="code" title="function ok= calc_model_prior_test;">calc_model_prior_test</a>	Verify model prior calcs</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function filt= calc_Gaussian_HPF( fmdl, diam_frac, zero_thresh)</a></li><li><a href="#_sub2" class="code">function filt= calc_Gaussian_HPF_old( fmdl, diam_frac)</a></li><li><a href="#_sub3" class="code">function [x,xc,y,yc] = interp_points(NODE,ELEM,np);</a></li><li><a href="#_sub4" class="code">function do_unit_test</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function Reg= prior_gaussian_HPF( fwd_model );</a>
0002 <span class="comment">% PRIOR_GAUSSIAN_HPF calculate image prior</span>
0003 <span class="comment">% Reg= prior_gaussian_HPF( fwd_model )</span>
0004 <span class="comment">%     or accepts inv_model</span>
0005 <span class="comment">% Reg        =&gt; output regularization term</span>
0006 <span class="comment">% fwd_model  =&gt; forward model struct</span>
0007 <span class="comment">% Parameters:</span>
0008 <span class="comment">%   diam_frac= fwd_model.prior_gaussian_HPF.diam_frac DEFAULT 0.1</span>
0009 <span class="comment">%   zero_thresh=fwd_model.prior_gaussian_HPF.zero_thresh DEFAULT 0.0001</span>
0010 <span class="comment">%</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% prior_gaussian_HPF is designed to be used as an R_prior, rather than a RtR_prior</span>
0013 <span class="comment">%</span>
0014 <span class="comment">% CITATION_REQUEST:</span>
0015 <span class="comment">% AUTHOR: A Adler &amp; R Guardo</span>
0016 <span class="comment">% YEAR: 1996</span>
0017 <span class="comment">% TITLE: Electrical impedance tomography: regularized imaging and contrast</span>
0018 <span class="comment">% detection</span>
0019 <span class="comment">% JOURNAL: IEEE transactions on medical imaging</span>
0020 <span class="comment">% VOL: 15</span>
0021 <span class="comment">% NUM: 2</span>
0022 <span class="comment">% PAGE: 170–9</span>
0023 <span class="comment">% LINK: http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=491418</span>
0024 
0025 <span class="comment">% NOTES:</span>
0026 <span class="comment">% - the old version had numerous bugs. It has been fixed and simplified for version 3.11</span>
0027 <span class="comment">% - Old code should be removed in future</span>
0028 <span class="comment">% TODO:</span>
0029 <span class="comment">% - Accept and work with coarse2fine</span>
0030 
0031 <span class="comment">% (C) 2005 Andy Adler. License: GPL version 2 or version 3</span>
0032 <span class="comment">% $Id: prior_gaussian_HPF.m 6510 2022-12-30 16:34:22Z aadler $</span>
0033 
0034 <span class="keyword">if</span> ischar(fwd_model) &amp;&amp; strcmp(fwd_model,<span class="string">'UNIT_TEST'</span>); <a href="#_sub4" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0035 
0036 <span class="keyword">if</span> ~strcmp(fwd_model.type, <span class="string">'fwd_model'</span>)
0037     fwd_model= fwd_model.fwd_model;
0038 <span class="keyword">end</span>
0039 <span class="keyword">try</span> 
0040     diam_frac= fwd_model.prior_gaussian_HPF.diam_frac;
0041 <span class="keyword">catch</span>
0042     diam_frac= 0.1;
0043 <span class="keyword">end</span>
0044 <span class="keyword">try</span> 
0045     diam_frac= fwd_model.prior_gaussian_HPF.zero_thresh;
0046 <span class="keyword">catch</span>
0047     zero_thresh = .0001;
0048 <span class="keyword">end</span>
0049 
0050 copt.cache_obj= {fwd_model.nodes, fwd_model.elems, diam_frac};
0051 copt.fstr = <span class="string">'prior_gaussian_HPF'</span>;
0052 Reg = <a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub1" class="code" title="subfunction filt= calc_Gaussian_HPF( fmdl, diam_frac, zero_thresh)">calc_Gaussian_HPF</a>, {fwd_model, diam_frac, zero_thresh}, copt );
0053 
0054 <a name="_sub1" href="#_subfunctions" class="code">function filt= calc_Gaussian_HPF( fmdl, diam_frac, zero_thresh)</a>
0055   pts = <a href="../../../eidors/models/interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>(fmdl,3); <span class="comment">% elem ctr</span>
0056   fmdl.interp_mesh.n_interp = 0; <span class="comment">% for ctr</span>
0057   ptc = <a href="../../../eidors/models/interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>(fmdl,0);
0058   <span class="comment">% we divide by four to closely match</span>
0059   <span class="comment">% previous implementation</span>
0060   <a href="../../../eidors/models/mdl_dim.html" class="code" title="function num = mdl_dim( mdl );">mdl_dim</a> = max(fmdl.nodes) - min(fmdl.nodes);
0061   <a href="../../../eidors/models/mdl_dim.html" class="code" title="function num = mdl_dim( mdl );">mdl_dim</a> = mean(<a href="../../../eidors/models/mdl_dim.html" class="code" title="function num = mdl_dim( mdl );">mdl_dim</a>(1:2)); 
0062    
0063   beta=2.769/(diam_frac * <a href="../../../eidors/models/mdl_dim.html" class="code" title="function num = mdl_dim( mdl );">mdl_dim</a>)^2;
0064   dim = <a href="../../../eidors/models/elem_dim.html" class="code" title="function num = elem_dim( mdl );">elem_dim</a>(fmdl);
0065 
0066   <span class="comment">% Gaussian is integral of exp(-beta*r^2)</span>
0067   <span class="comment">% Integral of exp(-1/2 * x'*Sigma*x)</span>
0068   <span class="comment">%  = sqrt((2*pi)^k*det(Sigma))</span>
0069   <span class="comment">% Here Sigma = 2*eye()*beta</span>
0070   <span class="comment">%  det(Sigma) = (2*beta)^k</span>
0071   <span class="comment">% so int[exp(-beta*r2)]= (pi*beta)^(d/2)</span>
0072 
0073   <span class="comment">% integral of exp(-r2) =</span>
0074   Abeta_pi = <a href="../../../eidors/models/get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>(fmdl,<span class="string">'no_c2f'</span>) <span class="keyword">...</span>
0075              *(beta/pi)^(dim/2);
0076   <span class="keyword">for</span> j= 1:<a href="../../../eidors/models/num_elems.html" class="code" title="function num = num_elems( mdl );">num_elems</a>(fmdl)
0077     dif = bsxfun(@minus, pts, ptc(j,:));
0078     r2  = sum(dif.^2, 2);
0079     mean_elem = mean( exp(-beta*r2 ),3);
0080     flt(:,j)=Abeta_pi.*mean_elem;
0081   <span class="keyword">end</span> <span class="comment">%for j=1:ELEM</span>
0082   <span class="comment">% flt should sum to 1, but the integral is numeric and could vary. Instead we normalize</span>
0083   flt = flt./sum(flt);
0084   <span class="comment">% Filter is 1 - Gaussian</span>
0085   flt=eye(<a href="../../../eidors/models/num_elems.html" class="code" title="function num = num_elems( mdl );">num_elems</a>(fmdl)) - flt;
0086   flt= ( flt+flt' )/ 2;
0087   filt= <a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(flt.*(abs(flt)&gt;zero_thresh)); 
0088 
0089 <span class="comment">% Calculate Gaussian HP Filter as per Adler &amp; Guardo 96</span>
0090 <span class="comment">% parameter is diam_frac (normally 0.1)</span>
0091 <a name="_sub2" href="#_subfunctions" class="code">function filt= calc_Gaussian_HPF_old( fmdl, diam_frac)</a>
0092   ELEM= fmdl.elems';
0093   NODE= fmdl.nodes';
0094 
0095 
0096   e= size(ELEM, 2);
0097   np= 128;
0098   [x,xc,y,yc] = <a href="#_sub3" class="code" title="subfunction [x,xc,y,yc] = interp_points(NODE,ELEM,np);">interp_points</a>(NODE,ELEM,np);
0099 
0100   v_yx= [-y,x];
0101   o= ones(np*np,1);
0102   filt= zeros(e);
0103   tourne= [0 -1 1;1 0 -1;-1 1 0];
0104 
0105   <span class="keyword">for</span> j= 1:e
0106 <span class="comment">%   if ~rem(j,20); fprintf('.'); end</span>
0107     xy= NODE(:,ELEM(:,j))';
0108     a= xy([2;3;1],1).*xy([3;1;2],2) <span class="keyword">...</span>
0109          -xy([3;1;2],1).*xy([2;3;1],2);
0110     aire=abs(sum(a));
0111     mx_xy = max(xy);
0112     mn_xy = min(xy);
0113     endr=find(y&lt;=mx_xy(2) &amp; y&gt;=mn_xy(2) <span class="keyword">...</span>
0114             &amp; x&lt;=mx_xy(1) &amp; x&gt;=mn_xy(1) )';
0115     aa= sum(abs(ones(length(endr),1)*a' <span class="keyword">...</span>
0116          +v_yx(endr,:)*xy'*tourne)');
0117     endr( find( abs(1 - aa / aire) &gt; 1e-8 ) )=[];
0118     ll=length(endr); endr=endr-1;
0119 
0120     yp= rem(endr,np)/(np-1) - .5; <span class="comment">% (rem(endr,np) corresponde a y</span>
0121     ym= ones(e,1)*yp -yc*ones(1,ll);
0122     xp= floor(endr/np)/(np-1) - .5; <span class="comment">% (floor(endr/np)) corresponde a x</span>
0123     xm= ones(e,1)*xp -xc*ones(1,ll);
0124 
0125     beta=2.769/diam_frac.^2;
0126 <span class="comment">%   filt(:,j)=-aire/2*beta/pi*mean(...</span>
0127     filt(:,j)=-beta/pi*sum( exp(-beta*(ym.^2+xm.^2))')';
0128   <span class="keyword">end</span> <span class="comment">%for j=1:ELEM</span>
0129 <span class="comment">% filt=filt/taille(1)/taille(2)+eye(e);</span>
0130   filt=filt/np^2+eye(e);
0131   filt= ( filt+filt' )/ 2;
0132   filt= <a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(filt.*(abs(filt)&gt;.003)); 
0133 
0134 <a name="_sub3" href="#_subfunctions" class="code">function [x,xc,y,yc] = interp_points(NODE,ELEM,np);</a>
0135   taille=max(NODE')-min(NODE');
0136   e= size(ELEM, 2);
0137 
0138 <span class="comment">% Triangles of each shape</span>
0139   xt= reshape(NODE(1,ELEM(:)),3,e)';
0140   yt= reshape(NODE(2,ELEM(:)),3,e)';
0141 
0142 <span class="comment">% We want center [1,1,1]/3 and edges [4,1,1]/6</span>
0143   pts= [2,2,2;4,1,1;1,4,1;1,1,4]'/6;
0144   xp= xt*pts;
0145   yp= yt*pts;
0146   
0147   [x y]=meshgrid( <span class="keyword">...</span>
0148       linspace( min(NODE(1,:)), max(NODE(1,:)) ,np ), <span class="keyword">...</span>
0149       linspace( min(NODE(2,:)), max(NODE(2,:)) ,np )  ); 
0150 <span class="comment">% Add the basic interpolation points to those based on the</span>
0151 <span class="comment">%  elements</span>
0152   x= [x(:);xp(:)]; 
0153   y= [y(:);yp(:)]; 
0154 
0155 <span class="comment">% BUG HERE: why is xc,yc scaled and not x,y</span>
0156 
0157   xc= mean(xt,2)/taille(1);
0158   yc= mean(yt,2)/taille(2);
0159 
0160 <a name="_sub4" href="#_subfunctions" class="code">function do_unit_test</a>
0161   imdl = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'a2c0'</span>,16);
0162   RtR = <a href="prior_gaussian_HPF.html" class="code" title="function Reg= prior_gaussian_HPF( fwd_model );">prior_gaussian_HPF</a>(imdl);
0163   tt=[0.557367798877852, -0.124016055611277, -0.029231532288002, -0.124016055611277];
0164   <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'a2c2 :1'</span>, RtR(1,1:4),tt,1e-10);
0165 
0166   <span class="comment">% Old values are somewhat similar</span>
0167   RtR= <a href="#_sub2" class="code" title="subfunction filt= calc_Gaussian_HPF_old( fmdl, diam_frac)">calc_Gaussian_HPF_old</a>( imdl.fwd_model, 0.1);
0168   tt=[0.562239752317943, -0.117068756722254, -0.025875127622824, -0.117068756722254];
0169   <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'a2c2 _old :1'</span>, RtR(1,1:4),tt,1e-10);
0170 
0171   imdl = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'a3cr'</span>,16);
0172   RtR = <a href="prior_gaussian_HPF.html" class="code" title="function Reg= prior_gaussian_HPF( fwd_model );">prior_gaussian_HPF</a>(imdl);  <span class="comment">%NOTE: Fix required</span>
0173   tt=[0.793660877689329,-0.096517734290331;
0174      -0.096517734290331, 0.793660877689329;
0175      -0.004236643618993,-0.011516904603663;
0176      -0.011516904603663,-0.004236643618993];
0177   <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'a3cr :1'</span>, RtR(1:4,1:2),tt,1e-10);
0178 
0179   ls = -1:.1:1;
0180   fmdl = <a href="../../../eidors/models/mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>([], ls, ls); 
0181   fmdl = rmfield(fmdl,<span class="string">'coarse2fine'</span>);
0182   RtR = <a href="prior_gaussian_HPF.html" class="code" title="function Reg= prior_gaussian_HPF( fwd_model );">prior_gaussian_HPF</a>(fmdl);
0183   
0184   <span class="comment">% Test space-independence ... 2D</span>
0185   ll= 2*(length(ls)-1);
0186   <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'2D space indep'</span>, <span class="keyword">...</span>
0187      RtR(10*ll+(1:4),10*ll+(1:4)), <span class="keyword">...</span>
0188      RtR(12*ll+(1:4),12*ll+(1:4)), 1e-14);
0189 
0190 
0191   ls = -1:.2:1;
0192   fmdl = <a href="../../../eidors/models/mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>([],ls,ls,(-4:2:4)/10); 
0193   fmdl = rmfield(fmdl,<span class="string">'coarse2fine'</span>);
0194   RtR = <a href="prior_gaussian_HPF.html" class="code" title="function Reg= prior_gaussian_HPF( fwd_model );">prior_gaussian_HPF</a>(fmdl);
0195   
0196   <span class="comment">% Test space-independence ... 2D</span>
0197   ll= 6*(length(ls)-1);
0198   lv= 6*(length(ls)-1)^2;
0199   <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'3D space indep'</span>, <span class="keyword">...</span>
0200      RtR(lv+3*ll+(1:4),lv+3*ll+(1:4)), <span class="keyword">...</span>
0201      RtR(lv+5*ll+(1:4),lv+5*ll+(1:4)), 1e-14);
0202</pre></div>
<hr><address>Generated on Fri 30-Dec-2022 20:46:51 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>
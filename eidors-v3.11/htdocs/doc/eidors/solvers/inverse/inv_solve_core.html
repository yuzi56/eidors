<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of inv_solve_core</title>
  <meta name="keywords" content="inv_solve_core">
  <meta name="description" content="INV_SOLVE_CORE Solver using a generic iterative algorithm">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">eidors</a> &gt; <a href="../index.html">solvers</a> &gt; <a href="index.html">inverse</a> &gt; inv_solve_core.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/solvers/inverse&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>inv_solve_core
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>INV_SOLVE_CORE Solver using a generic iterative algorithm</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function img= inv_solve_core( inv_model, data0, data1); </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">INV_SOLVE_CORE Solver using a generic iterative algorithm
 img        =&gt; output image (or vector of images)
 inv_model  =&gt; inverse model struct
 data0      =&gt; EIT data
 data0, data1 =&gt; difference EIT data

 This function is parametrized and uses function pointers where possible to
 allow its use as a general iterative solver framework. There are a large
 number of parameters and functions contained here. Sensible defaults are
 used throughout. You do not need to set every parameter.

 The solver operates as an absolute Gauss-Newton iterative solver by default.
 Wrapper functions are available to call this function in its various forms.
 Look forward to the &quot;See also&quot; section at the end of this help.

 Argument matrices to the internal functions (measurement inverse covariance,
 for example) are only calculated if required. Functions that are supplied to
 this <a href="inv_solve_core.html" class="code" title="function img= inv_solve_core( inv_model, data0, data1);">INV_SOLVE_CORE</a> must be able to survive being probed: they will have
 each parameter set to either 0 or 1 to determine if the function is sensitive
 to that argument. This works cleanly for most matrix multiplication based
 functions but for more abstract code, some handling of this behaviour may
 need to be implemented.

 In the following parameters, r_k is the current residual, r_{k-1} is the
 previous iteration's residual. k is the iteration count.

 Parameters denoted with a ** to the right of their default values are
 deprecated legacy parameters, some of which formerly existed under
 'inv_model.parameters.*'.

 Parameters (inv_model.<a href="inv_solve_core.html" class="code" title="function img= inv_solve_core( inv_model, data0, data1);">inv_solve_core</a>.*):
   verbose (show progress)                (default 1)
      0: quiet
    &gt;=1: print iteration count and residual
    &gt;=2: print details as the algorithm progresses
    &gt;=3: plot residuals versus iteration count
    &gt;=4: plot result at each iteration, see show_fem
    &gt;=5: plot line search per iteration
   plot_residuals                         (default 0)
    plot residuals without verbose output
   fig_prefix                       (default: &lt;none&gt;)
    figure file prefix; figures not saved if &lt;none&gt;
   fwd_solutions                          (default 0)
    0: ignore
    1: count fwd_solve(), generally the most
       computationally expensive component of
       the iterations
   residual_func =             (default @GN_residual)
    NOTE: @meas_residual exists to maintain
    compatibility with some older code
   max_iterations                        (default 10)  **
   ntol (estimate of machine precision) (default eps)
   tol (stop iter if r_k &lt; tol)           (default 0)
   dtol                              (default -0.01%)
    stop iter if (r_k - r_{k-1})/r_1 &lt; dtol AND
                 k &gt;= dtol_iter
   dtol_iter                              (default 0)
    apply dtol stopping criteria if k &gt;= dtol_iter
   min_value                           (default -inf)  **
   max_value                           (default +inf)  **
   line_optimize_func                (default &lt;none&gt;)  ** TODO
     [next,fmin,res]=f(org,dx,data0,opt);
     opt=line_optimize.* + objective_func
     Deprecated, use line_search_func instead.
   <a href="line_optimize.html" class="code" title="function [img fmin res] = line_optimize(imgk, dx, data0, opt)">line_optimize</a>.perturb
                   (default line_search_args.perturb)  ** TODO
     Deprecated, use line_search_args.perturb instead.
   update_func                         (default TODO)  ** TODO
     [img,opt]=f(org,next,dx,fmin,res,opt)
     Deprecated, use &lt;TODO&gt; instead.
   update_method                   (default cholesky)
     Method to use for solving dx: 'pcg' or 'cholesky'
     If 'cholesky', will fall back to 'pcg' if
     out-of-memory. Matlab has trouble detecting the
     out-of-memory condition on many machines, and is
     likely to just grind to a halt swapping. Beware.
   do_starting_estimate                   (default 1)  ** TODO
     Deprecated, use &lt;TODO&gt; instead.
   line_search_func       (default @line_search_onm2)
   line_search_dv_func      (default @update_dv_core)
   line_search_de_func      (default @update_de_core)
   line_search_args.perturb
                     (default [0 1/16 1/8 1/4 1/2 1])
    line search for alpha by these steps along sx
   line_search_args.plot                  (default 0)
   c2f_background                         (default 0)
    if &gt; 0, this is additional elem_data
    if a c2f map exists, the default is to decide
    based on an estimate of c2f overlap whether a
    background value is required. If a background is
    required, it is added as the last element of that
    type.
   c2f_background_fixed                   (default 1)
    hold the background estimate fixed or allow it
    to vary as any other elem_data
   elem_fixed                            (default [])
    meas_select already handles selecting from the
    valid measurements. we want the same for the
    elem_data, so we only work on modifying the
    legal values.
    Note that c2f_background's elements are added to
    this list if c2f_background_fixed == 1.
   prior_data             (default to jacobian_bkgnd)
    Sets the priors of type elem_prior. May be
    scalar, per elem_prior, or match the working
    length of each elem_data type. Note that for priors
    using the c2f a background element may be added
    to the end of that range when required; see
    c2f_background.
   elem_len                (default to all elem_data)
    A cell array list of how many of each
    elem_working there are in elem_data.
      prior_data = { 32.1, 10*ones(10,1) };
      elem_prior = {'conductivity', 'movement'};
      elem_len = { 20001, 10 };
   elem_prior                (default 'conductivity')
    Input 'prior_data' type; immediately converted to
    'elem_working' type before first iteration.
   elem_working              (default 'conductivity')
   elem_output               (default 'conductivity')
    The working and output units for 'elem_data'.
    Valid types are 'conductivity' and 'resistivity'
    as plain units or with the prefix 'log_' or
    'log10_'. Conversions are handled internally.
    Scaling factors are applied to the Jacobian
    (calculated in units of 'conductivity') as
    appropriate.
    If elem_working == elem_output, then no
    conversions take place.
    For multiple types, use cell array.
    ex: elem_output = {'log_resistivity', 'movement'}
   meas_input                     (default 'voltage')
   meas_working                   (default 'voltage')
    Similarly to elem_working/output, conversion
    between 'voltage' and 'apparent_resistivity' and
    their log/log10 variants are handled internally.
    If meas_input == meas_working no conversions take
    place. The normalization factor 'N' is calculated
    if 'apparent_resistivity' is used.
   update_img_func             (default: pass-through)
    Called prior to calc_jacobian and update_dv.
    Elements are converted to their &quot;base types&quot;
    before this function is called. For example,
    'log_resistivity' becomes 'conductivity'.
    It is a hook to allow additional updates to the
    model before the Jacobian, or a new set of
    measurements are calculated via fwd_solve.
   return_working_variables               (default: 0)
    If 1, return the last working variables to the user
     img.inv_solve_{type}.J   Jacobian
     img.inv_solve_{type}.dx  descent direction
     img.inv_solve_{type}.sx  search direction
     img.inv_solve_{type}.alpha  line search result
     img.inv_solve_{type}.beta   conjugation parameter
     img.inv_solve_{type}.r   as:
       [ residual, measurement misfit, element misfit ]
       with one row per iteration
   show_fem                       (default: @show_fem)
    Function with which to plot each iteration's
    current parameters.

   Signature for residual_func
    [r,m,e] = f(dv, de, W, hps2RtR, hpt2LLt)
   where
    r   - the residual = m + e
    m   - measurement error
    e   - prior misfit
    dv  - change in voltage
    de  - change in image elements
    W   - measurement inverse covariance matrix
    hps2  - spatial hyperparameter squared, see CALC_HYPERPARAMETER
    RtR   - regularization matrix squared --&gt; hps2RtR = hps2*RtR
    hpt2  - temporal hyperparameter squared
    LLt   - temporal regularization matrix squared --&gt; hpt2LLt = hpt2*LLt

   Signature for line_optimize_func
    [alpha, img, dv, opt] = f(img, sx, data0, img0, N, W, hps2RtR, hpt2LLt, dv, opt)
   where:
    alpha - line search result
    img   - the current image
            (optional, recalculated if not available)
    sx    - the search direction to which alpha should be applied
    data0 - the true measurements     (dv = N*data - N*data0)
    img0  - the image background (de = img - img0)
    N     - a measurement normalization factor, N*dv
    W     - measurement inverse covariance matrix
    hps2  - spatial hyperparameter squared, see CALC_HYPERPARAMETER
    RtR   - regularization matrix squared --&gt; hps2RtR = hps2*RtR
    hpt2  - temporal hyperparameter squared
    LLt   - temporal regularization matrix squared --&gt; hpt2LLt = hpt2*LLt
    dv    - change in voltage
            (optional, recalculated if not available)
    opt   - additional arguments, updated at each call

   Signature for line_search_dv_func
    [dv, opt] = update_dv_core(img, data0, N, opt)
   where:
    dv    - change in voltage
    opt   - additional arguments, updated at each call
    data  - the estimated measurements
    img   - the current image
    data0 - the true measurements
    N     - a measurement normalization factor, N*dv

   Signature for line_search_de_func
    de = f(img, img0, opt)
   where:
    de    - change in image elements
    img   - the current image
    img0  - the image background (de = img - img0)
    opt   - additional arguments

   Signature for calc_jacobian_scaling_func
    S = f(x)
   where:
    S - to be used to scale the Jacobian
    x - current img.elem_data in units of 'conductivity'

   Signature for  update_img_func
    img2 = f(img1, opt)
   where
    img1 - an input image, the current working image
    img2 - a (potentially) modified version to be used
    for the fwd_solve/Jacobian calculations

 NOTE that the default line search is very crude. For
 my test problems it seems to amount to an expensive grid
 search. Much more efficient line search algorithms exist
 and some fragments already are coded elsewhere in the
 EIDORS code-base.

 See also: INV_SOLVE_ABS_GN, INV_SOLVE_ABS_GN_LOGC,
           INV_SOLVE_ABS_CG, INV_SOLVE_ABS_CG_LOGC,
           <a href="line_search_o2.html" class="code" title="function  [alpha, img, dv, opt] = line_search_o2(imgk, dx, data1, img1, N, W, hps2RtR, hpt2LLt, dv0, opt)">LINE_SEARCH_O2</a>, <a href="line_search_onm2.html" class="code" title="function  [alpha, img, dv, opt] = line_search_onm2(imgk, dx, data1, img1, N, W, hps2RtR, hpt2LLt, dv0, opt, retry, pf_max)">LINE_SEARCH_ONM2</a>

 (C) 2010-2016 Alistair Boyle, Nolwenn Lesparre, Andy Adler, Bartłomiej Grychtol.
 License: GPL version 2 or version 3</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/algorithms/left_divide.html" class="code" title="function [V] = left_divide(E,I,tol,~,V)">left_divide</a>	[V] = LEFT_DIVIDE(E,I,tol,pp,V);</li><li><a href="../../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG eidors progress and status messages</li><li><a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>	SHOW_FEM: show the EIDORS3D finite element model</li><li><a href="../../../eidors/graphics/matlab/show_fem_move.html" class="code" title="function [hf,hh] = show_fem_move( img, move, scale, options )">show_fem_move</a>	SHOW_FEM_MOVE   Plot EIT finite element model (FEM) and movement</li><li><a href="../../../eidors/meshing/netgen/ng_mk_cyl_models.html" class="code" title="function [fmdl,mat_idx] = ng_mk_cyl_models(cyl_shape, elec_pos,elec_shape, extra_ng_code);">ng_mk_cyl_models</a>	NG_MAKE_CYL_MODELS: create cylindrical models using netgen</li><li><a href="../../../eidors/models/data_mapper.html" class="code" title="function img = data_mapper(img, reverse)">data_mapper</a>	DATA_MAPPER maps img.params data to elem or node data</li><li><a href="../../../eidors/models/elec_rearrange.html" class="code" title="function [elec_idx, new_fmdl] = elec_rearrange( pattern, newarrange, fwd_model )">elec_rearrange</a>	ELEC_REARRANGE: rearrange electrodes for given pattern</li><li><a href="../../../eidors/models/interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>	INTERP_MESH: calculate interpolation points onto mdl elements</li><li><a href="../../../eidors/models/mk_approx_c2f.html" class="code" title="function [mapping, outside] = mk_approx_c2f( f_mdl, c_mdl );">mk_approx_c2f</a>	MK_APPROX_C2F: create a mapping matrix from coarse to fine FEM</li><li><a href="../../../eidors/models/mk_coarse_fine_mapping.html" class="code" title="function [mapping, outside] = mk_coarse_fine_mapping(varargin)">mk_coarse_fine_mapping</a>	MK_COARSE_FINE_MAPPING: create a mapping matrix from coarse to fine FEM</li><li><a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="../../../eidors/models/mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>	imdl = mk_geophysics_model(str, ne, [option])</li><li><a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>	MK_IMAGE: create eidors image object</li><li><a href="../../../eidors/models/mk_stim_patterns.html" class="code" title="function [stim, meas_sel]= mk_stim_patterns(n_elec, n_rings, inj, meas, options, amplitude)">mk_stim_patterns</a>	MK_STIM_PATTERNS: create an EIDORS stimulation pattern structure</li><li><a href="../../../eidors/models/private/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>	SPDIAG Sparse diagonal matrices and diagonals of a matrix.</li><li><a href="../../../eidors/models/select_imdl.html" class="code" title="function inv_mdl= select_imdl( mdl, options )">select_imdl</a>	SELECT_IMDL: select pre-packaged inverse model features</li><li><a href="../../../eidors/models/simulate_movement.html" class="code" title="function [vh,vi,xyzr,c2f]= simulate_movement( img, xyzr, UNUSED );">simulate_movement</a>	SIMULATE_MOVEMENT simulate small conductivity perturbations</li><li><a href="../../../eidors/models/supported_params.html" class="code" title="function list = supported_params">supported_params</a>	</li><li><a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>	SPARSE Create sparse matrix (EIDORS overload).</li><li><a href="../../../eidors/overloads/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>	SPDIAG Sparse diagonal matrices and diagonals of a matrix.</li><li><a href="../../../eidors/solvers/calc_LLt_prior.html" class="code" title="function LLt_prior = calc_LLt_prior( data0, inv_model )">calc_LLt_prior</a>	LLt = calc_LLt_prior( data0, inv_model )</li><li><a href="../../../eidors/solvers/calc_RtR_prior.html" class="code" title="function RtR_prior = calc_RtR_prior( inv_model )">calc_RtR_prior</a>	RtR = calc_RtR_prior( inv_model )</li><li><a href="../../../eidors/solvers/calc_difference_data.html" class="code" title="function dva = calc_difference_data( data1, data2, fwd_model)">calc_difference_data</a>	CALC_DIFFERENCE_DATA: calculate difference data between</li><li><a href="../../../eidors/solvers/calc_hyperparameter.html" class="code" title="function hyperparameter = calc_hyperparameter( inv_model )">calc_hyperparameter</a>	CALC_HYPERPARAMETER: calculate hyperparameter value</li><li><a href="../../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>	CALC_JACOBIAN: calculate jacobian from an inv_model</li><li><a href="../../../eidors/solvers/calc_meas_icov.html" class="code" title="function meas_icov = calc_meas_icov( inv_model )">calc_meas_icov</a>	meas_icov = calc_meas_icov( inv_model )</li><li><a href="../../../eidors/solvers/forward/fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>	FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)</li><li><a href="../../../eidors/solvers/forward/jacobian_adjoint.html" class="code" title="function J= jacobian_adjoint( fwd_model, img)">jacobian_adjoint</a>	JACOBIAN_ADJOINT: J= jacobian_adjoint( img )</li><li><a href="../../../eidors/solvers/forward/jacobian_movement.html" class="code" title="function J = jacobian_movement(fwd_model, img)">jacobian_movement</a>	JACOBIAN_MOVEMENT   Computes the Jacobian matrix for conductivity and</li><li><a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>	FWD_SOLVE: calculate data from a fwd_model object and an image</li><li><a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>	INV_SOLVE: calculate imag from an inv_model and data</li><li><a href="inv_solve_core.html" class="code" title="function img= inv_solve_core( inv_model, data0, data1);">inv_solve_core</a>	INV_SOLVE_CORE Solver using a generic iterative algorithm</li><li><a href="inv_solve_gn.html" class="code" title="function img= inv_solve_gn( inv_model, data1, data2);">inv_solve_gn</a>	function img= inv_solve_gn( inv_model, data1);</li><li><a href="line_search_onm2.html" class="code" title="function  [alpha, img, dv, opt] = line_search_onm2(imgk, dx, data1, img1, N, W, hps2RtR, hpt2LLt, dv0, opt, retry, pf_max)">line_search_onm2</a>	function  [alpha, img, dv, opt] = line_search_onm2(imgk, dx, data1, img1, N, W, hps2RtR, hpt2LLt, dv0, opt)</li><li><a href="prior_movement.html" class="code" title="function Reg= prior_movement( inv_model );">prior_movement</a>	PRIOR_MOVEMENT calculate image prior</li><li><a href="../../../eidors/tools/eidors_default.html" class="code" title="function varargout = eidors_default(varargin)">eidors_default</a>	EIDORS_DEFAULT Default function handler.</li><li><a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>	UNIT_TEST_CMP: compare matrices in eidors output</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/deprecated/inv_solve_abs_core.html" class="code" title="function img= inv_solve_abs_core(imdl,varargin);">inv_solve_abs_core</a>	inv_solve_abs_core is deprecated in favour of inv_solve_core</li><li><a href="inv_solve_cg.html" class="code" title="function img= inv_solve_cg( inv_model, data1, data2);">inv_solve_cg</a>	function img= inv_solve_cg( inv_model, data1);</li><li><a href="inv_solve_core.html" class="code" title="function img= inv_solve_core( inv_model, data0, data1);">inv_solve_core</a>	INV_SOLVE_CORE Solver using a generic iterative algorithm</li><li><a href="inv_solve_gn.html" class="code" title="function img= inv_solve_gn( inv_model, data1, data2);">inv_solve_gn</a>	function img= inv_solve_gn( inv_model, data1);</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function show_meas_err(dvall, data0, k, N, W, opt)</a></li><li><a href="#_sub2" class="code">function n_frames = count_data_frames(data1)</a></li><li><a href="#_sub3" class="code">function img = init_elem_data(img, opt)</a></li><li><a href="#_sub4" class="code">function W = init_meas_icov(inv_model, opt)</a></li><li><a href="#_sub5" class="code">function [N, dN] = init_normalization(fmdl, data0, opt)</a></li><li><a href="#_sub6" class="code">function [stop, k, r, img] = update_residual(dv, img, de, W, hps2RtR, hpt2LLt, k, r, alpha, sx, opt)</a></li><li><a href="#_sub7" class="code">function beta = update_beta(dx_k, dx_km1, sx_km1, opt);</a></li><li><a href="#_sub8" class="code">function sx = update_sx(dx, beta, sx_km1, opt);</a></li><li><a href="#_sub9" class="code">function hps2RtR = update_hps2RtR(inv_model, J, k, img, opt)</a></li><li><a href="#_sub10" class="code">function hpt2LLt = update_hpt2LLt(inv_model, data0, k, opt)</a></li><li><a href="#_sub11" class="code">function plot_dx_and_svd_elem(J, W, hps2RtR, k, sx, dx, img, opt)</a></li><li><a href="#_sub12" class="code">function plot_svd(J, W, hps2RtR, k, hp)</a></li><li><a href="#_sub13" class="code">function RtR = calc_RtR_prior_wrapper(inv_model, img, opt)</a></li><li><a href="#_sub14" class="code">function [J, opt] = update_jacobian(img, dN, k, opt)</a></li><li><a href="#_sub15" class="code">function S = dx_dlogx(x);</a></li><li><a href="#_sub16" class="code">function S = dx_dlog10x(x);</a></li><li><a href="#_sub17" class="code">function S = dx_dy(x);</a></li><li><a href="#_sub18" class="code">function S = dx_dlogy(x);</a></li><li><a href="#_sub19" class="code">function S = dx_dlog10y(x);</a></li><li><a href="#_sub20" class="code">function dN = da_dv(v,vh)</a></li><li><a href="#_sub21" class="code">function dN = dloga_dv(v,vh)</a></li><li><a href="#_sub22" class="code">function dN = dlog10a_dv(v,vh)</a></li><li><a href="#_sub23" class="code">function dN = dv_dv(v,vh)</a></li><li><a href="#_sub24" class="code">function dN = dlogv_dv(v,vh)</a></li><li><a href="#_sub25" class="code">function dN = dlog10v_dv(v,vh)</a></li><li><a href="#_sub26" class="code">function [alpha, img, dv, opt] = update_alpha(img, sx, data0, img0, N, W, hps2RtR, hpt2LLt, k, dv, opt)</a></li><li><a href="#_sub27" class="code">function err_if_inf_or_nan(x, str);</a></li><li><a href="#_sub28" class="code">function [img, dv] = update_img_using_limits(img, img0, data0, N, dv, opt)</a></li><li><a href="#_sub29" class="code">function  de = update_de(de, img, img0, opt)</a></li><li><a href="#_sub30" class="code">function [dv, opt] = update_dv(dv, img, data0, N, opt, reason)</a></li><li><a href="#_sub31" class="code">function data = map_meas_struct(data, N, out)</a></li><li><a href="#_sub32" class="code">function [dv, opt, err] = update_dv_core(img, data0, N, opt)</a></li><li><a href="#_sub33" class="code">function show_fem_iter(k, img, inv_model, stop, opt)</a></li><li><a href="#_sub34" class="code">function [ residual meas elem ] = GN_residual(dv, de, W, hps2RtR, hpt2LLt)</a></li><li><a href="#_sub35" class="code">function residual = meas_residual(dv, de, W, hps2RtR)</a></li><li><a href="#_sub36" class="code">function opt = parse_options(imdl,n_frames)</a></li><li><a href="#_sub37" class="code">function check_matrix_sizes(J, W, hps2RtR, hpt2LLt, dv, de, opt)</a></li><li><a href="#_sub38" class="code">function dx = update_dx(J, W, hps2RtR, hpt2LLt, dv, de, opt)</a></li><li><a href="#_sub39" class="code">function dx = GN_update(J, W, hps2RtR, hpt2LLt, dv, de, opt)</a></li><li><a href="#_sub40" class="code">function args = function_depends_upon(func, argn)</a></li><li><a href="#_sub41" class="code">function out = null_func(in, varargin);</a></li><li><a href="#_sub42" class="code">function [out, x, y, z] = ret1_func(varargin);</a></li><li><a href="#_sub43" class="code">function [inv_model, opt] = append_c2f_background(inv_model, opt)</a></li><li><a href="#_sub44" class="code">function [img, opt] = strip_c2f_background(img, opt, indent)</a></li><li><a href="#_sub45" class="code">function b = has_params(s)</a></li><li><a href="#_sub46" class="code">function out = map_img_base_types(img)</a></li><li><a href="#_sub47" class="code">function type = to_base_types(type)</a></li><li><a href="#_sub48" class="code">function img = map_img(img, out);</a></li><li><a href="#_sub49" class="code">function x = map_data(x, in, out)</a></li><li><a href="#_sub50" class="code">function b = map_meas(b, N, in, out)</a></li><li><a href="#_sub51" class="code">function x=range(y)</a></li><li><a href="#_sub52" class="code">function pass=do_unit_test(solver)</a></li><li><a href="#_sub53" class="code">function [imdl, vh, imgi, vi] = unit_test_imdl()</a></li><li><a href="#_sub54" class="code">function do_unit_test_diff()</a></li><li><a href="#_sub55" class="code">function do_unit_test_sub</a></li><li><a href="#_sub56" class="code">function test_map_data(data, in, out, expected)</a></li><li><a href="#_sub57" class="code">function test_map_meas(data, N, in, out, expected)</a></li><li><a href="#_sub58" class="code">function do_unit_test_rec1(solver)</a></li><li><a href="#_sub59" class="code">function do_unit_test_rec_mv(solver)</a></li><li><a href="#_sub60" class="code">function Jm = jacobian_movement_only (fwd_model, img);</a></li><li><a href="#_sub61" class="code">function RtR = prior_movement_only(imdl);</a></li><li><a href="#_sub62" class="code">function do_unit_test_rec2(solver)</a></li><li><a href="#_sub63" class="code">function do_unit_test_img0_bg()</a></li><li><a href="#_sub64" class="code">function do_unit_test_diffseq(solver)</a></li><li><a href="#_sub65" class="code">function do_unit_test_absseq(solver)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function img= inv_solve_core( inv_model, data0, data1);</a>
0002 <span class="comment">%INV_SOLVE_CORE Solver using a generic iterative algorithm</span>
0003 <span class="comment">% img        =&gt; output image (or vector of images)</span>
0004 <span class="comment">% inv_model  =&gt; inverse model struct</span>
0005 <span class="comment">% data0      =&gt; EIT data</span>
0006 <span class="comment">% data0, data1 =&gt; difference EIT data</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% This function is parametrized and uses function pointers where possible to</span>
0009 <span class="comment">% allow its use as a general iterative solver framework. There are a large</span>
0010 <span class="comment">% number of parameters and functions contained here. Sensible defaults are</span>
0011 <span class="comment">% used throughout. You do not need to set every parameter.</span>
0012 <span class="comment">%</span>
0013 <span class="comment">% The solver operates as an absolute Gauss-Newton iterative solver by default.</span>
0014 <span class="comment">% Wrapper functions are available to call this function in its various forms.</span>
0015 <span class="comment">% Look forward to the &quot;See also&quot; section at the end of this help.</span>
0016 <span class="comment">%</span>
0017 <span class="comment">% Argument matrices to the internal functions (measurement inverse covariance,</span>
0018 <span class="comment">% for example) are only calculated if required. Functions that are supplied to</span>
0019 <span class="comment">% this INV_SOLVE_CORE must be able to survive being probed: they will have</span>
0020 <span class="comment">% each parameter set to either 0 or 1 to determine if the function is sensitive</span>
0021 <span class="comment">% to that argument. This works cleanly for most matrix multiplication based</span>
0022 <span class="comment">% functions but for more abstract code, some handling of this behaviour may</span>
0023 <span class="comment">% need to be implemented.</span>
0024 <span class="comment">%</span>
0025 <span class="comment">% In the following parameters, r_k is the current residual, r_{k-1} is the</span>
0026 <span class="comment">% previous iteration's residual. k is the iteration count.</span>
0027 <span class="comment">%</span>
0028 <span class="comment">% Parameters denoted with a ** to the right of their default values are</span>
0029 <span class="comment">% deprecated legacy parameters, some of which formerly existed under</span>
0030 <span class="comment">% 'inv_model.parameters.*'.</span>
0031 <span class="comment">%</span>
0032 <span class="comment">% Parameters (inv_model.inv_solve_core.*):</span>
0033 <span class="comment">%   verbose (show progress)                (default 1)</span>
0034 <span class="comment">%      0: quiet</span>
0035 <span class="comment">%    &gt;=1: print iteration count and residual</span>
0036 <span class="comment">%    &gt;=2: print details as the algorithm progresses</span>
0037 <span class="comment">%    &gt;=3: plot residuals versus iteration count</span>
0038 <span class="comment">%    &gt;=4: plot result at each iteration, see show_fem</span>
0039 <span class="comment">%    &gt;=5: plot line search per iteration</span>
0040 <span class="comment">%   plot_residuals                         (default 0)</span>
0041 <span class="comment">%    plot residuals without verbose output</span>
0042 <span class="comment">%   fig_prefix                       (default: &lt;none&gt;)</span>
0043 <span class="comment">%    figure file prefix; figures not saved if &lt;none&gt;</span>
0044 <span class="comment">%   fwd_solutions                          (default 0)</span>
0045 <span class="comment">%    0: ignore</span>
0046 <span class="comment">%    1: count fwd_solve(), generally the most</span>
0047 <span class="comment">%       computationally expensive component of</span>
0048 <span class="comment">%       the iterations</span>
0049 <span class="comment">%   residual_func =             (default @GN_residual)</span>
0050 <span class="comment">%    NOTE: @meas_residual exists to maintain</span>
0051 <span class="comment">%    compatibility with some older code</span>
0052 <span class="comment">%   max_iterations                        (default 10)  **</span>
0053 <span class="comment">%   ntol (estimate of machine precision) (default eps)</span>
0054 <span class="comment">%   tol (stop iter if r_k &lt; tol)           (default 0)</span>
0055 <span class="comment">%   dtol                              (default -0.01%)</span>
0056 <span class="comment">%    stop iter if (r_k - r_{k-1})/r_1 &lt; dtol AND</span>
0057 <span class="comment">%                 k &gt;= dtol_iter</span>
0058 <span class="comment">%   dtol_iter                              (default 0)</span>
0059 <span class="comment">%    apply dtol stopping criteria if k &gt;= dtol_iter</span>
0060 <span class="comment">%   min_value                           (default -inf)  **</span>
0061 <span class="comment">%   max_value                           (default +inf)  **</span>
0062 <span class="comment">%   line_optimize_func                (default &lt;none&gt;)  ** TODO</span>
0063 <span class="comment">%     [next,fmin,res]=f(org,dx,data0,opt);</span>
0064 <span class="comment">%     opt=line_optimize.* + objective_func</span>
0065 <span class="comment">%     Deprecated, use line_search_func instead.</span>
0066 <span class="comment">%   line_optimize.perturb</span>
0067 <span class="comment">%                   (default line_search_args.perturb)  ** TODO</span>
0068 <span class="comment">%     Deprecated, use line_search_args.perturb instead.</span>
0069 <span class="comment">%   update_func                         (default TODO)  ** TODO</span>
0070 <span class="comment">%     [img,opt]=f(org,next,dx,fmin,res,opt)</span>
0071 <span class="comment">%     Deprecated, use &lt;TODO&gt; instead.</span>
0072 <span class="comment">%   update_method                   (default cholesky)</span>
0073 <span class="comment">%     Method to use for solving dx: 'pcg' or 'cholesky'</span>
0074 <span class="comment">%     If 'cholesky', will fall back to 'pcg' if</span>
0075 <span class="comment">%     out-of-memory. Matlab has trouble detecting the</span>
0076 <span class="comment">%     out-of-memory condition on many machines, and is</span>
0077 <span class="comment">%     likely to just grind to a halt swapping. Beware.</span>
0078 <span class="comment">%   do_starting_estimate                   (default 1)  ** TODO</span>
0079 <span class="comment">%     Deprecated, use &lt;TODO&gt; instead.</span>
0080 <span class="comment">%   line_search_func       (default @line_search_onm2)</span>
0081 <span class="comment">%   line_search_dv_func      (default @update_dv_core)</span>
0082 <span class="comment">%   line_search_de_func      (default @update_de_core)</span>
0083 <span class="comment">%   line_search_args.perturb</span>
0084 <span class="comment">%                     (default [0 1/16 1/8 1/4 1/2 1])</span>
0085 <span class="comment">%    line search for alpha by these steps along sx</span>
0086 <span class="comment">%   line_search_args.plot                  (default 0)</span>
0087 <span class="comment">%   c2f_background                         (default 0)</span>
0088 <span class="comment">%    if &gt; 0, this is additional elem_data</span>
0089 <span class="comment">%    if a c2f map exists, the default is to decide</span>
0090 <span class="comment">%    based on an estimate of c2f overlap whether a</span>
0091 <span class="comment">%    background value is required. If a background is</span>
0092 <span class="comment">%    required, it is added as the last element of that</span>
0093 <span class="comment">%    type.</span>
0094 <span class="comment">%   c2f_background_fixed                   (default 1)</span>
0095 <span class="comment">%    hold the background estimate fixed or allow it</span>
0096 <span class="comment">%    to vary as any other elem_data</span>
0097 <span class="comment">%   elem_fixed                            (default [])</span>
0098 <span class="comment">%    meas_select already handles selecting from the</span>
0099 <span class="comment">%    valid measurements. we want the same for the</span>
0100 <span class="comment">%    elem_data, so we only work on modifying the</span>
0101 <span class="comment">%    legal values.</span>
0102 <span class="comment">%    Note that c2f_background's elements are added to</span>
0103 <span class="comment">%    this list if c2f_background_fixed == 1.</span>
0104 <span class="comment">%   prior_data             (default to jacobian_bkgnd)</span>
0105 <span class="comment">%    Sets the priors of type elem_prior. May be</span>
0106 <span class="comment">%    scalar, per elem_prior, or match the working</span>
0107 <span class="comment">%    length of each elem_data type. Note that for priors</span>
0108 <span class="comment">%    using the c2f a background element may be added</span>
0109 <span class="comment">%    to the end of that range when required; see</span>
0110 <span class="comment">%    c2f_background.</span>
0111 <span class="comment">%   elem_len                (default to all elem_data)</span>
0112 <span class="comment">%    A cell array list of how many of each</span>
0113 <span class="comment">%    elem_working there are in elem_data.</span>
0114 <span class="comment">%      prior_data = { 32.1, 10*ones(10,1) };</span>
0115 <span class="comment">%      elem_prior = {'conductivity', 'movement'};</span>
0116 <span class="comment">%      elem_len = { 20001, 10 };</span>
0117 <span class="comment">%   elem_prior                (default 'conductivity')</span>
0118 <span class="comment">%    Input 'prior_data' type; immediately converted to</span>
0119 <span class="comment">%    'elem_working' type before first iteration.</span>
0120 <span class="comment">%   elem_working              (default 'conductivity')</span>
0121 <span class="comment">%   elem_output               (default 'conductivity')</span>
0122 <span class="comment">%    The working and output units for 'elem_data'.</span>
0123 <span class="comment">%    Valid types are 'conductivity' and 'resistivity'</span>
0124 <span class="comment">%    as plain units or with the prefix 'log_' or</span>
0125 <span class="comment">%    'log10_'. Conversions are handled internally.</span>
0126 <span class="comment">%    Scaling factors are applied to the Jacobian</span>
0127 <span class="comment">%    (calculated in units of 'conductivity') as</span>
0128 <span class="comment">%    appropriate.</span>
0129 <span class="comment">%    If elem_working == elem_output, then no</span>
0130 <span class="comment">%    conversions take place.</span>
0131 <span class="comment">%    For multiple types, use cell array.</span>
0132 <span class="comment">%    ex: elem_output = {'log_resistivity', 'movement'}</span>
0133 <span class="comment">%   meas_input                     (default 'voltage')</span>
0134 <span class="comment">%   meas_working                   (default 'voltage')</span>
0135 <span class="comment">%    Similarly to elem_working/output, conversion</span>
0136 <span class="comment">%    between 'voltage' and 'apparent_resistivity' and</span>
0137 <span class="comment">%    their log/log10 variants are handled internally.</span>
0138 <span class="comment">%    If meas_input == meas_working no conversions take</span>
0139 <span class="comment">%    place. The normalization factor 'N' is calculated</span>
0140 <span class="comment">%    if 'apparent_resistivity' is used.</span>
0141 <span class="comment">%   update_img_func             (default: pass-through)</span>
0142 <span class="comment">%    Called prior to calc_jacobian and update_dv.</span>
0143 <span class="comment">%    Elements are converted to their &quot;base types&quot;</span>
0144 <span class="comment">%    before this function is called. For example,</span>
0145 <span class="comment">%    'log_resistivity' becomes 'conductivity'.</span>
0146 <span class="comment">%    It is a hook to allow additional updates to the</span>
0147 <span class="comment">%    model before the Jacobian, or a new set of</span>
0148 <span class="comment">%    measurements are calculated via fwd_solve.</span>
0149 <span class="comment">%   return_working_variables               (default: 0)</span>
0150 <span class="comment">%    If 1, return the last working variables to the user</span>
0151 <span class="comment">%     img.inv_solve_{type}.J   Jacobian</span>
0152 <span class="comment">%     img.inv_solve_{type}.dx  descent direction</span>
0153 <span class="comment">%     img.inv_solve_{type}.sx  search direction</span>
0154 <span class="comment">%     img.inv_solve_{type}.alpha  line search result</span>
0155 <span class="comment">%     img.inv_solve_{type}.beta   conjugation parameter</span>
0156 <span class="comment">%     img.inv_solve_{type}.r   as:</span>
0157 <span class="comment">%       [ residual, measurement misfit, element misfit ]</span>
0158 <span class="comment">%       with one row per iteration</span>
0159 <span class="comment">%   show_fem                       (default: @show_fem)</span>
0160 <span class="comment">%    Function with which to plot each iteration's</span>
0161 <span class="comment">%    current parameters.</span>
0162 <span class="comment">%</span>
0163 <span class="comment">%   Signature for residual_func</span>
0164 <span class="comment">%    [r,m,e] = f(dv, de, W, hps2RtR, hpt2LLt)</span>
0165 <span class="comment">%   where</span>
0166 <span class="comment">%    r   - the residual = m + e</span>
0167 <span class="comment">%    m   - measurement error</span>
0168 <span class="comment">%    e   - prior misfit</span>
0169 <span class="comment">%    dv  - change in voltage</span>
0170 <span class="comment">%    de  - change in image elements</span>
0171 <span class="comment">%    W   - measurement inverse covariance matrix</span>
0172 <span class="comment">%    hps2  - spatial hyperparameter squared, see CALC_HYPERPARAMETER</span>
0173 <span class="comment">%    RtR   - regularization matrix squared --&gt; hps2RtR = hps2*RtR</span>
0174 <span class="comment">%    hpt2  - temporal hyperparameter squared</span>
0175 <span class="comment">%    LLt   - temporal regularization matrix squared --&gt; hpt2LLt = hpt2*LLt</span>
0176 <span class="comment">%</span>
0177 <span class="comment">%   Signature for line_optimize_func</span>
0178 <span class="comment">%    [alpha, img, dv, opt] = f(img, sx, data0, img0, N, W, hps2RtR, hpt2LLt, dv, opt)</span>
0179 <span class="comment">%   where:</span>
0180 <span class="comment">%    alpha - line search result</span>
0181 <span class="comment">%    img   - the current image</span>
0182 <span class="comment">%            (optional, recalculated if not available)</span>
0183 <span class="comment">%    sx    - the search direction to which alpha should be applied</span>
0184 <span class="comment">%    data0 - the true measurements     (dv = N*data - N*data0)</span>
0185 <span class="comment">%    img0  - the image background (de = img - img0)</span>
0186 <span class="comment">%    N     - a measurement normalization factor, N*dv</span>
0187 <span class="comment">%    W     - measurement inverse covariance matrix</span>
0188 <span class="comment">%    hps2  - spatial hyperparameter squared, see CALC_HYPERPARAMETER</span>
0189 <span class="comment">%    RtR   - regularization matrix squared --&gt; hps2RtR = hps2*RtR</span>
0190 <span class="comment">%    hpt2  - temporal hyperparameter squared</span>
0191 <span class="comment">%    LLt   - temporal regularization matrix squared --&gt; hpt2LLt = hpt2*LLt</span>
0192 <span class="comment">%    dv    - change in voltage</span>
0193 <span class="comment">%            (optional, recalculated if not available)</span>
0194 <span class="comment">%    opt   - additional arguments, updated at each call</span>
0195 <span class="comment">%</span>
0196 <span class="comment">%   Signature for line_search_dv_func</span>
0197 <span class="comment">%    [dv, opt] = update_dv_core(img, data0, N, opt)</span>
0198 <span class="comment">%   where:</span>
0199 <span class="comment">%    dv    - change in voltage</span>
0200 <span class="comment">%    opt   - additional arguments, updated at each call</span>
0201 <span class="comment">%    data  - the estimated measurements</span>
0202 <span class="comment">%    img   - the current image</span>
0203 <span class="comment">%    data0 - the true measurements</span>
0204 <span class="comment">%    N     - a measurement normalization factor, N*dv</span>
0205 <span class="comment">%</span>
0206 <span class="comment">%   Signature for line_search_de_func</span>
0207 <span class="comment">%    de = f(img, img0, opt)</span>
0208 <span class="comment">%   where:</span>
0209 <span class="comment">%    de    - change in image elements</span>
0210 <span class="comment">%    img   - the current image</span>
0211 <span class="comment">%    img0  - the image background (de = img - img0)</span>
0212 <span class="comment">%    opt   - additional arguments</span>
0213 <span class="comment">%</span>
0214 <span class="comment">%   Signature for calc_jacobian_scaling_func</span>
0215 <span class="comment">%    S = f(x)</span>
0216 <span class="comment">%   where:</span>
0217 <span class="comment">%    S - to be used to scale the Jacobian</span>
0218 <span class="comment">%    x - current img.elem_data in units of 'conductivity'</span>
0219 <span class="comment">%</span>
0220 <span class="comment">%   Signature for  update_img_func</span>
0221 <span class="comment">%    img2 = f(img1, opt)</span>
0222 <span class="comment">%   where</span>
0223 <span class="comment">%    img1 - an input image, the current working image</span>
0224 <span class="comment">%    img2 - a (potentially) modified version to be used</span>
0225 <span class="comment">%    for the fwd_solve/Jacobian calculations</span>
0226 <span class="comment">%</span>
0227 <span class="comment">% NOTE that the default line search is very crude. For</span>
0228 <span class="comment">% my test problems it seems to amount to an expensive grid</span>
0229 <span class="comment">% search. Much more efficient line search algorithms exist</span>
0230 <span class="comment">% and some fragments already are coded elsewhere in the</span>
0231 <span class="comment">% EIDORS code-base.</span>
0232 <span class="comment">%</span>
0233 <span class="comment">% See also: INV_SOLVE_ABS_GN, INV_SOLVE_ABS_GN_LOGC,</span>
0234 <span class="comment">%           INV_SOLVE_ABS_CG, INV_SOLVE_ABS_CG_LOGC,</span>
0235 <span class="comment">%           LINE_SEARCH_O2, LINE_SEARCH_ONM2</span>
0236 <span class="comment">%</span>
0237 <span class="comment">% (C) 2010-2016 Alistair Boyle, Nolwenn Lesparre, Andy Adler, Bartłomiej Grychtol.</span>
0238 <span class="comment">% License: GPL version 2 or version 3</span>
0239 
0240 <span class="comment">% $Id: inv_solve_core.m 6503 2022-12-30 14:33:58Z aadler $</span>
0241 
0242 <span class="comment">%--------------------------</span>
0243 <span class="comment">% UNIT_TEST?</span>
0244 <span class="keyword">if</span> ischar(inv_model) &amp;&amp; strcmp(inv_model,<span class="string">'UNIT_TEST'</span>) &amp;&amp; (nargin == 1); <a href="#_sub52" class="code" title="subfunction pass=do_unit_test(solver)">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0245 <span class="keyword">if</span> ischar(inv_model) &amp;&amp; strcmp(inv_model,<span class="string">'UNIT_TEST'</span>) &amp;&amp; (nargin == 2); <a href="#_sub52" class="code" title="subfunction pass=do_unit_test(solver)">do_unit_test</a>(data0); <span class="keyword">return</span>; <span class="keyword">end</span>
0246 
0247 <span class="comment">%--------------------------</span>
0248 <span class="keyword">if</span> nargin == 3 <span class="comment">% difference reconstruction</span>
0249    n_frames = max(<a href="#_sub2" class="code" title="subfunction n_frames = count_data_frames(data1)">count_data_frames</a>(data0),<a href="#_sub2" class="code" title="subfunction n_frames = count_data_frames(data1)">count_data_frames</a>(data1));
0250 <span class="keyword">else</span> <span class="comment">% absolute reconstruction</span>
0251    n_frames = <a href="#_sub2" class="code" title="subfunction n_frames = count_data_frames(data1)">count_data_frames</a>(data0);
0252 <span class="keyword">end</span>
0253 opt = <a href="#_sub36" class="code" title="subfunction opt = parse_options(imdl,n_frames)">parse_options</a>(inv_model, n_frames);
0254 <span class="comment">%if opt.do_starting_estimate</span>
0255 <span class="comment">%    img = initial_estimate( inv_model, data0 ); % TODO</span>
0256 <span class="comment">%%%    AB-&gt;NL this is Nolwenn's homogeneous estimate...</span>
0257 <span class="comment">%%%    calc_background_resistivity is my version of this code</span>
0258 <span class="comment">%%%    that is working for my data set</span>
0259 <span class="comment">%else</span>
0260 [inv_model, opt] = <a href="#_sub43" class="code" title="subfunction [inv_model, opt] = append_c2f_background(inv_model, opt)">append_c2f_background</a>(inv_model, opt);
0261 <span class="comment">% calc_jacobian_bkgnd, used by mk_image does not understand</span>
0262 <span class="comment">% the course-to-fine mapping and explodes when it is fed a</span>
0263 <span class="comment">% prior based on the coarse model. Here we give that</span>
0264 <span class="comment">% function something it can swallow, then create then plug</span>
0265 <span class="comment">% in the correct prior afterwards.</span>
0266 <span class="keyword">if</span> isfield(inv_model, <span class="string">'jacobian_bkgnd'</span>)
0267   inv_model = rmfield(inv_model,<span class="string">'jacobian_bkgnd'</span>);
0268 <span class="keyword">end</span>
0269 inv_model.jacobian_bkgnd.value = 1;
0270 img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>( inv_model );
0271 img.inv_model = inv_model; <span class="comment">% stash the inverse model</span>
0272 img = <a href="../../../eidors/models/data_mapper.html" class="code" title="function img = data_mapper(img, reverse)">data_mapper</a>(img); <span class="comment">% move data from whatever 'params' to img.elem_data</span>
0273 <span class="comment">% insert the prior data</span>
0274 img = <a href="#_sub3" class="code" title="subfunction img = init_elem_data(img, opt)">init_elem_data</a>(img, opt);
0275 
0276 <span class="comment">% map data and measurements to working types</span>
0277 <span class="comment">%  convert elem_data</span>
0278 img = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img, opt.elem_working);
0279 
0280 <span class="comment">% solve for difference data?</span>
0281 <span class="keyword">if</span> nargin == 3
0282    test = strcmp(opt.meas_working{1}, {<span class="string">'apparent_resistivity'</span>,<span class="string">'log_apparent_resistivity'</span>, <span class="string">'log10_apparent_resitivity'</span>});
0283    errstr= [<span class="string">'meas_working = '''</span> opt.meas_working{1} <span class="string">''' not yet supported for difference solutions'</span>];
0284    assert(all(~test), errstr);
0285    <span class="keyword">for</span> i = 1:length(opt.elem_output)
0286       assert(any(strcmp(opt.elem_output{i}, {<span class="string">'conductivity'</span>,<span class="string">'resistivity'</span>,<span class="string">'movement'</span>})), <span class="keyword">...</span>
0287              [<span class="string">'elem_output = {'</span> strjoin(opt.elem_output,<span class="string">', '</span>) <span class="string">'} but difference solver log normal outputs are not supported'</span>]);
0288    <span class="keyword">end</span>
0289    <span class="comment">% dv = (meas1 - meas0) + meas@backgnd</span>
0290    nil = struct;
0291    <span class="keyword">if</span> isstruct(data0)
0292       nil.meas = data0(1).meas(:,1)*0;
0293    <span class="keyword">else</span>
0294       nil.meas = data0(:,1)*0;
0295    <span class="keyword">end</span>
0296    nil.type = <span class="string">'data'</span>;
0297    nil.current_params = opt.meas_input;
0298    [dv, opt, err] = <a href="#_sub32" class="code" title="subfunction [dv, opt, err] = update_dv_core(img, data0, N, opt)">update_dv_core</a>(img, nil, 1, opt);
0299    <span class="comment">% This: data0 = calc_difference_data( data0, data1, inv_model.fwd_model) + dv*ones(1,n_frames);</span>
0300    <span class="comment">% but efficient and don't depend on n_frames:</span>
0301    data0 = bsxfun(@plus,<a href="../../../eidors/solvers/calc_difference_data.html" class="code" title="function dva = calc_difference_data( data1, data2, fwd_model)">calc_difference_data</a>( data0, data1, inv_model.fwd_model ), dv);
0302    <span class="comment">% back to our regularly scheduled progam</span>
0303    assert(strcmp(inv_model.reconst_type, <span class="string">'difference'</span>), <span class="keyword">...</span>
0304           [<span class="string">'expected inv_model.reconst_type = ''difference'' not '</span> inv_model.reconst_type]);
0305 <span class="keyword">else</span>
0306    assert(strcmp(inv_model.reconst_type, <span class="string">'absolute'</span>), <span class="keyword">...</span>
0307           [<span class="string">'expected inv_model.reconst_type = ''absolute'' not '</span> inv_model.reconst_type]);
0308 <span class="keyword">end</span>
0309 
0310 <span class="comment">%  convert measurement data</span>
0311 <span class="keyword">if</span> ~isstruct(data0)
0312    d = data0;
0313    data0 = struct;
0314    data0.meas = d;
0315    data0.type = <span class="string">'data'</span>;
0316 <span class="keyword">end</span>
0317 data0.current_params = opt.meas_input;
0318 
0319 <span class="comment">% precalculate some of our matrices if required</span>
0320 W  = <a href="#_sub4" class="code" title="subfunction W = init_meas_icov(inv_model, opt)">init_meas_icov</a>(inv_model, opt);
0321 [N, dN] = <a href="#_sub5" class="code" title="subfunction [N, dN] = init_normalization(fmdl, data0, opt)">init_normalization</a>(inv_model.fwd_model, data0, opt);
0322 
0323 <span class="comment">% now get on with</span>
0324 img0 = img;
0325 hps2RtR = 0; alpha = 0; k = 0; sx = 0; r = 0; stop = 0; <span class="comment">% general init</span>
0326 hpt2LLt = <a href="#_sub10" class="code" title="subfunction hpt2LLt = update_hpt2LLt(inv_model, data0, k, opt)">update_hpt2LLt</a>(inv_model, data0, k, opt);
0327 residuals = zeros(opt.max_iterations,3); <span class="comment">% for residuals plots</span>
0328 dxp = 0; <span class="comment">% previous step's slope was... nothing</span>
0329 [dv, opt] = <a href="#_sub30" class="code" title="subfunction [dv, opt] = update_dv(dv, img, data0, N, opt, reason)">update_dv</a>([], img, data0, N, opt);
0330 de = <a href="#_sub29" class="code" title="subfunction  de = update_de(de, img, img0, opt)">update_de</a>([], img, img0, opt);
0331 <span class="keyword">if</span> opt.verbose &gt;= 5 <span class="comment">% we only save the measurements at each iteration if we are being verbose</span>
0332   dvall = ones(size(data0.meas,1),opt.max_iterations+1)*NaN;
0333 <span class="keyword">end</span>
0334 <span class="keyword">while</span> 1
0335   <span class="keyword">if</span> opt.verbose &gt;= 1
0336      <span class="keyword">if</span> k == 0
0337         fprintf(<span class="string">'  inv_solve_core: start up\n'</span>);
0338      <span class="keyword">else</span>
0339         fprintf(<span class="string">'  inv_solve_core: iteration %d (residual = %g)\n'</span>, k, r(k,1));
0340      <span class="keyword">end</span>
0341   <span class="keyword">end</span>
0342 
0343   <span class="comment">% calculate the Jacobian</span>
0344   <span class="comment">%  - Jacobian before RtR because it is needed for Noser prior</span>
0345   [J, opt] = <a href="#_sub14" class="code" title="subfunction [J, opt] = update_jacobian(img, dN, k, opt)">update_jacobian</a>(img, dN, k, opt);
0346 
0347   <span class="comment">% update RtR, if required (depends on prior)</span>
0348   hps2RtR = <a href="#_sub9" class="code" title="subfunction hps2RtR = update_hps2RtR(inv_model, J, k, img, opt)">update_hps2RtR</a>(inv_model, J, k, img, opt);
0349 
0350   <span class="comment">% determine the next search direction sx</span>
0351   <span class="comment">%  dx is specific to the algorithm, generally &quot;downhill&quot;</span>
0352   dx = <a href="#_sub38" class="code" title="subfunction dx = update_dx(J, W, hps2RtR, hpt2LLt, dv, de, opt)">update_dx</a>(J, W, hps2RtR, hpt2LLt, dv, de, opt);
0353   <span class="comment">% choose beta, beta=0 unless doing Conjugate Gradient</span>
0354   beta = <a href="#_sub7" class="code" title="subfunction beta = update_beta(dx_k, dx_km1, sx_km1, opt);">update_beta</a>(dx, dxp, sx, opt);
0355   beta_all(k+1)=beta; <span class="comment">% save for debug</span>
0356   <span class="comment">% sx_k = dx_k + beta * sx_{k-1}</span>
0357   sx = <a href="#_sub8" class="code" title="subfunction sx = update_sx(dx, beta, sx_km1, opt);">update_sx</a>(dx, beta, sx, opt);
0358   <span class="keyword">if</span> k ~= 0
0359      dxp = dx; <span class="comment">% saved for next iteration if using beta</span>
0360   <span class="keyword">end</span>
0361 
0362   <span class="comment">% plot dx and SVD of Jacobian (before and after regularization)</span>
0363   <a href="#_sub11" class="code" title="subfunction plot_dx_and_svd_elem(J, W, hps2RtR, k, sx, dx, img, opt)">plot_dx_and_svd_elem</a>(J, W, hps2RtR, k, sx, dx, img, opt);
0364 
0365   <span class="comment">% line search for alpha, leaving the final selection as img</span>
0366   <span class="comment">% x_n = img.elem_data</span>
0367   <span class="comment">% x_{n+1} = x_n + \alpha sx</span>
0368   <span class="comment">% img.elem_data = x_{n+1}</span>
0369   [alpha, img, dv, opt] = <a href="#_sub26" class="code" title="subfunction [alpha, img, dv, opt] = update_alpha(img, sx, data0, img0, N, W, hps2RtR, hpt2LLt, k, dv, opt)">update_alpha</a>(img, sx, data0, img0, N, W, hps2RtR, hpt2LLt, k, dv, opt);
0370   alpha_all(k+1) = alpha;
0371   <span class="comment">% fix max/min values for x, clears dx if limits are hit, where</span>
0372   <span class="comment">% a cleared dv will trigger a recalculation of dv at the next update_dv()</span>
0373   [img, dv] = <a href="#_sub28" class="code" title="subfunction [img, dv] = update_img_using_limits(img, img0, data0, N, dv, opt)">update_img_using_limits</a>(img, img0, data0, N, dv, opt);
0374 
0375   <span class="comment">% update change in element data from the prior de and</span>
0376   <span class="comment">% the measurement error dv</span>
0377   [dv, opt] = <a href="#_sub30" class="code" title="subfunction [dv, opt] = update_dv(dv, img, data0, N, opt, reason)">update_dv</a>(dv, img, data0, N, opt);
0378   de = <a href="#_sub29" class="code" title="subfunction  de = update_de(de, img, img0, opt)">update_de</a>(de, img, img0, opt);
0379   <span class="keyword">if</span> opt.verbose &gt;= 5
0380     dvall(:,k+1) = dv;
0381     <a href="#_sub1" class="code" title="subfunction show_meas_err(dvall, data0, k, N, W, opt)">show_meas_err</a>(dvall, data0, k, N, W, opt);
0382   <span class="keyword">end</span>
0383   <a href="#_sub33" class="code" title="subfunction show_fem_iter(k, img, inv_model, stop, opt)">show_fem_iter</a>(k, img, inv_model, stop, opt);
0384 
0385   <span class="comment">% now find the residual, quit if we're done</span>
0386   [stop, k, r, img] = <a href="#_sub6" class="code" title="subfunction [stop, k, r, img] = update_residual(dv, img, de, W, hps2RtR, hpt2LLt, k, r, alpha, sx, opt)">update_residual</a>(dv, img, de, W, hps2RtR, hpt2LLt, k, r, alpha, sx, opt);
0387   <span class="keyword">if</span> stop
0388      <span class="keyword">if</span> stop == -1
0389         alpha_all(k) = 0;
0390      <span class="keyword">end</span>
0391      <span class="keyword">break</span>;
0392   <span class="keyword">end</span>
0393 <span class="keyword">end</span>
0394 img0 = <a href="#_sub44" class="code" title="subfunction [img, opt] = strip_c2f_background(img, opt, indent)">strip_c2f_background</a>(img0, opt);
0395 [img, opt] = <a href="#_sub44" class="code" title="subfunction [img, opt] = strip_c2f_background(img, opt, indent)">strip_c2f_background</a>(img, opt);
0396 <span class="comment">% check we're returning the right size of data</span>
0397 <span class="keyword">if</span> isfield(inv_model, <span class="string">'rec_model'</span>)
0398   img.fwd_model = inv_model.rec_model;
0399 <span class="keyword">end</span>
0400 <span class="keyword">if</span> opt.verbose &gt;= 1
0401    <span class="keyword">if</span> k==1; itrs=<span class="string">''</span>; <span class="keyword">else</span> itrs=<span class="string">'s'</span>; <span class="keyword">end</span>
0402    fprintf(<span class="string">'  %d fwd_solves required for this solution in %d iteration%s\n'</span>, <span class="keyword">...</span>
0403            opt.fwd_solutions, k, itrs);
0404 <span class="keyword">end</span>
0405 <span class="comment">% convert data for output</span>
0406 img = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img, opt.elem_output);
0407 <span class="keyword">if</span> strcmp(inv_model.reconst_type, <span class="string">'difference'</span>)
0408    img0 = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img0, opt.elem_output);
0409    img.elem_data = img.elem_data - img0.elem_data;
0410 <span class="keyword">end</span>
0411 img.meas_err = dv;
0412 <span class="keyword">if</span> opt.return_working_variables
0413   img.inv_solve_core.J = J;
0414   img.inv_solve_core.dx = dx;
0415   img.inv_solve_core.sx = sx;
0416   img.inv_solve_core.alpha = alpha_all;
0417   img.inv_solve_core.beta = beta_all;
0418   img.inv_solve_core.k = k;
0419   img.inv_solve_core.r = r(1:(k+1),:); <span class="comment">% trim r to n-iterations' rows</span>
0420   img.inv_solve_core.N = N;
0421   img.inv_solve_core.W = W;
0422   img.inv_solve_core.hps2RtR = hps2RtR;
0423   img.inv_solve_core.dv = dv;
0424   img.inv_solve_core.de = de;
0425   <span class="keyword">if</span> opt.verbose &gt;= 5
0426     img.inv_solve_core.dvall = dvall;
0427   <span class="keyword">end</span>
0428 <span class="keyword">end</span>
0429 <span class="comment">%img = data_mapper(img, 1); % move data from img.elem_data to whatever 'params'</span>
0430 
0431 <a name="_sub1" href="#_subfunctions" class="code">function show_meas_err(dvall, data0, k, N, W, opt)</a>
0432    clf;
0433    assert(length(opt.meas_working) == 1,<span class="string">'TODO meas_working len &gt; 1'</span>);
0434    subplot(211); bar(dvall(:,k+1)); ylabel(sprintf(<span class="string">'dv_k [%s]'</span>,opt.meas_working{1})); xlabel(<span class="string">'meas #'</span>); title(sprintf(<span class="string">'measurement error @ iter=%d'</span>,k));
0435    subplot(212); bar(<a href="#_sub50" class="code" title="subfunction b = map_meas(b, N, in, out)">map_meas</a>(dvall(:,k+1),N,opt.meas_working{1}, <span class="string">'voltage'</span>)); ylabel(<span class="string">'dv_k [V]'</span>); xlabel(<span class="string">'meas #'</span>); title(<span class="string">''</span>);
0436    drawnow;
0437    <span class="keyword">if</span> isfield(opt,<span class="string">'fig_prefix'</span>)
0438       print(<span class="string">'-dpdf'</span>,sprintf(<span class="string">'%s-meas_err%d'</span>,opt.fig_prefix,k));
0439       print(<span class="string">'-dpng'</span>,sprintf(<span class="string">'%s-meas_err%d'</span>,opt.fig_prefix,k));
0440       saveas(gcf,sprintf(<span class="string">'%s-meas_err%d.fig'</span>,opt.fig_prefix,k));
0441    <span class="keyword">end</span>
0442    drawnow;
0443 
0444 <span class="comment">% count_data_frames() needs to agree with calc_difference_data behaviour!</span>
0445 <a name="_sub2" href="#_subfunctions" class="code">function n_frames = count_data_frames(data1)</a>
0446    <span class="keyword">if</span> isnumeric(data1)
0447       n_frames = size(data1,2);
0448    <span class="keyword">else</span>
0449       n_frames = size(horzcat(data1(:).meas),2);
0450    <span class="keyword">end</span>
0451 
0452 <a name="_sub3" href="#_subfunctions" class="code">function img = init_elem_data(img, opt)</a>
0453   <span class="keyword">if</span> opt.verbose &gt; 1
0454     fprintf(<span class="string">'  setting prior elem_data\n'</span>);
0455   <span class="keyword">end</span>
0456   ne2 = 0; <span class="comment">% init</span>
0457   img.elem_data = zeros(sum([opt.elem_len{:}]),sum([opt.n_frames{:}])); <span class="comment">% preallocate</span>
0458   <span class="keyword">for</span> i=1:length(opt.elem_prior)
0459     ne1 = ne2+1; <span class="comment">% next start idx ne1</span>
0460     ne2 = ne1+opt.elem_len{i}-1; <span class="comment">% this set ends at idx ne2</span>
0461     <span class="keyword">if</span> opt.verbose &gt; 1
0462       <span class="keyword">if</span> length(opt.prior_data{i}) == 1
0463         fprintf(<span class="string">'    %d x %s: %0.1f\n'</span>,opt.elem_len{i},opt.elem_prior{i}, opt.prior_data{i});
0464       <span class="keyword">else</span>
0465         fprintf(<span class="string">'    %d x %s: ...\n'</span>,opt.elem_len{i},opt.elem_prior{i});
0466         <span class="keyword">if</span> length(opt.prior_data{i}) ~= opt.elem_len{i}
0467            error(sprintf(<span class="string">'expected %d elem, got %d elem in elem_prior'</span>, <span class="keyword">...</span>
0468                          opt.elem_len{i}, length(opt.prior_data{i})));
0469         <span class="keyword">end</span>
0470       <span class="keyword">end</span>
0471     <span class="keyword">end</span>
0472     img.params_sel(i) = {ne1:ne2};
0473     img.elem_data(img.params_sel{i},:) = opt.prior_data{i};
0474   <span class="keyword">end</span>
0475   img.current_params = opt.elem_prior;
0476 
0477 <a name="_sub4" href="#_subfunctions" class="code">function W = init_meas_icov(inv_model, opt)</a>
0478    W = 1;
0479    <span class="keyword">if</span> opt.calc_meas_icov
0480       <span class="keyword">if</span> opt.verbose &gt; 1
0481          disp(<span class="string">'  calc measurement inverse covariance W'</span>);
0482       <span class="keyword">end</span>
0483       W   = <a href="../../../eidors/solvers/calc_meas_icov.html" class="code" title="function meas_icov = calc_meas_icov( inv_model )">calc_meas_icov</a>( inv_model );
0484    <span class="keyword">end</span>
0485    <a href="#_sub27" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(W, <span class="string">'init_meas_icov'</span>);
0486 
0487 <a name="_sub5" href="#_subfunctions" class="code">function [N, dN] = init_normalization(fmdl, data0, opt)</a>
0488    <span class="comment">% precalculate the normalization of the data if required (apparent resistivity)</span>
0489    N = 1;
0490    dN = 1;
0491    vh1.meas = 1;
0492    <span class="keyword">if</span> ~iscell(opt.meas_input) || ~iscell(opt.meas_working)
0493       error(<span class="string">'expected cell array for meas_input and meas_working'</span>);
0494    <span class="keyword">end</span>
0495    <span class="comment">% TODO support for multiple measurement types</span>
0496    assert(length(opt.meas_input) == length(opt.meas_working), <span class="string">'meas_input and meas_working lengths must match'</span>);
0497    assert(length(opt.meas_working) == 1, <span class="string">'TODO only supports a single type of measurements'</span>);
0498    go =       any(strcmp({opt.meas_input{1}, opt.meas_working{1}},<span class="string">'apparent_resistivity'</span>));
0499    go = go || any(strcmp({opt.meas_input{1}, opt.meas_working{1}},<span class="string">'log_apparent_resistivity'</span>));
0500    go = go || any(strcmp({opt.meas_input{1}, opt.meas_working{1}},<span class="string">'log10_apparent_resistivity'</span>));
0501    <span class="keyword">if</span> go
0502       <span class="keyword">if</span> opt.verbose &gt; 1
0503          disp([<span class="string">'  calc measurement normalization matrix N (voltage -&gt; '</span> opt.meas_working{1} <span class="string">')'</span>]);
0504       <span class="keyword">end</span>
0505       <span class="comment">% calculate geometric factor for apparent_resitivity conversions</span>
0506       img1 = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(fmdl,1);
0507       vh1  = <a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(img1);
0508       N    = <a href="../../../eidors/models/private/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>(1./vh1.meas);
0509       <a href="#_sub27" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(N,  <span class="string">'init_normalization: N'</span>);
0510    <span class="keyword">end</span>
0511    <span class="keyword">if</span> go &amp;&amp; (opt.verbose &gt; 1)
0512       disp([<span class="string">'  calc Jacobian normalization matrix   dN (voltage -&gt; '</span> opt.meas_working{1} <span class="string">')'</span>]);
0513    <span class="keyword">end</span>
0514    <span class="comment">% calculate the normalization factor for the Jacobian</span>
0515    assert(length(opt.meas_working)==1, <span class="string">'only supports single measurement type at a time'</span>);
0516    data0 = <a href="#_sub31" class="code" title="subfunction data = map_meas_struct(data, N, out)">map_meas_struct</a>(data0, N, <span class="string">'voltage'</span>); <span class="comment">% to voltage</span>
0517    <span class="keyword">switch</span> opt.meas_working{1}
0518       <span class="keyword">case</span> <span class="string">'apparent_resistivity'</span>
0519          dN = <a href="#_sub20" class="code" title="subfunction dN = da_dv(v,vh)">da_dv</a>(data0.meas, vh1.meas);
0520       <span class="keyword">case</span> <span class="string">'log_apparent_resistivity'</span>
0521          dN = <a href="#_sub21" class="code" title="subfunction dN = dloga_dv(v,vh)">dloga_dv</a>(data0.meas, vh1.meas);
0522       <span class="keyword">case</span> <span class="string">'log10_apparent_resistivity'</span>
0523          dN = <a href="#_sub22" class="code" title="subfunction dN = dlog10a_dv(v,vh)">dlog10a_dv</a>(data0.meas, vh1.meas);
0524       <span class="keyword">case</span> <span class="string">'voltage'</span>
0525          dN = <a href="#_sub23" class="code" title="subfunction dN = dv_dv(v,vh)">dv_dv</a>(data0.meas, vh1.meas);
0526       <span class="keyword">case</span> <span class="string">'log_voltage'</span>
0527          dN = <a href="#_sub24" class="code" title="subfunction dN = dlogv_dv(v,vh) ">dlogv_dv</a>(data0.meas, vh1.meas);
0528       <span class="keyword">case</span> <span class="string">'log10_voltage'</span>
0529          dN = <a href="#_sub25" class="code" title="subfunction dN = dlog10v_dv(v,vh) ">dlog10v_dv</a>(data0.meas, vh1.meas);
0530       <span class="keyword">otherwise</span>
0531          error(<span class="string">'hmm'</span>);
0532    <span class="keyword">end</span>
0533    <a href="#_sub27" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(dN, <span class="string">'init_normalization: dN'</span>);
0534 
0535 <span class="comment">% r_km1: previous residual, if its the first iteration r_km1 = inf</span>
0536 <span class="comment">% r_k: new residual</span>
0537 <a name="_sub6" href="#_subfunctions" class="code">function [stop, k, r, img] = update_residual(dv, img, de, W, hps2RtR, hpt2LLt, k, r, alpha, sx, opt)</a>
0538   stop = 0;
0539 
0540   <span class="comment">% update residual estimate</span>
0541   <span class="keyword">if</span> k == 0
0542      r = ones(opt.max_iterations, 3)*NaN;
0543      r_km1 = inf;
0544      r_1   = inf;
0545   <span class="keyword">else</span>
0546      r_km1 = r(k, 1);
0547      r_1   = r(1, 1);
0548   <span class="keyword">end</span>
0549   [r_k m_k e_k] = feval(opt.residual_func, dv, de, W, hps2RtR, hpt2LLt);
0550   <span class="comment">% save residual for next iteration</span>
0551   r(k+1,1:3) = [r_k m_k e_k];
0552 
0553   <span class="comment">% now do something with that information</span>
0554   <span class="keyword">if</span> opt.verbose &gt; 1
0555      fprintf(<span class="string">'    calc residual\n'</span>);
0556      <span class="keyword">if</span> k == 0
0557         fprintf(<span class="string">'    stop @ max iter = %d, tol = %0.3g (%0.3g%%), dtol = %0.3g%% (after %d iter)\n'</span>, <span class="keyword">...</span>
0558                 opt.max_iterations, opt.tol, opt.tol/r_k*100, opt.dtol*100, opt.dtol_iter);
0559         fprintf(<span class="string">'      r =%0.3g = %0.3g meas + %0.3g elem\n'</span>, r_k, m_k, e_k);
0560      <span class="keyword">else</span>
0561         fprintf(<span class="string">'      r =%0.3g (%0.03g%%) = %0.3g meas (%0.03g%%) + %0.3g elem (%0.3g%%)\n'</span>, <span class="keyword">...</span>
0562                 r_k, r_k/r(1,1)*100, m_k, m_k/r(1,2)*100, e_k, e_k/r(1,3)*100);
0563         dr = (r_k - r_km1);
0564         fprintf(<span class="string">'      dr=%0.3g (%0.3g%%)\n'</span>, dr, dr/r_1*100);
0565      <span class="keyword">end</span>
0566   <span class="keyword">end</span>
0567   <span class="keyword">if</span> opt.plot_residuals
0568      <span class="comment">%         optimization_criteria, data misfit, roughness</span>
0569      r(k+1,2:3) = [sum(sum(dv.^2,1))/2 sum(sum(de.^2,1))/2];
0570      <span class="keyword">if</span> k &gt; 0
0571         clf;
0572         x = 1:(k+1);
0573         y = r(x, :);
0574         y = y ./ repmat(max(y,[],1),size(y,1),1) * 100;
0575         plot(x-1, y, <span class="string">'o-'</span>, <span class="string">'linewidth'</span>, 2, <span class="string">'MarkerSize'</span>, 10);
0576         title(<span class="string">'residuals'</span>);
0577         axis tight;
0578         ylabel(<span class="string">'residual (% of max)'</span>);
0579         xlabel(<span class="string">'iteration'</span>);
0580         set(gca, <span class="string">'xtick'</span>, x);
0581         set(gca, <span class="string">'xlim'</span>, [0 max(x)-1]);
0582         legend(<span class="string">'residual'</span>,<span class="string">'meas. misfit'</span>,<span class="string">'prior misfit'</span>);
0583         legend(<span class="string">'Location'</span>, <span class="string">'EastOutside'</span>);
0584         drawnow;
0585         <span class="keyword">if</span> isfield(opt,<span class="string">'fig_prefix'</span>)
0586            print(<span class="string">'-dpdf'</span>,sprintf(<span class="string">'%s-r'</span>,opt.fig_prefix));
0587            print(<span class="string">'-dpng'</span>,sprintf(<span class="string">'%s-r'</span>,opt.fig_prefix));
0588            saveas(gcf,sprintf(<span class="string">'%s-r.fig'</span>,opt.fig_prefix));
0589         <span class="keyword">end</span>
0590      <span class="keyword">end</span>
0591   <span class="keyword">end</span>
0592 
0593   <span class="comment">% evaluate stopping criteria</span>
0594   <span class="keyword">if</span> r_k &gt; r_km1 <span class="comment">% bad step</span>
0595      <span class="keyword">if</span> opt.verbose &gt; 1
0596         fprintf(<span class="string">'  terminated at iteration %d (bad step, returning previous iteration''s result)\n'</span>,k);
0597      <span class="keyword">end</span>
0598      img.elem_data = img.elem_data - alpha * sx; <span class="comment">% undo the last step</span>
0599      stop = -1;
0600   <span class="keyword">elseif</span> k &gt;= opt.max_iterations
0601      <span class="keyword">if</span> opt.verbose &gt; 1
0602         fprintf(<span class="string">'  terminated at iteration %d (max iterations)\n'</span>,k);
0603      <span class="keyword">end</span>
0604      stop = 1;
0605   <span class="keyword">elseif</span> r_k &lt; opt.tol + opt.ntol
0606      <span class="keyword">if</span> opt.verbose &gt; 1
0607         fprintf(<span class="string">'  terminated at iteration %d\n'</span>,k);
0608         fprintf(<span class="string">'    residual tolerance (%0.3g) achieved\n'</span>, opt.tol + opt.ntol);
0609      <span class="keyword">end</span>
0610      stop = 1;
0611   <span class="keyword">elseif</span> (k &gt;= opt.dtol_iter) &amp;&amp; ((r_k - r_km1)/r_1 &gt; opt.dtol - 2*opt.ntol)
0612      <span class="keyword">if</span> opt.verbose &gt; 1
0613         fprintf(<span class="string">'  terminated at iteration %d (iterations not improving)\n'</span>, k);
0614         fprintf(<span class="string">'    residual slope tolerance (%0.3g%%) exceeded\n'</span>, (opt.dtol - 2*opt.ntol)*100);
0615      <span class="keyword">end</span>
0616      stop = 1;
0617   <span class="keyword">end</span>
0618   <span class="keyword">if</span> ~stop
0619      <span class="comment">% update iteration count</span>
0620      k = k+1;
0621   <span class="keyword">end</span>
0622 
0623 <span class="comment">% for Conjugate Gradient, else beta = 0</span>
0624 <span class="comment">%  dx_k, dx_{k-1}, sx_{k-1}</span>
0625 <a name="_sub7" href="#_subfunctions" class="code">function beta = update_beta(dx_k, dx_km1, sx_km1, opt);</a>
0626    <span class="keyword">if</span> isfield(opt, <span class="string">'beta_func'</span>)
0627       <span class="keyword">if</span> opt.verbose &gt; 1
0628          <span class="keyword">try</span> beta_str = func2str(opt.beta_func);
0629          <span class="keyword">catch</span>
0630             <span class="keyword">try</span>
0631                 beta_str = opt.beta_func;
0632             <span class="keyword">catch</span>
0633                 beta_str = <span class="string">'unknown'</span>;
0634             <span class="keyword">end</span>
0635          <span class="keyword">end</span>
0636       <span class="keyword">end</span>
0637       beta= feval(opt.beta_func, dx_k, dx_km1, sx_km1);
0638    <span class="keyword">else</span>
0639      beta_str = <span class="string">'&lt;none&gt;'</span>;
0640      beta = 0;
0641    <span class="keyword">end</span>
0642    <span class="keyword">if</span> opt.verbose &gt; 1
0643       str = sprintf(<span class="string">'    calc beta (%s)=%0.3f\n'</span>, beta_str, beta);
0644    <span class="keyword">end</span>
0645 
0646 <span class="comment">% update the search direction</span>
0647 <span class="comment">% for Gauss-Newton</span>
0648 <span class="comment">%   sx_k = dx_k</span>
0649 <span class="comment">% for Conjugate-Gradient</span>
0650 <span class="comment">%   sx_k = dx_k + beta * sx_{k-1}</span>
0651 <a name="_sub8" href="#_subfunctions" class="code">function sx = update_sx(dx, beta, sx_km1, opt);</a>
0652    sx = dx + beta * sx_km1;
0653    <span class="keyword">if</span>(opt.verbose &gt; 1)
0654       nsx = norm(sx);
0655       nsxk = norm(sx_km1);
0656       fprintf( <span class="string">'    update step dx, beta=%0.3g, ||dx||=%0.3g\n'</span>, beta, nsx);
0657       <span class="keyword">if</span> nsxk ~= 0
0658          fprintf( <span class="string">'      acceleration     d||dx||=%0.3g\n'</span>, nsx-nsxk);
0659          <span class="comment">% ||ddx|| = chord_len = 2 sin(theta/2)</span>
0660          ddx = norm(sx/nsx-sx_km1/nsxk);
0661          fprintf( <span class="string">'      direction change ||ddx||=%0.3g (%0.3g°)\n'</span>, ddx, 2*asind(ddx/2));
0662       <span class="keyword">end</span>
0663    <span class="keyword">end</span>
0664 
0665 <span class="comment">% this function constructs the blockwise RtR spatial regularization matrix</span>
0666 <a name="_sub9" href="#_subfunctions" class="code">function hps2RtR = update_hps2RtR(inv_model, J, k, img, opt)</a>
0667    <span class="keyword">if</span> k==0 <span class="comment">% first the start up iteration use the initial hyperparameter</span>
0668       k=1;
0669    <span class="keyword">end</span>
0670    <span class="comment">% TODO sometimes (with Noser?) this requires the Jacobian, could this be done more efficiently?</span>
0671    <span class="comment">% add a test function to determine if img.elem_data affects RtR, skip this if independant</span>
0672    <span class="comment">% TODO we could detect in the opt_parsing whether the calc_RtR_prior depends on 'x' and skip this if no</span>
0673    <span class="keyword">if</span> ~opt.calc_RtR_prior
0674       error(<span class="string">'no RtR calculation mechanism, set imdl.inv_solve_core.RtR_prior or imdl.RtR_prior'</span>);
0675    <span class="keyword">end</span>
0676    <span class="keyword">if</span> opt.verbose &gt; 1
0677       disp(<span class="string">'    calc hp^2 R^t R'</span>);
0678    <span class="keyword">end</span>
0679    hp2 = <a href="../../../eidors/solvers/calc_hyperparameter.html" class="code" title="function hyperparameter = calc_hyperparameter( inv_model )">calc_hyperparameter</a>( inv_model )^2; <span class="comment">% = \lambda^2</span>
0680    net = sum([opt.elem_len{:}]); <span class="comment">% Number of Elements, Total</span>
0681    RtR = <a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(net,net); <span class="comment">% init RtR = sparse(zeros(net,net));</span>
0682    esi = 0; eei = 0; <span class="comment">% element start, element end</span>
0683    <span class="keyword">for</span> i = 1:size(opt.RtR_prior,1) <span class="comment">% row i</span>
0684       esi = eei + 1;
0685       eei = eei + opt.elem_len{i};
0686       esj = 0; eej = 0; <span class="comment">% element start, element end</span>
0687       <span class="keyword">for</span> j = 1:size(opt.RtR_prior,2) <span class="comment">% column j</span>
0688          esj = eej + 1;
0689          eej = eej + opt.elem_len{j};
0690          <span class="keyword">if</span> isempty(opt.RtR_prior{i,j}) <span class="comment">% null entries</span>
0691             <span class="keyword">continue</span>; <span class="comment">% no need to explicitly create zero block matrices</span>
0692          <span class="keyword">end</span>
0693 
0694          <span class="comment">% select a hyperparameter, potentially, per iteration</span>
0695          <span class="comment">% if we're at the end of the list, select the last entry</span>
0696          hp=opt.hyperparameter_spatial{i,j};
0697          <span class="keyword">if</span> length(hp) &gt; k
0698             hp=hp(k);
0699          <span class="keyword">else</span>
0700             hp=hp(end);
0701          <span class="keyword">end</span>
0702 
0703          <span class="keyword">try</span> RtR_str = func2str(opt.RtR_prior{i,j});
0704          <span class="keyword">catch</span>
0705             <span class="keyword">try</span>
0706                 RtR_str = opt.RtR_prior{i,j};
0707             <span class="keyword">catch</span>
0708                 RtR_str = <span class="string">'unknown'</span>;
0709             <span class="keyword">end</span>
0710          <span class="keyword">end</span>
0711          <span class="keyword">if</span> opt.verbose &gt; 1
0712             fprintf(<span class="string">'      {%d,%d} regularization RtR (%s), ne=%dx%d, hp=%0.4g\n'</span>, i,j,RtR_str,eei-esi+1,eej-esj+1,hp*sqrt(hp2));
0713          <span class="keyword">end</span>
0714          imgt = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img, opt.elem_working{i});
0715          inv_modelt = inv_model;
0716          inv_modelt.RtR_prior = opt.RtR_prior{i,j};
0717          <span class="keyword">if</span> strcmp(RtR_str, <span class="string">'prior_noser'</span>) <span class="comment">% intercept prior_noser: we already have the Jacobian calculated</span>
0718             <span class="keyword">if</span> i ~= j
0719                error(<span class="string">'noser for off diagonal prior (RtR) is undefined'</span>)
0720             <span class="keyword">end</span>
0721             exponent= 0.5; <span class="keyword">try</span> exponent = inv_model.prior_noser.exponent; <span class="keyword">end</span>; <span class="keyword">try</span> exponent = inv_model.prior_noser.exponent{j}; <span class="keyword">end</span>
0722             ss = sum(J(:,esj:eej).^2,1)';
0723             Reg = spdiags( ss.^exponent, 0, opt.elem_len{j}, opt.elem_len{j}); <span class="comment">% = diag(J'*J)^0.5</span>
0724             RtR(esi:eei, esj:eej) = hp.^2 * Reg;
0725          <span class="keyword">else</span>
0726             RtR(esi:eei, esj:eej) = hp.^2 * <a href="#_sub13" class="code" title="subfunction RtR = calc_RtR_prior_wrapper(inv_model, img, opt)">calc_RtR_prior_wrapper</a>(inv_modelt, imgt, opt);
0727          <span class="keyword">end</span>
0728       <span class="keyword">end</span>
0729    <span class="keyword">end</span>
0730    hps2RtR = hp2*RtR;
0731 
0732 <span class="comment">% this function constructs the LLt temporal regularization matrix</span>
0733 <a name="_sub10" href="#_subfunctions" class="code">function hpt2LLt = update_hpt2LLt(inv_model, data0, k, opt)</a>
0734    <span class="keyword">if</span> k==0 <span class="comment">% first the start up iteration use the initial hyperparameter</span>
0735       k=1;
0736    <span class="keyword">end</span>
0737    <span class="keyword">if</span> ~opt.calc_LLt_prior
0738       error(<span class="string">'no LLt calculation mechanism, set imdl.inv_solve_core.LLt_prior or imdl.LLt_prior'</span>);
0739    <span class="keyword">end</span>
0740    <span class="keyword">if</span> opt.verbose &gt; 1
0741       disp(<span class="string">'    calc hp^2 L L^t'</span>);
0742    <span class="keyword">end</span>
0743    hp2 = 1;
0744    nmt = sum([opt.n_frames{:}]); <span class="comment">% Number of Measurements, Total</span>
0745    LLt = <a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(nmt,nmt); <span class="comment">% init = 0</span>
0746    msi = 0; mei = 0; <span class="comment">% measurement start, measurement end</span>
0747    <span class="keyword">for</span> i = 1:size(opt.LLt_prior,1) <span class="comment">% row i</span>
0748       msi = mei + 1;
0749       mei = mei + opt.n_frames{i};
0750       msj = 0; mej = 0; <span class="comment">% element start, element end</span>
0751       <span class="keyword">for</span> j = 1:size(opt.LLt_prior,2) <span class="comment">% column j</span>
0752          msj = mej + 1;
0753          mej = mej + opt.n_frames{j};
0754          <span class="keyword">if</span> isempty(opt.LLt_prior{i,j}) <span class="comment">% null entries</span>
0755             <span class="keyword">continue</span>; <span class="comment">% no need to explicitly create zero block matrices</span>
0756          <span class="keyword">end</span>
0757 
0758          <span class="comment">% select a hyperparameter, potentially, per iteration</span>
0759          <span class="comment">% if we're at the end of the list, select the last entry</span>
0760          hp=opt.hyperparameter_temporal{i,j};
0761          <span class="keyword">if</span> length(hp) &gt; k
0762             hp=hp(k);
0763          <span class="keyword">else</span>
0764             hp=hp(end);
0765          <span class="keyword">end</span>
0766 
0767          <span class="keyword">try</span> LLt_str = func2str(opt.LLt_prior{i,j});
0768          <span class="keyword">catch</span>
0769             <span class="keyword">try</span>
0770                 LLt_str = opt.LLt_prior{i,j};
0771                 <span class="keyword">if</span> isnumeric(LLt_str)
0772                    <span class="keyword">if</span> LLt_str == eye(size(LLt_str))
0773                       LLt_str = <span class="string">'eye'</span>;
0774                    <span class="keyword">else</span>
0775                       LLt_str = sprintf(<span class="string">'array, norm=%0.1g'</span>,norm(LLt_str));
0776                    <span class="keyword">end</span>
0777                 <span class="keyword">end</span>
0778             <span class="keyword">catch</span>
0779                 LLt_str = <span class="string">'unknown'</span>;
0780             <span class="keyword">end</span>
0781          <span class="keyword">end</span>
0782          <span class="keyword">if</span> opt.verbose &gt; 1
0783             fprintf(<span class="string">'      {%d,%d} regularization LLt (%s), frames=%dx%d, hp=%0.4g\n'</span>, i,j,LLt_str,mei-msi+1,mej-msj+1,hp*sqrt(hp2));
0784          <span class="keyword">end</span>
0785          inv_modelt = inv_model;
0786          inv_modelt.LLt_prior = opt.LLt_prior{i,j};
0787          LLt(msi:mei, msj:mej) = hp.^2 * <a href="../../../eidors/solvers/calc_LLt_prior.html" class="code" title="function LLt_prior = calc_LLt_prior( data0, inv_model )">calc_LLt_prior</a>( data0, inv_modelt );
0788       <span class="keyword">end</span>
0789    <span class="keyword">end</span>
0790    hpt2LLt = hp2*LLt;
0791 
0792 <a name="_sub11" href="#_subfunctions" class="code">function plot_dx_and_svd_elem(J, W, hps2RtR, k, sx, dx, img, opt)</a>
0793    <span class="keyword">if</span>(opt.verbose &gt;= 5)
0794       <span class="comment">% and try a show_fem with the pixel search direction</span>
0795       clf;
0796       imgb=img;
0797       imgb.elem_data = dx;
0798       imgb.current_params = opt.elem_working;
0799       imgb.is_dx_plot = 1; <span class="comment">% hint to show_fem that this is a dx plot (for handling log scale if anything clever is going on)</span>
0800       <span class="keyword">if</span> isfield(imgb.inv_model,<span class="string">'rec_model'</span>)
0801          imgb.fwd_model = imgb.inv_model.rec_model;
0802       <span class="keyword">end</span>
0803       feval(opt.show_fem,imgb,1);
0804       title(sprintf(<span class="string">'dx @ iter=%d'</span>,k));
0805       drawnow;
0806       <span class="keyword">if</span> isfield(opt,<span class="string">'fig_prefix'</span>)
0807          print(<span class="string">'-dpng'</span>,sprintf(<span class="string">'%s-dx%d'</span>,opt.fig_prefix,k));
0808          print(<span class="string">'-dpdf'</span>,sprintf(<span class="string">'%s-dx%d'</span>,opt.fig_prefix,k));
0809          saveas(gcf,sprintf(<span class="string">'%s-dx%d.fig'</span>,opt.fig_prefix,k));
0810       <span class="keyword">end</span>
0811    <span class="keyword">end</span>
0812    <span class="keyword">if</span> opt.verbose &lt; 8
0813       <span class="keyword">return</span>; <span class="comment">% do nothing if not verbose</span>
0814    <span class="keyword">end</span>
0815    <span class="comment">% canonicalize the structures so we don't have to deal with a bunch of scenarios below</span>
0816    <span class="keyword">if</span> ~isfield(img, <span class="string">'params_sel'</span>)
0817       img.params_sel = {1:length(img.elem_data)};
0818    <span class="keyword">end</span>
0819    <span class="keyword">if</span> ~isfield(img, <span class="string">'current_params'</span>)
0820       img.current_params = <span class="string">'conductivity'</span>;
0821    <span class="keyword">end</span>
0822    <span class="keyword">if</span> ~iscell(img.current_params)
0823       img.current_params = {img.current_params};
0824    <span class="keyword">end</span>
0825    <span class="comment">% go</span>
0826    cols=length(opt.elem_working);
0827    <span class="keyword">if</span> norm(sx - dx) &lt; <a href="#_sub51" class="code" title="subfunction x=range(y)">range</a>(dx)/max(dx)*0.01 <span class="comment">% sx and dx are within 1%</span>
0828       rows=2;
0829    <span class="keyword">else</span>
0830       rows=3;
0831    <span class="keyword">end</span>
0832    clf; <span class="comment">% individual SVD plots</span>
0833    <span class="keyword">for</span> i=1:cols
0834       <span class="keyword">if</span> 1 <span class="comment">% if Tikhonov</span>
0835          hp=opt.hyperparameter_spatial{i};
0836          <span class="keyword">if</span> k ~= 0 &amp;&amp; k &lt; length(hp)
0837             hp = hp(k);
0838          <span class="keyword">else</span>
0839             hp = hp(end);
0840          <span class="keyword">end</span>
0841       <span class="keyword">else</span>
0842          hp = [];
0843       <span class="keyword">end</span>
0844       sel=img.params_sel{i};
0845       str=strrep(img.current_params{i},<span class="string">'_'</span>,<span class="string">' '</span>);
0846       <a href="#_sub12" class="code" title="subfunction plot_svd(J, W, hps2RtR, k, hp)">plot_svd</a>(J(:,sel), W, hps2RtR(sel,sel), k, hp); xlabel(str);
0847       drawnow;
0848       <span class="keyword">if</span> isfield(opt,<span class="string">'fig_prefix'</span>)
0849          print(<span class="string">'-dpdf'</span>,sprintf(<span class="string">'%s-svd%d-%s'</span>,opt.fig_prefix,k,img.current_params{i}));
0850          print(<span class="string">'-dpng'</span>,sprintf(<span class="string">'%s-svd%d-%s'</span>,opt.fig_prefix,k,img.current_params{i}));
0851          saveas(gcf,sprintf(<span class="string">'%s-svd%d-%s.fig'</span>,opt.fig_prefix,k,img.current_params{i}));
0852       <span class="keyword">end</span>
0853    <span class="keyword">end</span>
0854    clf; <span class="comment">% combo plot</span>
0855    <span class="keyword">for</span> i=1:cols
0856       <span class="keyword">if</span> 1 <span class="comment">% if Tikhonov</span>
0857          hp=opt.hyperparameter_spatial{i};
0858          <span class="keyword">if</span> k ~= 0 &amp;&amp; k &lt; length(hp)
0859             hp = hp(k);
0860          <span class="keyword">else</span>
0861             hp = hp(end);
0862          <span class="keyword">end</span>
0863       <span class="keyword">else</span>
0864          hp = [];
0865       <span class="keyword">end</span>
0866       subplot(rows,cols,i);
0867       sel=img.params_sel{i};
0868       str=strrep(img.current_params{i},<span class="string">'_'</span>,<span class="string">' '</span>);
0869       <a href="#_sub12" class="code" title="subfunction plot_svd(J, W, hps2RtR, k, hp)">plot_svd</a>(J(:,sel), W, hps2RtR(sel,sel), k, hp); xlabel(str);
0870       subplot(rows,cols,cols+i);
0871       bar(dx(sel)); ylabel([<span class="string">'dx: '</span> str]);
0872       <span class="keyword">if</span> rows &gt; 2
0873          subplot(rows,cols,2*cols+i);
0874          bar(sx(sel)); ylabel([<span class="string">'sx: '</span> str]);
0875       <span class="keyword">end</span>
0876    <span class="keyword">end</span>
0877    drawnow;
0878    <span class="keyword">if</span> isfield(opt,<span class="string">'fig_prefix'</span>)
0879       print(<span class="string">'-dpdf'</span>,sprintf(<span class="string">'%s-svd%d'</span>,opt.fig_prefix,k));
0880       print(<span class="string">'-dpng'</span>,sprintf(<span class="string">'%s-svd%d'</span>,opt.fig_prefix,k));
0881       saveas(gcf,sprintf(<span class="string">'%s-svd%d.fig'</span>,opt.fig_prefix,k));
0882    <span class="keyword">end</span>
0883 
0884 <a name="_sub12" href="#_subfunctions" class="code">function plot_svd(J, W, hps2RtR, k, hp)</a>
0885    <span class="keyword">if</span> nargin &lt; 5
0886       hp = [];
0887    <span class="keyword">end</span>
0888    <span class="comment">% calculate the singular values before and after regularization</span>
0889    [~,s1,~]=svd(J'*W*J); s1=sqrt(diag(s1));
0890    [~,s2,~]=svd(J'*W*J + hps2RtR); s2=sqrt(diag(s2));
0891    h=semilogy(s1,<span class="string">'bx'</span>); axis tight; set(h,<span class="string">'LineWidth'</span>,2);
0892    hold on; h=semilogy(s2,<span class="string">'go'</span>); axis tight; set(h,<span class="string">'LineWidth'</span>,2); hold off;
0893    xlabel(<span class="string">'k'</span>); ylabel(<span class="string">'value \sigma'</span>);
0894    title(sprintf(<span class="string">'singular values of J at iteration %d'</span>,k));
0895    legend(<span class="string">'J^T J'</span>, <span class="string">'J^T J + \lambda^2 R^T R'</span>); legend location best;
0896    <span class="comment">% line for \lambda</span>
0897 <span class="comment">%     if regularization == 2 % Noser</span>
0898 <span class="comment">%        hp_scaled = hp*sqrt(norm(full(RtR)));</span>
0899 <span class="comment">%        h=line([1 length(s1)],[hp_scaled hp_scaled]);</span>
0900 <span class="comment">%        text(length(s1)/2,hp_scaled*0.9,sprintf('\\lambda ||R^T R||^{%0.1f}= %0.4g; \\lambda = %0.4g', noser_p, hp_scaled, hp));</span>
0901 <span class="comment">%        fprintf('  affecting %d of %d singular values\k', length(find(s1&lt;hp_scaled)), length(s1));</span>
0902 <span class="comment">%     else % Tikhonov</span>
0903    <span class="keyword">if</span> length(hp)==1
0904         h=line([1 length(s1)],[hp hp]);
0905         ly=10^(log10(hp)-0.05*<a href="#_sub51" class="code" title="subfunction x=range(y)">range</a>(log10([s1;s2])));
0906         text(length(s1)/2,ly,sprintf(<span class="string">'\\lambda = %0.4g'</span>, hp));
0907 <span class="comment">%       fprintf('  affecting %d of %d singular values\k', length(find(s1&lt;hp)), length(s1));</span>
0908      <span class="keyword">end</span>
0909      set(h,<span class="string">'LineStyle'</span>,<span class="string">'-.'</span>); set(h,<span class="string">'LineWidth'</span>,2);
0910    set(gca,<span class="string">'YMinorTick'</span>,<span class="string">'on'</span>, <span class="string">'YMinorGrid'</span>, <span class="string">'on'</span>, <span class="string">'YGrid'</span>, <span class="string">'on'</span>);
0911 
0912 
0913 <span class="comment">% TODO this function is one giant HACK around broken RtR generation with c2f matrices</span>
0914 <a name="_sub13" href="#_subfunctions" class="code">function RtR = calc_RtR_prior_wrapper(inv_model, img, opt)</a>
0915    RtR = <a href="../../../eidors/solvers/calc_RtR_prior.html" class="code" title="function RtR_prior = calc_RtR_prior( inv_model )">calc_RtR_prior</a>( inv_model );
0916    <span class="keyword">if</span> size(RtR,1) &lt; length(img.elem_data)
0917      ne = length(img.elem_data) - size(RtR,1);
0918      <span class="comment">% we are correcting for the added background element</span>
0919      <span class="keyword">for</span> i=1:ne
0920        RtR(end+1:end+1, end+1:end+1) = RtR(1,1);
0921      <span class="keyword">end</span>
0922      <span class="keyword">if</span> opt.verbose &gt; 1
0923         fprintf(<span class="string">'      c2f: adjusting RtR by appending %d rows/cols\n'</span>, ne);
0924         disp(   <span class="string">'      TODO move this fix, or something like it to calc_RtR_prior -- this fix is a quick HACK to get things to run...'</span>);
0925      <span class="keyword">end</span>
0926    <span class="keyword">end</span>
0927 
0928 <span class="comment">% opt is only updated for the fwd_solve count</span>
0929 <a name="_sub14" href="#_subfunctions" class="code">function [J, opt] = update_jacobian(img, dN, k, opt)</a>
0930    img.elem_data = img.elem_data(:,1);
0931    base_types = <a href="#_sub46" class="code" title="subfunction out = map_img_base_types(img)">map_img_base_types</a>(img);
0932    imgb = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img, base_types);
0933    imgb = feval(opt.update_img_func, imgb, opt);
0934    <span class="comment">% if the electrodes/geometry moved, we need to recalculate dN if it depends on vh</span>
0935    <span class="comment">% note that only apparent_resisitivity needs vh; all others depend on data0 measurements</span>
0936    <span class="keyword">if</span> any(strcmp(<a href="#_sub46" class="code" title="subfunction out = map_img_base_types(img)">map_img_base_types</a>(img), <span class="string">'movement'</span>)) &amp;&amp; any(strcmp(opt.meas_working, <span class="string">'apparent_resistivity'</span>))
0937       imgh = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(imgb, <span class="string">'conductivity'</span>); <span class="comment">% drop everything but conductivity</span>
0938       imgh.elem_data = imgh.elem_data*0 +1; <span class="comment">% conductivity = 1</span>
0939       vh = <a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(imgh); vh = vh.meas;
0940       dN = <a href="#_sub20" class="code" title="subfunction dN = da_dv(v,vh)">da_dv</a>(1,vh); <span class="comment">% = diag(1/vh)</span>
0941       opt.fwd_solutions = opt.fwd_solutions +1;
0942    <span class="keyword">end</span>
0943    ee = 0; <span class="comment">% element select, init</span>
0944    pp = <a href="../../../eidors/solvers/forward/fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>(imgb.fwd_model);
0945    J = zeros(pp.n_meas,sum([opt.elem_len{:}]));
0946    <span class="keyword">for</span> i=1:length(opt.jacobian)
0947       <span class="keyword">if</span>(opt.verbose &gt; 1)
0948          <span class="keyword">if</span> isnumeric(opt.jacobian{i})
0949             J_str = <span class="string">'[fixed]'</span>;
0950          <span class="keyword">elseif</span> isa(opt.jacobian{i}, <span class="string">'function_handle'</span>)
0951             J_str = func2str(opt.jacobian{i});
0952          <span class="keyword">else</span>
0953             J_str = opt.jacobian{i};
0954          <span class="keyword">end</span>
0955          <span class="keyword">if</span> i == 1 fprintf(<span class="string">'    calc Jacobian J(x) = '</span>);
0956          <span class="keyword">else</span>      fprintf(<span class="string">'                       + '</span>); <span class="keyword">end</span>
0957          fprintf(<span class="string">'(%s,'</span>, J_str);
0958       <span class="keyword">end</span>
0959       <span class="comment">% start and end of these Jacobian columns</span>
0960       es = ee+1;
0961       ee = es+opt.elem_len{i}-1;
0962       <span class="comment">% scaling if we are working in something other than direct conductivity</span>
0963       S = feval(opt.calc_jacobian_scaling_func{i}, imgb.elem_data(es:ee)); <span class="comment">% chain rule</span>
0964       <span class="comment">% finalize the jacobian</span>
0965       <span class="comment">% Note that if a normalization (i.e. apparent_resistivity) has been applied</span>
0966       <span class="comment">% to the measurements, it needs to be applied to the Jacobian as well!</span>
0967       imgt = imgb;
0968       <span class="keyword">if</span>  strcmp(base_types{i}, <span class="string">'conductivity'</span>) <span class="comment">% make legacy jacobian calculators happy... only conductivity on imgt.elem_data</span>
0969          imgt = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img, <span class="string">'conductivity'</span>);
0970       <span class="keyword">end</span>
0971       imgt.fwd_model.jacobian = opt.jacobian{i};
0972       Jn = <a href="../../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>( imgt ); <span class="comment">% unscaled natural units (i.e. conductivity)</span>
0973       J(:,es:ee) = dN * Jn * S; <span class="comment">% scaled and normalized</span>
0974       <span class="keyword">if</span> opt.verbose &gt; 1
0975          tmp = zeros(1,size(J,2));
0976          tmp(es:ee) = 1;
0977          tmp(opt.elem_fixed) = 0;
0978          fprintf(<span class="string">' %d DoF, %d meas, %s)\n'</span>, sum(tmp), size(J,1), func2str(opt.calc_jacobian_scaling_func{i}));
0979       <span class="keyword">end</span>
0980       <span class="keyword">if</span> opt.verbose &gt;= 5
0981          clf;
0982          t=axes(<span class="string">'Position'</span>,[0 0 1 1],<span class="string">'Visible'</span>,<span class="string">'off'</span>); <span class="comment">% something to put our title on after we're done</span>
0983          text(0.03,0.1,sprintf(<span class="string">'update\\_jacobian (%s), iter=%d'</span>, strrep(J_str,<span class="string">'_'</span>,<span class="string">'\_'</span>), k),<span class="string">'FontSize'</span>,20,<span class="string">'Rotation'</span>,90);
0984          <span class="keyword">for</span> y=0:1
0985             <span class="keyword">if</span> y == 0; D = Jn; <span class="keyword">else</span> D = J(:,es:ee); <span class="keyword">end</span>
0986             axes(<span class="string">'units'</span>, <span class="string">'normalized'</span>, <span class="string">'position'</span>, [ 0.13 0.62-y/2 0.8 0.3 ]);
0987             imagesc(D);
0988             <span class="keyword">if</span> y == 0; ylabel(<span class="string">'meas (1)'</span>); xlabel([<span class="string">'elem ('</span> strrep(base_types{i},<span class="string">'_'</span>,<span class="string">'\_'</span>) <span class="string">')'</span>]);
0989             <span class="keyword">else</span>       ylabel(<span class="string">'meas (dN)'</span>); xlabel([<span class="string">'elem ('</span> strrep(opt.elem_working{i},<span class="string">'_'</span>,<span class="string">'\_'</span>) <span class="string">')'</span>]);
0990             <span class="keyword">end</span>
0991             os = get(gca, <span class="string">'Position'</span>); c=colorbar(<span class="string">'southoutside'</span>); <span class="comment">% colorbar start...</span>
0992             set(gca, <span class="string">'Position'</span>, os); <span class="comment">% fix STUPID colorbar resizing</span>
0993             <span class="comment">% reduce height, this has to be done after the axes fix or STUPID matlab messes things up real good</span>
0994             cP = get(c,<span class="string">'Position'</span>); set(c,<span class="string">'Position'</span>, [0.13    0.54-y/2    0.8    0.010]);
0995             axes(<span class="string">'units'</span>, <span class="string">'normalized'</span>, <span class="string">'position'</span>, [ 0.93 0.62-y/2 0.05 0.3 ]);
0996             barh(sqrt(sum(D.^2,2))); axis tight; axis ij; set(gca, <span class="string">'ytick'</span>, [], <span class="string">'yticklabel'</span>, []);
0997             axes(<span class="string">'units'</span>, <span class="string">'normalized'</span>, <span class="string">'position'</span>, [ 0.13 0.92-y/2 0.8 0.05 ]);
0998             bar(sqrt(sum(D.^2,1))); axis tight; set(gca, <span class="string">'xtick'</span>, [], <span class="string">'xticklabel'</span>, []);
0999          <span class="keyword">end</span>
1000          drawnow;
1001          <span class="keyword">if</span> isfield(opt,<span class="string">'fig_prefix'</span>)
1002             print(<span class="string">'-dpng'</span>,sprintf(<span class="string">'%s-J%d-%s'</span>,opt.fig_prefix,k,strrep(J_str,<span class="string">'_'</span>,<span class="string">''</span>)));
1003             print(<span class="string">'-dpdf'</span>,sprintf(<span class="string">'%s-J%d-%s'</span>,opt.fig_prefix,k,strrep(J_str,<span class="string">'_'</span>,<span class="string">''</span>)));
1004             saveas(gcf,sprintf(<span class="string">'%s-J%d-%s.fig'</span>,opt.fig_prefix,k,strrep(J_str,<span class="string">'_'</span>,<span class="string">''</span>)));
1005          <span class="keyword">end</span>
1006       <span class="keyword">end</span>
1007    <span class="keyword">end</span>
1008    <span class="keyword">if</span> opt.verbose &gt;= 4
1009       <span class="comment">% and try a show_fem with the pixel sensitivity</span>
1010       <span class="keyword">try</span>
1011          clf;
1012          imgb.elem_data = log(sqrt(sum(J.^2,1)));
1013          <span class="keyword">for</span> i = 1:length(imgb.current_params)
1014             imgb.current_params{i} = [ <span class="string">'log_sensitivity_'</span> imgb.current_params{i} ];
1015          <span class="keyword">end</span>
1016          <span class="keyword">if</span> isfield(imgb.inv_model,<span class="string">'rec_model'</span>)
1017             imgb.fwd_model = imgb.inv_model.rec_model;
1018          <span class="keyword">end</span>
1019          feval(opt.show_fem,imgb,1);
1020          title(sprintf(<span class="string">'sensitivity @ iter=%d'</span>,k));
1021          drawnow;
1022          <span class="keyword">if</span> isfield(opt,<span class="string">'fig_prefix'</span>)
1023             print(<span class="string">'-dpng'</span>,sprintf(<span class="string">'%s-Js%d-%s'</span>,opt.fig_prefix,k,strrep(J_str,<span class="string">'_'</span>,<span class="string">''</span>)));
1024             print(<span class="string">'-dpdf'</span>,sprintf(<span class="string">'%s-Js%d-%s'</span>,opt.fig_prefix,k,strrep(J_str,<span class="string">'_'</span>,<span class="string">''</span>)));
1025             saveas(gcf,sprintf(<span class="string">'%s-Js%d-%s.fig'</span>,opt.fig_prefix,k,strrep(J_str,<span class="string">'_'</span>,<span class="string">''</span>)));
1026          <span class="keyword">end</span>
1027       <span class="keyword">catch</span> <span class="comment">% no worries if it didn't work... carry on</span>
1028       <span class="keyword">end</span>
1029    <span class="keyword">end</span>
1030 
1031 <span class="comment">% -------------------------------------------------</span>
1032 <span class="comment">% Chain Rule Products for Jacobian Translations</span>
1033 <span class="comment">% x is conductivity, we want the chain rule to translate the</span>
1034 <span class="comment">% Jacobian of conductivity to conductivity on resistivity or</span>
1035 <span class="comment">% logs of either.</span>
1036 <span class="comment">% This chain rule works out to a constant.</span>
1037 <span class="comment">%</span>
1038 <span class="comment">% d log_b(x)     1          d x</span>
1039 <span class="comment">% ---------- = ------- , ---------- = x ln(b)</span>
1040 <span class="comment">%     d x      x ln(b)   d log_b(x)</span>
1041 <a name="_sub15" href="#_subfunctions" class="code">function S = dx_dlogx(x);</a>
1042    S = <a href="../../../eidors/models/private/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>(x);
1043 <a name="_sub16" href="#_subfunctions" class="code">function S = dx_dlog10x(x);</a>
1044    S = <a href="../../../eidors/models/private/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>(x * log(10));
1045 <span class="comment">% resistivity 'y'</span>
1046 <span class="comment">% d x     d x   -1</span>
1047 <span class="comment">% ----- = --- = ---, y = 1/x --&gt; -(x^2)</span>
1048 <span class="comment">% d 1/x   d y   y^2</span>
1049 <a name="_sub17" href="#_subfunctions" class="code">function S = dx_dy(x);</a>
1050    S = <a href="../../../eidors/models/private/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>(-(x.^2));
1051 <span class="comment">% then build the log versions of conductivity by combining chain rule products</span>
1052 <a name="_sub18" href="#_subfunctions" class="code">function S = dx_dlogy(x);</a>
1053 <span class="comment">%   S = dx_dy(x) * dy_dlogy(x);</span>
1054 <span class="comment">%     = -(x^2) * 1/x = -x</span>
1055    S = <a href="../../../eidors/models/private/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>(-x);
1056 <a name="_sub19" href="#_subfunctions" class="code">function S = dx_dlog10y(x);</a>
1057 <span class="comment">%   S = dx_dy(x) * dy_dlog10y(x);</span>
1058 <span class="comment">%     = -(x^2) * 1/(ln(10) x) = -x / ln(10)</span>
1059    S = <a href="../../../eidors/models/private/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>(-x/log(10));
1060 <span class="comment">% ... some renaming to make things understandable above: x = 1/y</span>
1061 <span class="comment">%function S = dy_dlogy(x);</span>
1062 <span class="comment">%   S = dx_dlogx(1./x);</span>
1063 <span class="comment">%function S = dy_dlog10y(x);</span>
1064 <span class="comment">%   S = dx_dlog10x(1./x);</span>
1065 <span class="comment">% -------------------------------------------------</span>
1066 <span class="comment">% apparent_resistivity 'a' versus voltage 'x'</span>
1067 <span class="comment">% d a    1  d v    1         v</span>
1068 <span class="comment">% --- = --- --- = --- ; a = ---</span>
1069 <span class="comment">% d v    vh d v    vh        vh</span>
1070 <span class="comment">% log_apparent_resistivity</span>
1071 <span class="comment">% d loga   d loga d a    1   1     vh  1     1</span>
1072 <span class="comment">% ------ = ------ --- = --- --- = --- --- = ---</span>
1073 <span class="comment">% d v       d a   d v    a   vh    v   vh    v</span>
1074 <a name="_sub20" href="#_subfunctions" class="code">function dN = da_dv(v,vh)</a>
1075    dN = <a href="../../../eidors/models/private/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>(1./vh); <span class="comment">% N == dN for apparent_resistivity</span>
1076 <a name="_sub21" href="#_subfunctions" class="code">function dN = dloga_dv(v,vh)</a>
1077    dN = <a href="../../../eidors/models/private/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>(1./v);
1078 <a name="_sub22" href="#_subfunctions" class="code">function dN = dlog10a_dv(v,vh)</a>
1079    dN = <a href="../../../eidors/models/private/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>( 1./(v * log(10)) );
1080 <a name="_sub23" href="#_subfunctions" class="code">function dN = dv_dv(v,vh)</a>
1081    dN = 1;
1082 <a name="_sub24" href="#_subfunctions" class="code">function dN = dlogv_dv(v,vh) </a><span class="comment">% same as dloga_dv</span>
1083    dN = <a href="#_sub21" class="code" title="subfunction dN = dloga_dv(v,vh)">dloga_dv</a>(v,vh);
1084 <a name="_sub25" href="#_subfunctions" class="code">function dN = dlog10v_dv(v,vh) </a><span class="comment">% same as dlog10a_dv</span>
1085    dN = <a href="#_sub22" class="code" title="subfunction dN = dlog10a_dv(v,vh)">dlog10a_dv</a>(v, vh);
1086 <span class="comment">% -------------------------------------------------</span>
1087 
1088 
1089 <a name="_sub26" href="#_subfunctions" class="code">function [alpha, img, dv, opt] = update_alpha(img, sx, data0, img0, N, W, hps2RtR, hpt2LLt, k, dv, opt)</a>
1090   <span class="keyword">if</span> k == 0 <span class="comment">% first iteration, just setting up, no line search happens</span>
1091      alpha = 0;
1092      <span class="keyword">return</span>;
1093   <span class="keyword">end</span>
1094 
1095   <span class="keyword">if</span>(opt.verbose &gt; 1)
1096      <span class="keyword">try</span>
1097          ls_str = func2str(opt.line_search_func);
1098      <span class="keyword">catch</span>
1099          ls_str = opt.line_search_func;
1100      <span class="keyword">end</span>
1101      fprintf(<span class="string">'    line search, alpha = %s\n'</span>, ls_str);
1102   <span class="keyword">end</span>
1103 
1104   <span class="comment">% some sanity checks before we feed this information to the line search</span>
1105   <a href="#_sub27" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(sx, <span class="string">'sx (pre-line search)'</span>);
1106   <a href="#_sub27" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(img.elem_data, <span class="string">'img.elem_data (pre-line search)'</span>);
1107 
1108   <span class="keyword">if</span> any(size(img.elem_data) ~= size(sx))
1109      error(sprintf(<span class="string">'mismatch on elem_data[%d,%d] vs. sx[%d,%d] vector sizes, check c2f_background_fixed'</span>,size(img.elem_data), size(sx)));
1110   <span class="keyword">end</span>
1111 
1112   optt = opt;
1113   <span class="keyword">if</span> isfield(optt,<span class="string">'fig_prefix'</span>) <span class="comment">% set fig_prefix for the iteration#</span>
1114     optt.fig_prefix = [opt.fig_prefix <span class="string">'-k'</span> num2str(k)];
1115   <span class="keyword">end</span>
1116   [alpha, imgo, dv, opto] = feval(opt.line_search_func, img, sx, data0, img0, N, W, hps2RtR, hpt2LLt, dv, optt);
1117   <span class="keyword">if</span> isfield(opt,<span class="string">'fig_prefix'</span>) <span class="comment">% set fig_prefix back to it's old value</span>
1118     opto.fig_prefix = opt.fig_prefix;
1119   <span class="keyword">end</span>
1120   <span class="keyword">if</span> ~isempty(imgo)
1121      img = imgo;
1122   <span class="keyword">else</span>
1123      img.elem_data = img.elem_data + alpha*sx;
1124   <span class="keyword">end</span>
1125   <span class="keyword">if</span> ~isempty(opto)
1126      opt = opto;
1127   <span class="keyword">end</span>
1128 
1129   <span class="keyword">if</span>(opt.verbose &gt; 1)
1130      fprintf(<span class="string">'      selected alpha=%0.3g\n'</span>, alpha);
1131   <span class="keyword">end</span>
1132 
1133   <span class="keyword">if</span> (alpha == 0) &amp;&amp; (k == 1)
1134     error(<span class="string">'first iteration failed to advance solution'</span>);
1135   <span class="keyword">end</span>
1136 
1137 <a name="_sub27" href="#_subfunctions" class="code">function err_if_inf_or_nan(x, str);</a>
1138   <span class="keyword">if</span> any(any(isnan(x) | isinf(x)))
1139       error(sprintf(<span class="string">'bad %s (%d NaN, %d Inf of %d)'</span>, <span class="keyword">...</span>
1140                     str, <span class="keyword">...</span>
1141                     length(find(isnan(x))), <span class="keyword">...</span>
1142                     length(find(isinf(x))), <span class="keyword">...</span>
1143                     length(x(:))));
1144   <span class="keyword">end</span>
1145 
1146 
1147 <a name="_sub28" href="#_subfunctions" class="code">function [img, dv] = update_img_using_limits(img, img0, data0, N, dv, opt)</a>
1148   <span class="comment">% fix max/min values for x</span>
1149   <span class="keyword">if</span> opt.max_value ~= +inf
1150      lih = find(img.elem_data &gt; opt.max_value);
1151      img.elem_data(lih) = opt.max_value;
1152      <span class="keyword">if</span> opt.verbose &gt; 1
1153         fprintf(<span class="string">'    limit max(x)=%g for %d elements\n'</span>, opt.max_value, length(lih));
1154      <span class="keyword">end</span>
1155      dv = []; <span class="comment">% dv is now invalid since we changed the conductivity</span>
1156   <span class="keyword">end</span>
1157   <span class="keyword">if</span> opt.min_value ~= -inf
1158      lil = find(img.elem_data &lt; opt.min_value);
1159      img.elem_data(lil) = opt.min_value;
1160      <span class="keyword">if</span> opt.verbose &gt; 1
1161         fprintf(<span class="string">'    limit min(x)=%g for %d elements\n'</span>, opt.min_value, length(lil));
1162      <span class="keyword">end</span>
1163      dv = []; <span class="comment">% dv is now invalid since we changed the conductivity</span>
1164   <span class="keyword">end</span>
1165   <span class="comment">% update voltage change estimate if the limit operation changed the img data</span>
1166   [dv, opt] = <a href="#_sub30" class="code" title="subfunction [dv, opt] = update_dv(dv, img, data0, N, opt, reason)">update_dv</a>(dv, img, data0, N, opt, <span class="string">'(dv out-of-date)'</span>);
1167 
1168 <a name="_sub29" href="#_subfunctions" class="code">function  de = update_de(de, img, img0, opt)</a>
1169    img0 = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img0, opt.elem_working);
1170    img  = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img,  opt.elem_working);
1171    <a href="#_sub27" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(img0.elem_data, <span class="string">'de img0'</span>);
1172    <a href="#_sub27" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(img.elem_data,  <span class="string">'de img'</span>);
1173    <span class="comment">% probably not the most robust check for whether this is the first update</span>
1174    <span class="comment">% but this ensures that we get exactly zero for the first iteration and not</span>
1175    <span class="comment">% a set of values that has numeric floating point errors that are nearly zero</span>
1176    <span class="keyword">if</span> isempty(de) <span class="comment">% first iteration</span>
1177       <span class="comment">% data hasn't changed yet!</span>
1178       de = zeros(size(img0.elem_data));
1179    <span class="keyword">else</span>
1180       de = img.elem_data - img0.elem_data;
1181    <span class="keyword">end</span>
1182    de(opt.elem_fixed) = 0; <span class="comment">% TODO is this redundant... delete me?</span>
1183    <a href="#_sub27" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(de, <span class="string">'de out'</span>);
1184 
1185 <a name="_sub30" href="#_subfunctions" class="code">function [dv, opt] = update_dv(dv, img, data0, N, opt, reason)</a>
1186    <span class="comment">% estimate current error as a residual</span>
1187    <span class="keyword">if</span> ~isempty(dv) <span class="comment">% need to calculate dv...</span>
1188       <span class="keyword">return</span>;
1189    <span class="keyword">end</span>
1190    <span class="keyword">if</span> nargin &lt; 7
1191       reason = <span class="string">''</span>;
1192    <span class="keyword">end</span>
1193    <span class="keyword">if</span> opt.verbose &gt; 1
1194       disp([<span class="string">'    fwd_solve b=Ax '</span>, reason]);
1195    <span class="keyword">end</span>
1196    [dv, opt, err] = <a href="#_sub32" class="code" title="subfunction [dv, opt, err] = update_dv_core(img, data0, N, opt)">update_dv_core</a>(img, data0, N, opt);
1197 <span class="comment">% TODO AB inject the img.error here, so it doesn't need to be recalculated when calc_solution_error=1</span>
1198 <span class="comment">%   img.error = err;</span>
1199 
1200 <a name="_sub31" href="#_subfunctions" class="code">function data = map_meas_struct(data, N, out)</a>
1201    <span class="keyword">try</span>
1202        current_meas_params = data.current_params;
1203    <span class="keyword">catch</span>
1204        current_meas_params = <span class="string">'voltage'</span>;
1205    <span class="keyword">end</span>
1206    data.meas = <a href="#_sub50" class="code" title="subfunction b = map_meas(b, N, in, out)">map_meas</a>(data.meas, N, current_meas_params, out);
1207    data.current_params = out;
1208    <a href="#_sub27" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(data.meas, <span class="string">'dv meas'</span>);
1209 
1210 <span class="comment">% also used by the line search as opt.line_search_dv_func</span>
1211 <a name="_sub32" href="#_subfunctions" class="code">function [dv, opt, err] = update_dv_core(img, data0, N, opt)</a>
1212    data0 = <a href="#_sub31" class="code" title="subfunction data = map_meas_struct(data, N, out)">map_meas_struct</a>(data0, N, <span class="string">'voltage'</span>);
1213    img = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img, <a href="#_sub46" class="code" title="subfunction out = map_img_base_types(img)">map_img_base_types</a>(img));
1214    img = feval(opt.update_img_func, img, opt);
1215    img = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img, <span class="string">'conductivity'</span>); <span class="comment">% drop everything but conductivity</span>
1216    <span class="comment">% if the electrodes/geometry moved, we need to recalculate N if it's being used</span>
1217    <span class="keyword">if</span> any(any(N ~= 1)) &amp;&amp; any(strcmp(<a href="#_sub46" class="code" title="subfunction out = map_img_base_types(img)">map_img_base_types</a>(img), <span class="string">'movement'</span>))
1218       <span class="comment">% note: data0 is mapped back to 'voltage' before N is modified</span>
1219       imgh=img; imgh.elem_data = imgh.elem_data(:,1)*0 +1; <span class="comment">% conductivity = 1</span>
1220       vh = <a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(imgh); vh = vh.meas;
1221       N = <a href="../../../eidors/models/private/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>(1./vh);
1222       opt.fwd_solutions = opt.fwd_solutions +1;
1223    <span class="keyword">end</span>
1224    data = <a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(img);
1225    opt.fwd_solutions = opt.fwd_solutions +1;
1226    dv = <a href="../../../eidors/solvers/calc_difference_data.html" class="code" title="function dva = calc_difference_data( data1, data2, fwd_model)">calc_difference_data</a>(data0, data, img.fwd_model);
1227 <span class="comment">%   clf;subplot(211); h=show_fem(img,1); set(h,'EdgeColor','none'); subplot(212); xx=1:length(dv); plot(xx,[data0.meas,data.meas,dv]); legend('d0','d1','dv'); drawnow; pause(1);</span>
1228    <span class="keyword">if</span> nargout &gt;= 3
1229       err = norm(dv)/norm(data0.meas);
1230    <span class="keyword">else</span>
1231       err = NaN;
1232    <span class="keyword">end</span>
1233    dv = <a href="#_sub50" class="code" title="subfunction b = map_meas(b, N, in, out)">map_meas</a>(dv, N, <span class="string">'voltage'</span>, opt.meas_working);
1234    <a href="#_sub27" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(dv, <span class="string">'dv out'</span>);
1235 
1236 <a name="_sub33" href="#_subfunctions" class="code">function show_fem_iter(k, img, inv_model, stop, opt)</a>
1237   <span class="keyword">if</span> (opt.verbose &lt; 4) || (stop == -1)
1238      <span class="keyword">return</span>; <span class="comment">% if verbosity is low OR we're dropping the last iteration because it was bad, do nothing</span>
1239   <span class="keyword">end</span>
1240   <span class="keyword">if</span> opt.verbose &gt; 1
1241      str=opt.show_fem;
1242      <span class="keyword">if</span> isa(str,<span class="string">'function_handle'</span>)
1243         str=func2str(str);
1244      <span class="keyword">end</span>
1245      disp([<span class="string">'    '</span> str <span class="string">'()'</span>]);
1246   <span class="keyword">end</span>
1247   <span class="keyword">if</span> isequal(opt.show_fem,@<a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>) <span class="comment">% opt.show_fem == @show_fem... so we need to try to be smart enough to make show_fem not explode</span>
1248      img = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img, <span class="string">'resistivity'</span>); <span class="comment">% TODO big fat hack to make this work at the expense of an actual function...</span>
1249      [img, opt] = <a href="#_sub44" class="code" title="subfunction [img, opt] = strip_c2f_background(img, opt, indent)">strip_c2f_background</a>(img, opt, <span class="string">'    '</span>);
1250      <span class="comment">% check we're returning the right size of data</span>
1251      <span class="keyword">if</span> isfield(inv_model, <span class="string">'rec_model'</span>)
1252        img.fwd_model = inv_model.rec_model;
1253      <span class="keyword">end</span>
1254    <span class="comment">%  bg = 1;</span>
1255    <span class="comment">%  img.calc_colours.ref_level = bg;</span>
1256    <span class="comment">%  img.calc_colours.clim = bg;</span>
1257      img.calc_colours.cb_shrink_move = [0.3,0.6,0.02]; <span class="comment">% move color bars</span>
1258      <span class="keyword">if</span> size(img.elem_data,1) ~= size(img.fwd_model.elems,1)
1259         warning(sprintf(<span class="string">'img.elem_data has %d elements, img.fwd_model.elems has %d elems\n'</span>, <span class="keyword">...</span>
1260                         size(img.elem_data,1), <span class="keyword">...</span>
1261                         size(img.fwd_model.elems,1)));
1262      <span class="keyword">end</span>
1263   <span class="keyword">else</span> <span class="comment">% do the &quot;final clean up&quot;, same as when we quit</span>
1264      img = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img, opt.elem_output);
1265      [img, opt] = <a href="#_sub44" class="code" title="subfunction [img, opt] = strip_c2f_background(img, opt, indent)">strip_c2f_background</a>(img, opt, <span class="string">'    '</span>);
1266      <span class="keyword">if</span> isfield(inv_model, <span class="string">'rec_model'</span>)
1267        img.fwd_model = inv_model.rec_model;
1268      <span class="keyword">end</span>
1269   <span class="keyword">end</span>
1270   clf; feval(opt.show_fem, img, 1);
1271   title(sprintf(<span class="string">'x @ iter=%d'</span>,k));
1272   drawnow;
1273   <span class="keyword">if</span> isfield(opt,<span class="string">'fig_prefix'</span>)
1274      print(<span class="string">'-dpdf'</span>,sprintf(<span class="string">'%s-x%d'</span>,opt.fig_prefix,k));
1275      print(<span class="string">'-dpng'</span>,sprintf(<span class="string">'%s-x%d'</span>,opt.fig_prefix,k));
1276      saveas(gcf,sprintf(<span class="string">'%s-x%d.fig'</span>,opt.fig_prefix,k));
1277   <span class="keyword">end</span>
1278 
1279 <a name="_sub34" href="#_subfunctions" class="code">function [ residual meas elem ] = GN_residual(dv, de, W, hps2RtR, hpt2LLt)</a>
1280    <span class="comment">% We operate on whatever the iterations operate on</span>
1281    <span class="comment">% (log data, resistance, etc) + perturb(i)*dx.</span>
1282    <span class="comment">% We use the kronecker vector identity (Bt x A) vec(X) = vec(A X B) to</span>
1283    <span class="comment">% efficiently compute a residual over many frames.</span>
1284    Wdv = W*dv;
1285    meas = 0.5 * dv(:)' * Wdv(:);
1286    Rde = hps2RtR * de * hpt2LLt';
1287    elem = 0.5 * de(:)' * Rde(:);
1288    residual = meas + elem;
1289 
1290 <a name="_sub35" href="#_subfunctions" class="code">function residual = meas_residual(dv, de, W, hps2RtR)</a>
1291    residual = norm(dv);
1292 
1293 <span class="comment">%function img = initial_estimate( imdl, data )</span>
1294 <span class="comment">%   img = calc_jacobian_bkgnd( imdl );</span>
1295 <span class="comment">%   vs = fwd_solve(img);</span>
1296 <span class="comment">%</span>
1297 <span class="comment">%   if isstruct(data)</span>
1298 <span class="comment">%      data = data.meas;</span>
1299 <span class="comment">%   else</span>
1300 <span class="comment">%     meas_select = [];</span>
1301 <span class="comment">%     try</span>
1302 <span class="comment">%        meas_select = imdl.fwd_model.meas_select;</span>
1303 <span class="comment">%     end</span>
1304 <span class="comment">%     if length(data) == length(meas_select)</span>
1305 <span class="comment">%        data = data(meas_select);</span>
1306 <span class="comment">%     end</span>
1307 <span class="comment">%   end</span>
1308 <span class="comment">%</span>
1309 <span class="comment">%   pf = polyfit(data,vs.meas,1);</span>
1310 <span class="comment">%</span>
1311 <span class="comment">%   % create elem_data</span>
1312 <span class="comment">%   img = data_mapper(img);</span>
1313 <span class="comment">%</span>
1314 <span class="comment">%   if isfield(img.fwd_model,'coarse2fine');</span>
1315 <span class="comment">%      % TODO: the whole coarse2fine needs work here.</span>
1316 <span class="comment">%      %   what happens if c2f doesn't cover the whole region</span>
1317 <span class="comment">%</span>
1318 <span class="comment">%      % TODO: the two cases are very different. c2f case should match other</span>
1319 <span class="comment">%      nc = size(img.fwd_model.coarse2fine,2);</span>
1320 <span class="comment">%      img.elem_data = mean(img.elem_data)*ones(nc,1)*pf(1);</span>
1321 <span class="comment">%   else</span>
1322 <span class="comment">%      img.elem_data = img.elem_data*pf(1);</span>
1323 <span class="comment">%   end</span>
1324 <span class="comment">%</span>
1325 <span class="comment">%   % remove elem_data</span>
1326 <span class="comment">%%   img = data_mapper(img,1);</span>
1327 <span class="comment">%</span>
1328 <span class="comment">%function [img opt] = update_step(org, next, dx, fmin,res, opt)</span>
1329 <span class="comment">%   if isfield(opt, 'update_func')</span>
1330 <span class="comment">%      [img opt] = feval(opt.update_func,org,next,dx,fmin,res,opt);</span>
1331 <span class="comment">%   else</span>
1332 <span class="comment">%      img = next;</span>
1333 <span class="comment">%   end</span>
1334 <span class="comment">%</span>
1335 <span class="comment">% function bg = calc_background_resistivity(fmdl, va)</span>
1336 <span class="comment">%   % have a look at what we've created</span>
1337 <span class="comment">%   % compare data to homgeneous (how good is the model?)</span>
1338 <span class="comment">%   % NOTE background conductivity is set by matching amplitude of</span>
1339 <span class="comment">%   % homogeneous data against the measurements to get rough matching</span>
1340 <span class="comment">%   if(opt.verbose&gt;1)</span>
1341 <span class="comment">%     fprintf('est. background resistivity\n');</span>
1342 <span class="comment">%   end</span>
1343 <span class="comment">%   cache_obj = { fmdl, va };</span>
1344 <span class="comment">%   BACKGROUND_R = eidors_obj('get-cache', cache_obj, 'calc_background_resistivity');</span>
1345 <span class="comment">%   if isempty(BACKGROUND_R);</span>
1346 <span class="comment">%     imgh = mk_image(fmdl, 1); % conductivity = 1 S/m</span>
1347 <span class="comment">%     vh = fwd_solve(imgh);</span>
1348 <span class="comment">%     % take the best fit of the data</span>
1349 <span class="comment">%     BACKGROUND_R = vh.meas \ va; % 32 Ohm.m ... agrees w/ Wilkinson's papers</span>
1350 <span class="comment">%     % update cache</span>
1351 <span class="comment">%     eidors_obj('set-cache', cache_obj, 'calc_background_resistivity', BACKGROUND_R);</span>
1352 <span class="comment">%   else</span>
1353 <span class="comment">%     if(opt.verbose &gt; 1)</span>
1354 <span class="comment">%       fprintf('  ... cache hit\n');</span>
1355 <span class="comment">%     end</span>
1356 <span class="comment">%   end</span>
1357 <span class="comment">%   if(opt.verbose &gt; 1)</span>
1358 <span class="comment">%     fprintf('estimated background resistivity: %0.1f Ohm.m\n', BACKGROUND_R);</span>
1359 <span class="comment">%   end</span>
1360 
1361 <a name="_sub36" href="#_subfunctions" class="code">function opt = parse_options(imdl,n_frames)</a>
1362    <span class="comment">% merge legacy options locations</span>
1363 <span class="comment">%   imdl = deprecate_imdl_opt(imdl, 'parameters');</span>
1364 <span class="comment">%   imdl = deprecate_imdl_opt(imdl, 'inv_solve');</span>
1365 
1366    <span class="comment">% for any general options</span>
1367    <span class="keyword">if</span> isfield(imdl, <span class="string">'inv_solve_core'</span>)
1368       opt = imdl.inv_solve_core;
1369    <span class="keyword">else</span>
1370       opt = struct;
1371    <span class="keyword">end</span>
1372 
1373    <span class="comment">% verbosity, debug output</span>
1374    <span class="comment">% 0: quiet</span>
1375    <span class="comment">% 1: print iteration count</span>
1376    <span class="comment">% 2: print details as the algorithm progresses</span>
1377    <span class="keyword">if</span> ~isfield(opt,<span class="string">'verbose'</span>)
1378       opt.verbose = 1;
1379       fprintf(<span class="string">'  selecting inv_model.inv_solve_core.verbose=1\n'</span>);
1380    <span class="keyword">end</span>
1381    <span class="keyword">if</span> opt.verbose &gt; 1
1382       fprintf(<span class="string">'  verbose = %d\n'</span>, opt.verbose);
1383       fprintf(<span class="string">'  setting default parameters\n'</span>);
1384    <span class="keyword">end</span>
1385    <span class="comment">% we track how many fwd_solves we do since they are the most expensive part of the iterations</span>
1386    opt.fwd_solutions = 0;
1387 
1388    <span class="keyword">if</span> ~isfield(opt, <span class="string">'show_fem'</span>)
1389       opt.show_fem = @<a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>;
1390    <span class="keyword">end</span>
1391 
1392    <span class="keyword">if</span> ~isfield(opt, <span class="string">'residual_func'</span>) <span class="comment">% the objective function</span>
1393       opt.residual_func = @<a href="#_sub34" class="code" title="subfunction [ residual meas elem ] = GN_residual(dv, de, W, hps2RtR, hpt2LLt)">GN_residual</a>; <span class="comment">% r = f(dv, de, W, hps2RtR, hpt2LLt)</span>
1394       <span class="comment">% NOTE: the meas_residual function exists to maintain</span>
1395       <span class="comment">% compatibility with Nolwenn's code, the GN_residual</span>
1396       <span class="comment">% is a better choice</span>
1397       <span class="comment">%opt.residual_func = @meas_residual; % [r,m,e] = f(dv, de, W, hps2RtR, hpt2LLt)</span>
1398    <span class="keyword">end</span>
1399 
1400    <span class="comment">% calculation of update components</span>
1401    <span class="keyword">if</span> ~isfield(opt, <span class="string">'update_func'</span>)
1402       opt.update_func = @<a href="#_sub39" class="code" title="subfunction dx = GN_update(J, W, hps2RtR, hpt2LLt, dv, de, opt)">GN_update</a>; <span class="comment">% dx = f(J, W, hps2RtR, hpt2LLt, dv, de, opt)</span>
1403    <span class="keyword">end</span>
1404    <span class="keyword">if</span> ~isfield(opt, <span class="string">'update_method'</span>)
1405       opt.update_method = <span class="string">'cholesky'</span>;
1406    <span class="keyword">end</span>
1407 
1408    <span class="comment">% figure out if things need to be calculated</span>
1409    <span class="keyword">if</span> ~isfield(opt, <span class="string">'calc_meas_icov'</span>)
1410       opt.calc_meas_icov = 0; <span class="comment">% W</span>
1411    <span class="keyword">end</span>
1412    <span class="keyword">if</span> ~isfield(opt, <span class="string">'calc_RtR_prior'</span>)
1413       opt.calc_RtR_prior = 0; <span class="comment">% RtR</span>
1414    <span class="keyword">end</span>
1415    <span class="keyword">if</span> ~isfield(opt, <span class="string">'calc_LLt_prior'</span>)
1416       opt.calc_LLt_prior = 0; <span class="comment">% LLt</span>
1417    <span class="keyword">end</span>
1418 <span class="comment">% TODO calc_spatial_hyperparameter, calc_temporal_hyperparameter</span>
1419    <span class="keyword">if</span> ~isfield(opt, <span class="string">'calc_hyperparameter'</span>)
1420       opt.calc_hyperparameter = 0; <span class="comment">% hps2</span>
1421    <span class="keyword">end</span>
1422 
1423 <span class="comment">%   try</span>
1424       <span class="keyword">if</span> opt.verbose &gt; 1
1425          fprintf(<span class="string">'    examining function %s(...) for required arguments\n'</span>, func2str(opt.update_func));
1426       <span class="keyword">end</span>
1427       <span class="comment">% ensure that necessary components are calculated</span>
1428       <span class="comment">% opt.update_func: dx = f(J, W, hps2RtR, dv, de, opt)</span>
1429 <span class="comment">%TODO BROKEN      args = function_depends_upon(opt.update_func, 6);</span>
1430       args = ones(5,1); <span class="comment">% TODO BROKEN</span>
1431       <span class="keyword">if</span> args(2) == 1
1432          opt.calc_meas_icov = 1;
1433       <span class="keyword">end</span>
1434       <span class="keyword">if</span> args(3) == 1
1435          opt.calc_hyperparameter = 1;
1436       <span class="keyword">end</span>
1437       <span class="keyword">if</span> args(4) == 1
1438          opt.calc_RtR_prior = 1;
1439       <span class="keyword">end</span>
1440       <span class="keyword">if</span> args(5) == 1
1441          opt.calc_LLt_prior = 1;
1442       <span class="keyword">end</span>
1443 <span class="comment">%   catch</span>
1444 <span class="comment">%      error('exploration of function %s via function_depends_upon() failed', func2str(opt.update_func));</span>
1445 <span class="comment">%   end</span>
1446 
1447    <span class="comment">% stopping criteria, solution limits</span>
1448    <span class="keyword">if</span> ~isfield(opt, <span class="string">'max_iterations'</span>)
1449       opt.max_iterations = 10;
1450    <span class="keyword">end</span>
1451    <span class="keyword">if</span> ~isfield(opt, <span class="string">'ntol'</span>)
1452       opt.ntol = eps; <span class="comment">% attempt to quantify numeric machine precision</span>
1453    <span class="keyword">end</span>
1454    <span class="keyword">if</span> ~isfield(opt, <span class="string">'tol'</span>)
1455       opt.tol = 0; <span class="comment">% terminate iterations if residual is less than tol</span>
1456    <span class="keyword">end</span>
1457    <span class="keyword">if</span> ~isfield(opt, <span class="string">'dtol'</span>)
1458       <span class="comment">% terminate iterations if residual slope is greater than dtol</span>
1459       <span class="comment">% generally, we would want dtol to be -0.01 (1% decrease) or something similar</span>
1460       <span class="comment">%  ... as progress levels out, stop working</span>
1461       opt.dtol = -1e-4; <span class="comment">% --&gt; -0.01% slope (really slow)</span>
1462    <span class="keyword">end</span>
1463    <span class="keyword">if</span> opt.dtol &gt; 0
1464       error(<span class="string">'dtol must be less than 0 (residual decreases at every iteration)'</span>);
1465       <span class="comment">% otherwise we won't converge...</span>
1466    <span class="keyword">end</span>
1467    <span class="keyword">if</span> ~isfield(opt, <span class="string">'dtol_iter'</span>)
1468       <span class="comment">%opt.dtol_iter = inf; % ignore dtol for dtol_iter iterations</span>
1469       opt.dtol_iter = 0; <span class="comment">% use dtol from the beginning</span>
1470    <span class="keyword">end</span>
1471    <span class="keyword">if</span> ~isfield(opt, <span class="string">'min_value'</span>)
1472       opt.min_value = -inf; <span class="comment">% min elem_data value</span>
1473    <span class="keyword">end</span>
1474    <span class="keyword">if</span> ~isfield(opt, <span class="string">'max_value'</span>)
1475       opt.max_value = +inf; <span class="comment">% max elem_data value</span>
1476    <span class="keyword">end</span>
1477    <span class="comment">% provide a graphical display of the line search values &amp; fit</span>
1478    <span class="keyword">if</span> ~isfield(opt, <span class="string">'plot_residuals'</span>)
1479       <span class="keyword">if</span> opt.verbose &gt; 2
1480          opt.plot_residuals = 1;
1481       <span class="keyword">else</span>
1482          opt.plot_residuals = 0;
1483       <span class="keyword">end</span>
1484    <span class="keyword">end</span>
1485    <span class="keyword">if</span> opt.plot_residuals ~= 0
1486       disp(<span class="string">'  residual plot (updated per iteration) are enabled, to disable them set'</span>);
1487       disp(<span class="string">'    inv_model.inv_solve_core.plot_residuals=0'</span>);
1488    <span class="keyword">end</span>
1489 
1490    <span class="comment">% line search</span>
1491    <span class="keyword">if</span> ~isfield(opt,<span class="string">'line_search_func'</span>)
1492       <span class="comment">% [alpha, img, dv, opt] = f(img, sx, data0, img0, N, W, hps2RtR, dv, opt);</span>
1493       opt.line_search_func = @<a href="line_search_onm2.html" class="code" title="function  [alpha, img, dv, opt] = line_search_onm2(imgk, dx, data1, img1, N, W, hps2RtR, hpt2LLt, dv0, opt, retry, pf_max)">line_search_onm2</a>;
1494    <span class="keyword">end</span>
1495    <span class="keyword">if</span> ~isfield(opt,<span class="string">'line_search_dv_func'</span>)
1496       opt.line_search_dv_func = @<a href="#_sub32" class="code" title="subfunction [dv, opt, err] = update_dv_core(img, data0, N, opt)">update_dv_core</a>;
1497       <span class="comment">% [dv, opt] = update_dv_core(img, data0, N, opt)</span>
1498    <span class="keyword">end</span>
1499    <span class="keyword">if</span> ~isfield(opt,<span class="string">'line_search_de_func'</span>)
1500       <span class="comment">% we create an anonymous function to skip the first input argument since</span>
1501       <span class="comment">% we always want to calculate de in the line search</span>
1502       opt.line_search_de_func = @(img, img0, opt) <a href="#_sub29" class="code" title="subfunction  de = update_de(de, img, img0, opt)">update_de</a>(1, img, img0, opt);
1503       <span class="comment">% de = f(img, img0, opt)</span>
1504    <span class="keyword">end</span>
1505    <span class="comment">% an initial guess for the line search step sizes, may be modified by line search</span>
1506    <span class="comment">% TODO this 'sensible default' should be moved to the line_search code since it is not generic to any other line searches</span>
1507    <span class="keyword">if</span> ~isfield(opt,<span class="string">'line_search_args'</span>) || <span class="keyword">...</span>
1508       ~isfield(opt.line_search_args, <span class="string">'perturb'</span>)
1509       fmin = 1/4; <span class="comment">% arbitrary starting guess</span>
1510       opt.line_search_args.perturb = [0 fmin/4 fmin/2 fmin fmin*2 fmin*4];
1511       <span class="comment">%opt.line_search_args.perturb = [0 fmin/4 fmin fmin*4];</span>
1512       <span class="comment">%opt.line_search_args.perturb = [0 0.1 0.35 0.7 1.0];</span>
1513       <span class="comment">%opt.line_search_args.perturb = [0 0.1 0.5 0.7 1.0];</span>
1514       <span class="comment">%pt.line_search_args.perturb = [0 0.1 0.7 0.9 1.0];</span>
1515       <span class="comment">%opt.line_search_args.perturb = [0 0.1 0.9 1.0];</span>
1516    <span class="keyword">end</span>
1517    <span class="comment">% provide a graphical display of the line search values &amp; fit</span>
1518    <span class="keyword">if</span> ~isfield(opt,<span class="string">'line_search_args'</span>) || <span class="keyword">...</span>
1519       ~isfield(opt.line_search_args, <span class="string">'plot'</span>)
1520       <span class="keyword">if</span> opt.verbose &gt;= 5
1521          opt.line_search_args.plot = 1;
1522       <span class="keyword">else</span>
1523          opt.line_search_args.plot = 0;
1524       <span class="keyword">end</span>
1525    <span class="keyword">end</span>
1526    <span class="comment">% pass fig_prefix to the line search as well, unless they are supposed to go somewhere elese</span>
1527    <span class="keyword">if</span> isfield(opt,<span class="string">'fig_prefix'</span>) &amp;&amp; <span class="keyword">...</span>
1528       isfield(opt,<span class="string">'line_search_args'</span>) &amp;&amp; <span class="keyword">...</span>
1529       ~isfield(opt.line_search_args, <span class="string">'fig_prefix'</span>)
1530       opt.line_search_args.fig_prefix = opt.fig_prefix;
1531    <span class="keyword">end</span>
1532    <span class="comment">% some help on how to turn off the line search plots if we don't want to see them</span>
1533    <span class="keyword">if</span> opt.line_search_args.plot ~= 0
1534       disp(<span class="string">'  line search plots (per iteration) are enabled, to disable them set'</span>);
1535       disp(<span class="string">'    inv_model.inv_solve_core.line_search_args.plot=0'</span>);
1536    <span class="keyword">end</span>
1537 
1538    <span class="comment">% background</span>
1539    <span class="comment">% if &gt; 0, this is the elem_data that holds the background</span>
1540    <span class="comment">% this is stripped off just before the iterations complete</span>
1541    <span class="keyword">if</span> ~isfield(opt, <span class="string">'c2f_background'</span>)
1542      <span class="keyword">if</span> isfield(imdl, <span class="string">'fwd_model'</span>) &amp;&amp; isfield(imdl.fwd_model, <span class="string">'coarse2fine'</span>)
1543         opt.c2f_background = -1; <span class="comment">% possible: check if its required later</span>
1544      <span class="keyword">else</span>
1545         opt.c2f_background = 0;
1546      <span class="keyword">end</span>
1547    <span class="keyword">end</span>
1548    <span class="keyword">if</span> ~isfield(opt, <span class="string">'c2f_background_fixed'</span>)
1549       opt.c2f_background_fixed = 1; <span class="comment">% generally, don't touch the background</span>
1550    <span class="keyword">end</span>
1551 
1552 
1553    <span class="comment">% DATA CONVERSION settings</span>
1554    <span class="comment">% elem type for the initial estimate is based on calc_jacobian_bkgnd which returns an img</span>
1555    <span class="keyword">if</span> ~isfield(opt, <span class="string">'elem_working'</span>)
1556       opt.elem_working = {<span class="string">'conductivity'</span>};
1557    <span class="keyword">end</span>
1558    <span class="keyword">if</span> ~isfield(opt, <span class="string">'elem_prior'</span>)
1559       opt.elem_prior = {<span class="string">'conductivity'</span>};
1560    <span class="keyword">end</span>
1561    <span class="keyword">if</span> ~isfield(opt, <span class="string">'elem_output'</span>)
1562       opt.elem_output = {<span class="string">'conductivity'</span>};
1563    <span class="keyword">end</span>
1564    <span class="keyword">if</span> ~isfield(opt, <span class="string">'meas_input'</span>)
1565       opt.meas_input = <span class="string">'voltage'</span>;
1566    <span class="keyword">end</span>
1567    <span class="keyword">if</span> ~isfield(opt, <span class="string">'meas_working'</span>)
1568       opt.meas_working = <span class="string">'voltage'</span>;
1569    <span class="keyword">end</span>
1570    <span class="comment">% if the user didn't put these into cell arrays, do</span>
1571    <span class="comment">% so here so there is less error checking later in</span>
1572    <span class="comment">% the code</span>
1573    <span class="keyword">for</span> i = {<span class="string">'elem_working'</span>, <span class="string">'elem_prior'</span>, <span class="string">'elem_output'</span>, <span class="string">'meas_input'</span>, <span class="string">'meas_working'</span>}
1574      <span class="comment">% MATLAB voodoo: deincapsulate a cell containing a</span>
1575      <span class="comment">% string, then use that to access a struct element</span>
1576      x = opt.(i{1});
1577      <span class="keyword">if</span> ~iscell(x)
1578         opt.(i{1}) = {x};
1579      <span class="keyword">end</span>
1580    <span class="keyword">end</span>
1581    <span class="keyword">if</span> length(opt.meas_input) &gt; 1
1582       error(<span class="string">'imdl.inv_solve_core.meas_input: multiple measurement types not yet supported'</span>);
1583    <span class="keyword">end</span>
1584    <span class="keyword">if</span> length(opt.meas_working) &gt; 1
1585       error(<span class="string">'imdl.inv_solve_core.meas_working: multiple measurement types not yet supported'</span>);
1586    <span class="keyword">end</span>
1587 
1588    <span class="keyword">if</span> ~isfield(opt, <span class="string">'prior_data'</span>)
1589       <span class="keyword">if</span> isfield(imdl, <span class="string">'jacobian_bkgnd'</span>) &amp;&amp; <span class="keyword">...</span>
1590          isfield(imdl.jacobian_bkgnd, <span class="string">'value'</span>) &amp;&amp; <span class="keyword">...</span>
1591          length(opt.elem_prior) == 1
1592          opt.prior_data = {imdl.jacobian_bkgnd.value};
1593       <span class="keyword">else</span>
1594          error(<span class="string">'requires inv_model.inv_solve_core.prior_data'</span>);
1595       <span class="keyword">end</span>
1596    <span class="keyword">end</span>
1597 
1598    <span class="keyword">if</span> ~isfield(opt, <span class="string">'elem_len'</span>)
1599       <span class="keyword">if</span> length(opt.elem_working) == 1
1600          <span class="keyword">if</span> isfield(imdl.fwd_model, <span class="string">'coarse2fine'</span>)
1601             c2f = imdl.fwd_model.coarse2fine; <span class="comment">% coarse-to-fine mesh mapping</span>
1602             opt.elem_len = { size(c2f,2) };
1603          <span class="keyword">else</span>
1604             opt.elem_len = { size(imdl.fwd_model.elems,1) };
1605          <span class="keyword">end</span>
1606       <span class="keyword">else</span>
1607         error(<span class="string">'requires inv_model.inv_solve_core.elem_len'</span>);
1608       <span class="keyword">end</span>
1609    <span class="keyword">end</span>
1610 
1611    <span class="keyword">if</span> ~isfield(opt, <span class="string">'n_frames'</span>)
1612       opt.n_frames = {n_frames};
1613    <span class="keyword">end</span>
1614 
1615    <span class="comment">% meas_select already handles selecting from the valid measurements</span>
1616    <span class="comment">% we want the same for the elem_data, so we only work on modifying the legal values</span>
1617    <span class="comment">% Note that c2f_background's elements are added to this list if opt.c2f_background_fixed == 1</span>
1618    <span class="keyword">if</span> ~isfield(opt, <span class="string">'elem_fixed'</span>) <span class="comment">% give a safe default, if none has been provided</span>
1619       opt.elem_fixed = [];
1620    <span class="keyword">elseif</span> iscell(opt.elem_fixed) <span class="comment">% if its a cell-array, we convert it to absolute</span>
1621      <span class="comment">% numbers in elem_data</span>
1622      <span class="comment">%  -- requires: opt.elem_len to already be constructed if it was missing</span>
1623       offset=0;
1624       ef=[];
1625       <span class="keyword">for</span> i=1:length(opt.elem_fixed)
1626          ef = [ef, opt.elem_fixed{i} + offset];
1627          offset = offset + opt.elem_len{i};
1628       <span class="keyword">end</span>
1629       opt.elem_fixed = ef;
1630    <span class="keyword">end</span>
1631 
1632    <span class="comment">% allow a cell array of jacobians</span>
1633    <span class="keyword">if</span> ~isfield(opt, <span class="string">'jacobian'</span>)
1634       <span class="keyword">if</span> ~iscell(imdl.fwd_model.jacobian)
1635          opt.jacobian = {imdl.fwd_model.jacobian};
1636       <span class="keyword">else</span>
1637          opt.jacobian = imdl.fwd_model.jacobian;
1638       <span class="keyword">end</span>
1639    <span class="keyword">elseif</span> isfield(imdl.fwd_model, <span class="string">'jacobian'</span>)
1640       imdl.fwd_model
1641       imdl
1642       error(<span class="string">'inv_model.fwd_model.jacobian and inv_model.inv_solve_core.jacobian should not both exist: it''s ambiguous'</span>);
1643    <span class="keyword">end</span>
1644 
1645    <span class="keyword">if</span> isfield(opt, <span class="string">'hyperparameter'</span>)
1646       opt.hyperparameter_spatial = opt.hyperparameter; <span class="comment">% backwards compatible</span>
1647       opt = rmfield(opt, <span class="string">'hyperparameter'</span>);
1648    <span class="keyword">end</span>
1649    <span class="comment">% default hyperparameter is 1</span>
1650    <span class="keyword">if</span> ~isfield(opt, <span class="string">'hyperparameter_spatial'</span>)
1651       opt.hyperparameter_spatial = {[]};
1652       <span class="keyword">for</span> i=1:length(opt.elem_working)
1653          opt.hyperparameter_spatial{i} = 1;
1654       <span class="keyword">end</span>
1655    <span class="keyword">end</span>
1656    <span class="keyword">if</span> ~isfield(opt, <span class="string">'hyperparameter_temporal'</span>)
1657       opt.hyperparameter_temporal = {[]};
1658       <span class="keyword">for</span> i=1:length(opt.meas_working)
1659          opt.hyperparameter_temporal{i} = 1;
1660       <span class="keyword">end</span>
1661    <span class="keyword">end</span>
1662    <span class="comment">% if the user didn't put these into cell arrays, do</span>
1663    <span class="comment">% so here so there is less error checking later in</span>
1664    <span class="comment">% the code</span>
1665    <span class="keyword">for</span> i = {<span class="string">'elem_len'</span>, <span class="string">'prior_data'</span>, <span class="string">'jacobian'</span>, <span class="string">'hyperparameter_spatial'</span>, <span class="string">'hyperparameter_temporal'</span>}
1666      <span class="comment">% MATLAB voodoo: deincapsulate a cell containing a</span>
1667      <span class="comment">% string, then use that to access a struct eleemnt</span>
1668      x = opt.(i{1});
1669      <span class="keyword">if</span> ~iscell(x)
1670         opt.(i{1}) = {x};
1671      <span class="keyword">end</span>
1672    <span class="keyword">end</span>
1673    <span class="comment">% show what the hyperparameters are configured to when logging</span>
1674    <span class="keyword">if</span> opt.verbose &gt; 1
1675       fprintf(<span class="string">'  hyperparameters\n'</span>);
1676       <span class="keyword">try</span>
1677           hp_global = imdl.hyperparameter.value;
1678           hp_global_str = sprintf(<span class="string">' x %0.4g'</span>,hp_global);
1679       <span class="keyword">catch</span>
1680           hp_global = 1;
1681           hp_global_str = <span class="string">''</span>;
1682       <span class="keyword">end</span>
1683       <span class="keyword">for</span> i=1:length(opt.elem_working)
1684          <span class="keyword">if</span> isnumeric(opt.hyperparameter_spatial{i}) &amp;&amp; length(opt.hyperparameter_spatial{i}) == 1
1685             fprintf(<span class="string">'    %s: %0.4g\n'</span>,opt.elem_working{i}, opt.hyperparameter_spatial{i}*hp_global);
1686          <span class="keyword">elseif</span> isa(opt.hyperparameter_spatial{i}, <span class="string">'function_handle'</span>)
1687             fprintf(<span class="string">'    %s: @%s%s\n'</span>,opt.elem_working{i}, func2str(opt.hyperparameter_spatial{i}), hp_global_str);
1688          <span class="keyword">elseif</span> ischar(opt.hyperparameter_spatial{i})
1689             fprintf(<span class="string">'    %s: @%s%s\n'</span>,opt.elem_working{i}, opt.hyperparameter_spatial{i}, hp_global_str);
1690          <span class="keyword">else</span>
1691             fprintf(<span class="string">'    %s: ...\n'</span>,opt.elem_working{i});
1692          <span class="keyword">end</span>
1693       <span class="keyword">end</span>
1694       <span class="keyword">for</span> i=1:length(opt.meas_working)
1695          <span class="keyword">if</span> isnumeric(opt.hyperparameter_temporal{i}) &amp;&amp; length(opt.hyperparameter_temporal{i}) == 1
1696             fprintf(<span class="string">'    %s: %0.4g\n'</span>,opt.meas_working{i}, opt.hyperparameter_temporal{i}*hp_global);
1697          <span class="keyword">elseif</span> isa(opt.hyperparameter_temporal{i}, <span class="string">'function_handle'</span>)
1698             fprintf(<span class="string">'    %s: @%s%s\n'</span>,opt.meas_working{i}, func2str(opt.hyperparameter_temporal{i}), hp_global_str);
1699          <span class="keyword">elseif</span> ischar(opt.hyperparameter_temporal{i})
1700             fprintf(<span class="string">'    %s: @%s%s\n'</span>,opt.meas_working{i}, opt.hyperparameter_temporal{i}, hp_global_str);
1701          <span class="keyword">else</span>
1702             fprintf(<span class="string">'    %s: ...\n'</span>,opt.meas_working{i});
1703          <span class="keyword">end</span>
1704       <span class="keyword">end</span>
1705    <span class="keyword">end</span>
1706 
1707    <span class="comment">% REGULARIZATION RtR</span>
1708    <span class="comment">% for constructing the blockwise RtR matrix</span>
1709    <span class="comment">% can be: explicit matrix, blockwise matrix diagonal, or full blockwise matrix</span>
1710    <span class="comment">% blockwise matrices can be function ptrs or explicit</span>
1711    <span class="keyword">if</span> ~isfield(opt, <span class="string">'RtR_prior'</span>)
1712       <span class="keyword">if</span> isfield(imdl, <span class="string">'RtR_prior'</span>)
1713          opt.RtR_prior = {imdl.RtR_prior};
1714       <span class="keyword">else</span>
1715          opt.RtR_prior = {[]}; <span class="comment">% null matrix (all zeros)</span>
1716          warning(<span class="string">'missing imdl.inv_solve_core.RtR_prior or imdl.RtR_prior: assuming NO spatial regularization RtR=0'</span>);
1717       <span class="keyword">end</span>
1718    <span class="keyword">end</span>
1719    <span class="comment">% bit of a make work project but if its actually a full numeric matrix we</span>
1720    <span class="comment">% canoncialize it by breaking it up into the blockwise components</span>
1721    <span class="keyword">if</span> isnumeric(opt.RtR_prior)
1722       <span class="keyword">if</span> size(opt.RtR_prior, 1) ~= size(opt.RtR_prior, 2)
1723          error(<span class="string">'expecting square matrix for imdl.RtR_prior or imdl.inv_solve_core.RtR_prior'</span>);
1724       <span class="keyword">end</span>
1725       <span class="keyword">if</span> length(opt.RtR_prior) == 1
1726          opt.RtR_prior = {opt.RtR_prior}; <span class="comment">% encapsulate directly into a cell array</span>
1727       <span class="keyword">else</span>
1728          RtR = opt.RtR_prior;
1729          opt.RtR_prior = {[]};
1730          esi = 0; eei = 0;
1731          <span class="keyword">for</span> i=1:length(opt.elem_len)
1732             esi = eei +1;
1733             eei = eei +opt.elem_len{i};
1734             esj = 0; eej = 0;
1735             <span class="keyword">for</span> j=1:length(opt.elem_len)
1736                esj = eej +1;
1737                eej = eej +opt.elem_len{j};
1738                opt.RtR_prior(i,j) = RtR(esi:eei, esj:eej);
1739             <span class="keyword">end</span>
1740          <span class="keyword">end</span>
1741       <span class="keyword">end</span>
1742    <span class="keyword">elseif</span> ~iscell(opt.RtR_prior) <span class="comment">% not a cell array? encapsulate it</span>
1743       opt.RtR_prior = {opt.RtR_prior};
1744    <span class="keyword">end</span>
1745    <span class="comment">% if not square then expand the block matrix</span>
1746    <span class="comment">% single row/column: this is our diagonal --&gt; expand to full blockwise matrix</span>
1747    <span class="keyword">if</span> any(size(opt.RtR_prior) ~= ([1 1]*length(opt.elem_len)))
1748       <span class="keyword">if</span> (size(opt.RtR_prior, 1) ~= 1) &amp;&amp; <span class="keyword">...</span>
1749          (size(opt.RtR_prior, 2) ~= 1)
1750          error(<span class="string">'odd imdl.RtR_prior or imdl.inv_solve_core.RtR_prior, cannot figure out how to expand it blockwise'</span>);
1751       <span class="keyword">end</span>
1752       <span class="keyword">if</span> (size(opt.RtR_prior, 1) ~= length(opt.elem_len)) &amp;&amp; <span class="keyword">...</span>
1753          (size(opt.RtR_prior, 2) ~= length(opt.elem_len))
1754          error(<span class="string">'odd imdl.RtR_prior or imdl.inv_solve_core.RtR_prior, not enough blockwise components vs. elem_working types'</span>);
1755       <span class="keyword">end</span>
1756       RtR_diag = opt.RtR_prior;
1757       opt.RtR_prior = {[]}; <span class="comment">% delete and start again</span>
1758       <span class="keyword">for</span> i=1:length(opt.elem_len)
1759          opt.RtR_prior(i,i) = RtR_diag(i);
1760       <span class="keyword">end</span>
1761    <span class="keyword">end</span>
1762    <span class="comment">% now sort out the hyperparameter for the &quot;R^T R&quot; (RtR) matrix</span>
1763    hp=opt.hyperparameter_spatial;
1764    <span class="keyword">if</span> size(hp,1) == 1 <span class="comment">% one row</span>
1765       hp = hp'; <span class="comment">% ... now one col</span>
1766    <span class="keyword">end</span>
1767    <span class="keyword">if</span> iscell(hp)
1768       <span class="comment">% if it's a cell array that matches size of the RtR, then we're done</span>
1769       <span class="keyword">if</span> all(size(hp) == size(opt.RtR_prior))
1770          opt.hyperparameter_spatial = hp;
1771       <span class="comment">% if the columns match, then we can expand on the diagonal, everything else gets '1'</span>
1772       <span class="keyword">elseif</span> length(hp) == length(opt.RtR_prior)
1773          opt.hyperparameter_spatial = opt.RtR_prior;
1774          [opt.hyperparameter_spatial{:}] = deal(1); <span class="comment">% hp = 1 everywhere</span>
1775          opt.hyperparameter_spatial(logical(eye(size(opt.RtR_prior)))) = hp; <span class="comment">% assign to diagonal</span>
1776       <span class="keyword">else</span>
1777          error(<span class="string">'hmm, don''t understand this opt.hyperparameter_spatial cellarray'</span>);
1778       <span class="keyword">end</span>
1779    <span class="comment">% if it's a single hyperparameter, that's the value everywhere</span>
1780    <span class="keyword">elseif</span> isnumeric(hp)
1781       opt.hyperparameter_spatial = opt.RtR_prior;
1782       [opt.hyperparameter_spatial{:}] = deal({hp});
1783    <span class="keyword">else</span>
1784       error(<span class="string">'don''t understand this opt.hyperparameter_spatial'</span>);
1785    <span class="keyword">end</span>
1786    
1787    <span class="comment">% REGULARIZATION LLt</span>
1788    <span class="comment">% for constructing the blockwise LLt matrix</span>
1789    <span class="comment">% can be: explicit matrix, blockwise matrix diagonal, or full blockwise matrix</span>
1790    <span class="comment">% blockwise matrices can be function ptrs or explicit</span>
1791    <span class="keyword">if</span> ~isfield(opt, <span class="string">'LLt_prior'</span>)
1792       <span class="keyword">if</span> isfield(imdl, <span class="string">'LLt_prior'</span>)
1793          opt.LLt_prior = {imdl.LLt_prior};
1794       <span class="keyword">else</span>
1795          opt.LLt_prior = {eye(n_frames)};
1796          <span class="keyword">if</span> n_frames ~= 1
1797             fprintf(<span class="string">'warning: missing imdl.inv_solve_core.LLt_prior or imdl.LLt_prior: assuming NO temporal regularization LLt=I\n'</span>);
1798          <span class="keyword">end</span>
1799       <span class="keyword">end</span>
1800    <span class="keyword">end</span>
1801    <span class="comment">% bit of a make work project but if its actually a full numeric matrix we</span>
1802    <span class="comment">% canoncialize it by breaking it up into the blockwise components</span>
1803    <span class="keyword">if</span> isnumeric(opt.LLt_prior)
1804       <span class="keyword">if</span> size(opt.LLt_prior, 1) ~= size(opt.LLt_prior, 2)
1805          error(<span class="string">'expecting square matrix for imdl.LLt_prior or imdl.inv_solve_core.LLt_prior'</span>);
1806       <span class="keyword">end</span>
1807       <span class="keyword">if</span> length(opt.LLt_prior) == 1
1808          opt.LLt_prior = {opt.LLt_prior}; <span class="comment">% encapsulate directly into a cell array</span>
1809       <span class="keyword">else</span>
1810          LLt = opt.LLt_prior;
1811          opt.LLt_prior = {[]};
1812          msi = 0; mei = 0;
1813          <span class="keyword">for</span> i=1:length(opt.n_frames)
1814             msi = mei +1;
1815             mei = mei +opt.n_frames{i};
1816             msj = 0; mej = 0;
1817             <span class="keyword">for</span> j=1:length(opt.n_frames)
1818                msj = mej +1;
1819                mej = mej +opt.n_frames{j};
1820                opt.LLt_prior(i,j) = LLt(msi:mei, msj:mej);
1821             <span class="keyword">end</span>
1822          <span class="keyword">end</span>
1823       <span class="keyword">end</span>
1824    <span class="keyword">elseif</span> ~iscell(opt.LLt_prior) <span class="comment">% not a cell array? encapsulate it</span>
1825       opt.LLt_prior = {opt.LLt_prior};
1826    <span class="keyword">end</span>
1827    <span class="comment">% if not square then expand the block matrix</span>
1828    <span class="comment">% single row/column: this is our diagonal --&gt; expand to full blockwise matrix</span>
1829    <span class="keyword">if</span> any(size(opt.LLt_prior) ~= ([1 1]*length(opt.n_frames)))
1830       <span class="keyword">if</span> (size(opt.LLt_prior, 1) ~= 1) &amp;&amp; <span class="keyword">...</span>
1831          (size(opt.LLt_prior, 2) ~= 1)
1832          error(<span class="string">'odd imdl.LLt_prior or imdl.inv_solve_core.LLt_prior, cannot figure out how to expand it blockwise'</span>);
1833       <span class="keyword">end</span>
1834       <span class="keyword">if</span> (size(opt.LLt_prior, 1) ~= length(opt.n_frames)) &amp;&amp; <span class="keyword">...</span>
1835          (size(opt.LLt_prior, 2) ~= length(opt.n_frames))
1836          error(<span class="string">'odd imdl.LLt_prior or imdl.inv_solve_core.LLt_prior, not enough blockwise components vs. meas_working types'</span>);
1837       <span class="keyword">end</span>
1838       LLt_diag = opt.LLt_prior;
1839       opt.LLt_prior = {[]}; <span class="comment">% delete and start again</span>
1840       <span class="keyword">for</span> i=1:length(opt.n_frames)
1841          opt.LLt_prior(i,i) = LLt_diag(i);
1842       <span class="keyword">end</span>
1843    <span class="keyword">end</span>
1844    <span class="comment">% now sort out the hyperparameter for the &quot;L L^t&quot; (LLt) matrix</span>
1845    hp=opt.hyperparameter_temporal;
1846    <span class="keyword">if</span> size(hp,1) == 1 <span class="comment">% one row</span>
1847       hp = hp'; <span class="comment">% ... now one col</span>
1848    <span class="keyword">end</span>
1849    <span class="keyword">if</span> iscell(hp)
1850       <span class="comment">% if it's a cell array that matches size of the LLt, then we're done</span>
1851       <span class="keyword">if</span> all(size(hp) == size(opt.LLt_prior))
1852          opt.hyperparameter_temporal = hp;
1853       <span class="comment">% if the columns match, then we can expand on the diagonal, everything else gets '1'</span>
1854       <span class="keyword">elseif</span> length(hp) == length(opt.LLt_prior)
1855          opt.hyperparameter_temporal = opt.LLt_prior;
1856          [opt.hyperparameter_temporal{:}] = deal(1); <span class="comment">% hp = 1 everywhere</span>
1857          opt.hyperparameter_temporal(logical(eye(size(opt.LLt_prior)))) = hp; <span class="comment">% assign to diagonal</span>
1858       <span class="keyword">else</span>
1859          error(<span class="string">'hmm, don''t understand this opt.hyperparameter_temporal cellarray'</span>);
1860       <span class="keyword">end</span>
1861    <span class="comment">% if it's a single hyperparameter, that's the value everywhere</span>
1862    <span class="keyword">elseif</span> isnumeric(hp)
1863       opt.hyperparameter_temporal = opt.LLt_prior;
1864       [opt.hyperparameter_temporal{:}] = deal({hp});
1865    <span class="keyword">else</span>
1866       error(<span class="string">'don''t understand this opt.hyperparameter_temporal'</span>);
1867    <span class="keyword">end</span>
1868 
1869    <span class="comment">% JACOBIAN CHAIN RULE conductivity -&gt; whatever</span>
1870    <span class="comment">% where x = conductivity at this iteration</span>
1871    <span class="comment">%       S = a scaling matrix, generally a diagonal matrix of size matching Jacobian columns</span>
1872    <span class="comment">% Jn = J * S;</span>
1873    <span class="comment">% if not provided, determine based on 'elem_working' type</span>
1874    <span class="keyword">if</span> ~isfield(opt, <span class="string">'calc_jacobian_scaling_func'</span>)
1875       pinv = strfind(opt.elem_working, <span class="string">'resistivity'</span>);
1876       plog = strfind(opt.elem_working, <span class="string">'log_'</span>);
1877       plog10 = strfind(opt.elem_working, <span class="string">'log10_'</span>);
1878       <span class="keyword">for</span> i = 1:length(opt.elem_working)
1879         prefix = <span class="string">''</span>;
1880         <span class="keyword">if</span> plog{i}
1881            prefix = <span class="string">'log'</span>;
1882         <span class="keyword">elseif</span> plog10{i}
1883            prefix = <span class="string">'log10'</span>;
1884         <span class="keyword">else</span>
1885            prefix = <span class="string">''</span>;
1886         <span class="keyword">end</span>
1887         <span class="keyword">if</span> pinv{i}
1888            prefix = [prefix <span class="string">'_inv'</span>];
1889         <span class="keyword">end</span>
1890         <span class="keyword">switch</span>(prefix)
1891           <span class="keyword">case</span> <span class="string">''</span>
1892              opt.calc_jacobian_scaling_func{i} = @<a href="#_sub42" class="code" title="subfunction [out, x, y, z] = ret1_func(varargin);">ret1_func</a>;  <span class="comment">% S = f(x)</span>
1893           <span class="keyword">case</span> <span class="string">'log'</span>
1894              opt.calc_jacobian_scaling_func{i} = @<a href="#_sub15" class="code" title="subfunction S = dx_dlogx(x);">dx_dlogx</a>;   <span class="comment">% S = f(x)</span>
1895           <span class="keyword">case</span> <span class="string">'log10'</span>
1896              opt.calc_jacobian_scaling_func{i} = @<a href="#_sub16" class="code" title="subfunction S = dx_dlog10x(x);">dx_dlog10x</a>; <span class="comment">% S = f(x)</span>
1897           <span class="keyword">case</span> <span class="string">'_inv'</span>
1898              opt.calc_jacobian_scaling_func{i} = @<a href="#_sub17" class="code" title="subfunction S = dx_dy(x);">dx_dy</a>;      <span class="comment">% S = f(x)</span>
1899           <span class="keyword">case</span> <span class="string">'log_inv'</span>
1900              opt.calc_jacobian_scaling_func{i} = @<a href="#_sub18" class="code" title="subfunction S = dx_dlogy(x);">dx_dlogy</a>;   <span class="comment">% S = f(x)</span>
1901           <span class="keyword">case</span> <span class="string">'log10_inv'</span>
1902              opt.calc_jacobian_scaling_func{i} = @<a href="#_sub19" class="code" title="subfunction S = dx_dlog10y(x);">dx_dlog10y</a>; <span class="comment">% S = f(x)</span>
1903           <span class="keyword">otherwise</span>
1904              error(<span class="string">'oops'</span>);
1905        <span class="keyword">end</span>
1906      <span class="keyword">end</span>
1907    <span class="keyword">end</span>
1908 
1909    <span class="keyword">if</span> ~isfield(opt, <span class="string">'update_img_func'</span>)
1910       opt.update_img_func = @<a href="#_sub41" class="code" title="subfunction out = null_func(in, varargin);">null_func</a>; <span class="comment">% img = f(img, opt)</span>
1911    <span class="keyword">end</span>
1912 
1913    <span class="keyword">if</span> ~isfield(opt, <span class="string">'return_working_variables'</span>)
1914       opt.return_working_variables = 0;
1915    <span class="keyword">end</span>
1916 
1917 <a name="_sub37" href="#_subfunctions" class="code">function check_matrix_sizes(J, W, hps2RtR, hpt2LLt, dv, de, opt)</a>
1918    <span class="comment">% assuming our equation looks something like</span>
1919    <span class="comment">% dx = (J'*W*J + hps2RtR)\(J'*dv + hps2RtR*de);</span>
1920    <span class="comment">% check that all the matrix sizes are correct</span>
1921    ne = size(de,1);
1922    nv = size(dv,1);
1923    nf = size(dv,2);
1924    <span class="keyword">if</span> size(de,2) ~= size(dv,2)
1925       error(<span class="string">'de cols (%d) not equal to dv cols (%d)'</span>, size(de,2), size(dv,2));
1926    <span class="keyword">end</span>
1927    <span class="keyword">if</span> opt.calc_meas_icov &amp;&amp; <span class="keyword">...</span>
1928       any(size(W) ~= [nv nv])
1929       error(<span class="string">'W size (%d rows, %d cols) is incorrect (%d rows, %d cols)'</span>, size(W), nv, nv);
1930    <span class="keyword">end</span>
1931    <span class="keyword">if</span> any(size(J) ~= [nv ne])
1932       error(<span class="string">'J size (%d rows, %d cols) is incorrect (%d rows, %d cols)'</span>, size(J), nv, ne);
1933    <span class="keyword">end</span>
1934    <span class="keyword">if</span> opt.calc_RtR_prior &amp;&amp; <span class="keyword">...</span>
1935       any(size(hps2RtR) ~= [ne ne])
1936       error(<span class="string">'hps2RtR size (%d rows, %d cols) is incorrect (%d rows, %d cols)'</span>, size(hps2RtR), ne, ne);
1937    <span class="keyword">end</span>
1938    <span class="keyword">if</span> opt.calc_LLt_prior &amp;&amp; <span class="keyword">...</span>
1939       any(size(hpt2LLt) ~= [nf nf])
1940       error(<span class="string">'hpt2LLt size (%d rows, %d cols) is incorrect (%d rows, %d cols)'</span>, size(hpt2LLt), nf, nf);
1941    <span class="keyword">end</span>
1942 
1943 <a name="_sub38" href="#_subfunctions" class="code">function dx = update_dx(J, W, hps2RtR, hpt2LLt, dv, de, opt)</a>
1944    <span class="keyword">if</span>(opt.verbose &gt; 1)
1945       fprintf( <span class="string">'    calc step size dx\n'</span>);
1946    <span class="keyword">end</span>
1947    <span class="comment">% don't penalize for fixed elements</span>
1948    de(opt.elem_fixed) = 0;
1949 
1950    <span class="comment">% TODO move this outside the inner loop of the iterations, it only needs to be done once</span>
1951    <a href="#_sub37" class="code" title="subfunction check_matrix_sizes(J, W, hps2RtR, hpt2LLt, dv, de, opt)">check_matrix_sizes</a>(J, W, hps2RtR, hpt2LLt, dv, de, opt)
1952 
1953    <span class="comment">% zero out the appropriate things so that we can get a dx=0 for the elem_fixed</span>
1954    J(:,opt.elem_fixed) = 0;
1955    de(opt.elem_fixed,:) = 0;
1956    hps2RtR(opt.elem_fixed,:) = 0;
1957    V=opt.elem_fixed;
1958    N=size(hps2RtR,1)+1;
1959    hps2RtR(N*(V-1)+1) = 1; <span class="comment">% set diagonals to 1 to avoid divide by zero</span>
1960    <span class="comment">% do the update step direction calculation</span>
1961    dx = feval(opt.update_func, J, W, hps2RtR, hpt2LLt, dv, de, opt);
1962 
1963    <span class="comment">% check that our elem_fixed stayed fixed</span>
1964    <span class="keyword">if</span> any(dx(opt.elem_fixed) ~= 0)
1965       error(<span class="string">'elem_fixed did''t give dx=0 at update_dx'</span>)
1966    <span class="keyword">end</span>
1967 
1968    <span class="keyword">if</span>(opt.verbose &gt; 1)
1969       fprintf(<span class="string">'      ||dx||=%0.3g\n'</span>, norm(dx));
1970       es = 0; ee = 0;
1971       <span class="keyword">for</span> i=1:length(opt.elem_working)
1972           es = ee +1; ee = ee + opt.elem_len{i};
1973           nd = norm(dx(es:ee));
1974           fprintf( <span class="string">'      ||dx_%d||=%0.3g (%s)\n'</span>,i, nd, opt.elem_working{i});
1975       <span class="keyword">end</span>
1976    <span class="keyword">end</span>
1977 
1978 <a name="_sub39" href="#_subfunctions" class="code">function dx = GN_update(J, W, hps2RtR, hpt2LLt, dv, de, opt)</a>
1979    <span class="keyword">if</span> ~any(strcmp(opt.update_method, {<span class="string">'cholesky'</span>,<span class="string">'pcg'</span>}))
1980       error([<span class="string">'unsupported update_method: '</span>,opt.update_method]);
1981    <span class="keyword">end</span>
1982    <span class="keyword">if</span> strcmp(opt.update_method, <span class="string">'cholesky'</span>)
1983       <span class="keyword">try</span>
1984          <span class="comment">% expansion for multiple frames</span>
1985          <span class="keyword">if</span> any(any(hpt2LLt ~= eye(size(hpt2LLt))))
1986             <span class="comment">% this will explode for &gt; some small number of frames... massive memory hog</span>
1987             nf = size(dv,2); <span class="comment">% number of frames</span>
1988             JtWJ = kron(eye(nf),J'*W*J);
1989             RtR = kron(hpt2LLt,hps2RtR);
1990             JtW = kron(eye(nf),J'*W);
1991             <span class="comment">% the actual update</span>
1992             <span class="comment">%dx = -(JtWJ + RtR)\(JtW*dv(:) + RtR*de(:)); % LU/Cholesky</span>
1993             dx = -<a href="../../../eidors/algorithms/left_divide.html" class="code" title="function [V] = left_divide(E,I,tol,~,V)">left_divide</a>( (JtWJ + RtR), (JtW*dv(:) + RtR*de(:)) ); <span class="comment">% LU/Cholesky</span>
1994             <span class="comment">% put back: one column per frame</span>
1995             dx = reshape(dx,length(dx)/nf,nf);
1996          <span class="keyword">else</span>
1997             <span class="comment">%dx = -(J'*W*J + hps2RtR)\(J'*W*dv + hps2RtR*de); % LU/Cholesky</span>
1998             dx = -<a href="../../../eidors/algorithms/left_divide.html" class="code" title="function [V] = left_divide(E,I,tol,~,V)">left_divide</a>( (J'*W*J + hps2RtR), (J'*W*dv + hps2RtR*de) ); <span class="comment">% LU/Cholesky</span>
1999          <span class="keyword">end</span>
2000       <span class="keyword">catch</span> ME <span class="comment">% boom</span>
2001          fprintf(<span class="string">'      Cholesky failed: '</span>);
2002          disp(ME.message)
2003          fprintf(<span class="string">'      try opt.update_method = ''pcg'' on future runs\n'</span>);
2004          opt.update_method = <span class="string">'pcg'</span>;
2005       <span class="keyword">end</span>
2006    <span class="keyword">end</span>
2007    <span class="keyword">if</span> strcmp(opt.update_method, <span class="string">'pcg'</span>)
2008       tol = 1e-6; <span class="comment">% default 1e-6</span>
2009       maxit = []; <span class="comment">% default [] --&gt; min(n,20)</span>
2010       M = []; <span class="comment">% default [] --&gt; no preconditioner</span>
2011       x0 = []; <span class="comment">% default [] --&gt; zeros(n,1)</span>
2012 
2013       <span class="comment">% try Preconditioned Conjugate Gradient: A x = b, solve for x</span>
2014       <span class="comment">% avoids J'*J for n x m matrix with large number of m cols --&gt; J'*J becomes an m x m dense matrix</span>
2015       nm = size(de,1); nf = size(de,2);
2016       X = @(x) reshape(x,nm,nf); <span class="comment">% undo vec() operation</span>
2017 
2018       LHS = @(X) (J'*(W*(J*X)) + hps2RtR*(X*hpt2LLt));
2019       RHS = -(J'*(W*dv) + hps2RtR*(de*hpt2LLt));
2020 
2021       LHSv = @(x) reshape(LHS(X(x)),nm*nf,1); <span class="comment">% vec() operation</span>
2022       RHSv = reshape(RHS,nm*nf,1);
2023 
2024       tol=100*eps*size(J,2)^2; <span class="comment">% rough estimate based on multiply-accumulates</span>
2025 <span class="comment">%      maxit = 10;</span>
2026 
2027       [dx, flag, relres, iter, resvec] = pcg(LHSv, RHSv, tol, maxit, M', M', x0);
2028       dx = X(dx);
2029       <span class="comment">% TODO if verbose...</span>
2030       <span class="keyword">switch</span> flag
2031          <span class="keyword">case</span> 0
2032             <span class="keyword">if</span> opt.verbose &gt; 1
2033                fprintf(<span class="string">'      PCG: relres=%g &lt; tol=%g @ iter#%d\n'</span>,relres,tol,iter);
2034             <span class="keyword">end</span>
2035          <span class="keyword">case</span> 1
2036             <span class="keyword">if</span> opt.verbose &gt; 1
2037                fprintf(<span class="string">'      PCG: relres=%g &gt; tol=%g @ iter#%d (max#%d) [max iter]\n'</span>,relres,tol,iter,maxit);
2038             <span class="keyword">end</span>
2039          <span class="keyword">case</span> 2
2040             error(<span class="string">'error: PCG ill-conditioned preconditioner M'</span>);
2041          <span class="keyword">case</span> 3
2042             <span class="keyword">if</span> opt.verbose &gt; 1
2043                fprintf(<span class="string">'      PCG: relres=%g &gt; tol=%g @ iter#%d (max#%d) [stagnated]\n'</span>,relres,tol,iter,maxit);
2044             <span class="keyword">end</span>
2045          <span class="keyword">case</span> 4
2046             error(<span class="string">'error: PCG a scalar quantity became too large or small to continue'</span>);
2047          <span class="keyword">otherwise</span>
2048             error(sprintf(<span class="string">'error: PCG unrecognized flag=%d'</span>,flag));
2049       <span class="keyword">end</span>
2050 <span class="comment">% NOTE PCG is still a work in progress and generally problem specific</span>
2051 <span class="comment">%      % plot convergence for pcg()</span>
2052 <span class="comment">%      clf;</span>
2053 <span class="comment">%         xlabel('iteration #');</span>
2054 <span class="comment">%         ylabel('relative residual');</span>
2055 <span class="comment">%         xx = 0:length(resvec)-1;</span>
2056 <span class="comment">%         semilogy(xx,resvec/norm(RHS),'b.');</span>
2057 <span class="comment">%         hold on;</span>
2058 <span class="comment">%         legend('no preconditioner');</span>
2059 <span class="comment">%hold on</span>
2060 <span class="comment">%% sparsity strategies: www.cerfacs.fr/algor/reports/Dissertations/TH_PA_02_48.pdf</span>
2061 <span class="comment">%sJ = J; sJ(J/max(J(:)) &gt; 0.005) = 0; sJ=sparse(sJ); % sparsify J</span>
2062 <span class="comment">%M = ichol(sJ'*W*sJ + hps2RtR + speye(length(J)));</span>
2063 <span class="comment">%      [dx, flag, relres, iter, resvec] = pcg(LHS, RHS, tol, maxit, M);</span>
2064 <span class="comment">%         semilogy(xx,resvec/norm(RHS),'r.');</span>
2065 <span class="comment">%         legend('no P', 'IC(sp(J'')*W*sp(J) + hps2RtR)');</span>
2066 <span class="comment">%</span>
2067 <span class="comment">%</span>
2068 <span class="comment">%clf; Jj=J(:,1:800); imagesc(Jj'*Jj);</span>
2069 
2070       <span class="comment">% compare with gmres, bicgstab, lsqr</span>
2071       <span class="comment">% try preconditioners ilu, ichol (incomplete LU or Cholesky decomp.)</span>
2072 
2073       <span class="comment">%rethrow(ME); % we assume this is an 'excessive memory requested' failure</span>
2074    <span class="keyword">end</span>
2075 
2076 <span class="comment">% for each argument, returns 1 if the function depends on it, 0 otherwise</span>
2077 <span class="comment">% 'zero' arguments do not need to be calculated since they don't get used</span>
2078 <a name="_sub40" href="#_subfunctions" class="code">function args = function_depends_upon(func, argn)</a>
2079    <span class="comment">% build function call</span>
2080    str = sprintf(<span class="string">'%s('</span>,func2str(func));
2081    args = zeros(argn,1);
2082    <span class="keyword">for</span> i = 1:argn-1
2083       str = [str sprintf(<span class="string">'a(%d),'</span>,i)];
2084    <span class="keyword">end</span>
2085    str = [str sprintf(<span class="string">'a(%d))'</span>,argn)];
2086    <span class="comment">% baseline</span>
2087    a = ones(argn,1)*2;
2088    x = eval(str);
2089    <span class="comment">% now check for a difference at each argument</span>
2090    <span class="keyword">for</span> i = 1:argn
2091       a = ones(argn,1)*2;
2092       a(i) = 0;
2093       y = eval(str);
2094       <span class="keyword">if</span> any(x ~= y)
2095          args(i) = 1;
2096       <span class="keyword">end</span>
2097    <span class="keyword">end</span>
2098 
2099 <span class="comment">% this function just passes data from its input to its output</span>
2100 <a name="_sub41" href="#_subfunctions" class="code">function out = null_func(in, varargin);</a>
2101    out = in;
2102 
2103 <span class="comment">% this function always returns one</span>
2104 <a name="_sub42" href="#_subfunctions" class="code">function [out, x, y, z] = ret1_func(varargin);</a>
2105    out = 1;
2106    x = [];
2107    y = [];
2108    z = [];
2109 
2110 <span class="comment">% if required, expand the coarse-to-fine matrix to cover the background of the image</span>
2111 <span class="comment">% this is removed at the end of the iterations</span>
2112 <a name="_sub43" href="#_subfunctions" class="code">function [inv_model, opt] = append_c2f_background(inv_model, opt)</a>
2113     <span class="comment">% either there is already a background</span>
2114     <span class="comment">% or none is required --&gt; -1 means we go to work building one</span>
2115     <span class="keyword">if</span> opt.c2f_background &gt;= 0
2116       <span class="keyword">return</span>
2117     <span class="keyword">end</span>
2118     <span class="comment">% check that all elements get assigned a conductivity</span>
2119     <span class="comment">% through the c2f conversion</span>
2120     c2f = inv_model.fwd_model.coarse2fine; <span class="comment">% coarse-to-fine mesh mapping</span>
2121     nf = size(inv_model.fwd_model.elems,1); <span class="comment">% number of fine elements</span>
2122     nc = size(c2f,2); <span class="comment">% number of coarse elements</span>
2123     <span class="comment">% ... each element of fel aught to sum to '1' since the</span>
2124     <span class="comment">% elem_data is being assigned from a continuous unit</span>
2125     <span class="comment">% surface value</span>
2126     <span class="comment">% now, find any fine elements that are not fully</span>
2127     <span class="comment">% mapped between the two meshes (&lt;1) w/in a tolerance</span>
2128     <span class="comment">% related to the number of additions in the summation</span>
2129     fel = sum(c2f,2); <span class="comment">% collapse mapping onto the fwd_model elements</span>
2130     n = find(fel &lt; 1 - (1e3+nc)*eps);
2131     <span class="comment">% ... 1e3 is a fudge factor since we don't care too much</span>
2132     <span class="comment">%     about small area mapping errors</span>
2133     <span class="comment">% if we do have some unassigned elements,</span>
2134     <span class="comment">% expand c2f and add a background element to the 'elem_data'</span>
2135     <span class="keyword">if</span> length(n) ~= 0
2136       <span class="keyword">if</span>(opt.verbose &gt; 1)
2137         fprintf(<span class="string">'  c2f: adding background conductivity to %d\n    fwd_model elements not covered by rec_model\n'</span>, length(n));
2138       <span class="keyword">end</span>
2139       c2f(n,nc+1) = 1 - fel(n);
2140       inv_model.fwd_model.coarse2fine = c2f;
2141       opt.c2f_background = nc+1;
2142       <span class="keyword">if</span> opt.c2f_background_fixed
2143          <span class="comment">% TODO assumes conductivity/resistivity is the *first* parameterization</span>
2144          opt.elem_fixed(end+1) = nc+1;
2145       <span class="keyword">end</span>
2146     <span class="keyword">end</span>
2147     <span class="comment">% TODO assumes conductivity/resistivity is the *first* parameterization</span>
2148     opt.elem_len(1) = {size(c2f,2)}; <span class="comment">% elem_len +1</span>
2149 
2150 <a name="_sub44" href="#_subfunctions" class="code">function [img, opt] = strip_c2f_background(img, opt, indent)</a>
2151     <span class="keyword">if</span> nargin &lt; 3
2152        indent = <span class="string">''</span>;
2153     <span class="keyword">end</span>
2154     <span class="comment">% nothing to do?</span>
2155     <span class="keyword">if</span> opt.c2f_background &lt;= 0
2156       <span class="keyword">return</span>;
2157     <span class="keyword">end</span>
2158 
2159     <span class="comment">% if there are multiple 'params' (parametrizations), we assume its the first</span>
2160     <span class="comment">% TODO -- this isn't a great assumption but it'll work for now,</span>
2161     <span class="comment">%         we should add a better (more general) mechanism</span>
2162     in = img.current_params;
2163     out = opt.elem_output;
2164     <span class="keyword">if</span> iscell(in)
2165        in = in{1};
2166     <span class="keyword">end</span>
2167     <span class="keyword">if</span> iscell(out)
2168        out = out{1};
2169     <span class="keyword">end</span>
2170 
2171     <span class="comment">% go about cleaning up the background</span>
2172     e = opt.c2f_background;
2173     <span class="comment">% take backgtround elements and convert to output</span>
2174     <span class="comment">% 'params' (resistivity, etc)</span>
2175     bg = <a href="#_sub49" class="code" title="subfunction x = map_data(x, in, out)">map_data</a>(img.elem_data(e), in, out);
2176     img.elem_data_background = bg;
2177     <span class="comment">% remove elements from elem_data &amp; c2f</span>
2178     img.elem_data(e) = [];
2179     img.fwd_model.coarse2fine(:,e) = [];
2180     <span class="comment">% remove our element from the lists</span>
2181     opt.c2f_background = 0;
2182     ri = find(opt.elem_fixed == e);
2183     opt.elem_fixed(ri) = [];
2184     <span class="keyword">if</span> isfield(img, <span class="string">'params_sel'</span>)
2185        <span class="keyword">for</span> i = 1:length(img.params_sel)
2186           t = img.params_sel{i};
2187           ti = find(t == e);
2188           t(ti) = []; <span class="comment">% rm 'e' from the list of params_sel</span>
2189           ti = find(t &gt; e);
2190           t(ti) = t(ti)-1; <span class="comment">% down-count element indices greater than our deleted one</span>
2191           img.params_sel{i} = t;
2192        <span class="keyword">end</span>
2193     <span class="keyword">end</span>
2194 
2195     <span class="comment">% show what we got for a background value</span>
2196     <span class="keyword">if</span>(opt.verbose &gt; 1)
2197        bg = img.elem_data_background;
2198        bg = <a href="#_sub49" class="code" title="subfunction x = map_data(x, in, out)">map_data</a>(bg, in, <span class="string">'resistivity'</span>);
2199        fprintf(<span class="string">'%s  background conductivity: %0.1f Ohm.m\n'</span>, indent, bg);
2200     <span class="keyword">end</span>
2201 
2202 <a name="_sub45" href="#_subfunctions" class="code">function b = has_params(s)</a>
2203 b = false;
2204 <span class="keyword">if</span> isstruct(s)
2205    b = any(ismember(fieldnames(s),<a href="../../../eidors/models/supported_params.html" class="code" title="function list = supported_params">supported_params</a>));
2206 <span class="keyword">end</span>
2207 
2208 <span class="comment">% wrapper function for to_base_types</span>
2209 <a name="_sub46" href="#_subfunctions" class="code">function out = map_img_base_types(img)</a>
2210   out = <a href="#_sub47" class="code" title="subfunction type = to_base_types(type)">to_base_types</a>(img.current_params);
2211 
2212 <span class="comment">% convert from know types to their base types</span>
2213 <span class="comment">% A helper function for getting to a basic paramterization</span>
2214 <span class="comment">% prior to any required scaling, etc.</span>
2215 <a name="_sub47" href="#_subfunctions" class="code">function type = to_base_types(type)</a>
2216   <span class="keyword">if</span> ~iscell(type)
2217      type = {type};
2218   <span class="keyword">end</span>
2219   <span class="keyword">for</span> i = 1:length(type);
2220      type(i) = {strrep(type{i}, <span class="string">'log_'</span>, <span class="string">''</span>)};
2221      type(i) = {strrep(type{i}, <span class="string">'log10_'</span>, <span class="string">''</span>)};
2222      type(i) = {strrep(type{i}, <span class="string">'resistivity'</span>, <span class="string">'conductivity'</span>)};
2223      type(i) = {strrep(type{i}, <span class="string">'apparent_resistivity'</span>, <span class="string">'voltage'</span>)};
2224   <span class="keyword">end</span>
2225 
2226 <a name="_sub48" href="#_subfunctions" class="code">function img = map_img(img, out);</a>
2227    <a href="#_sub27" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(img.elem_data, <span class="string">'img-pre'</span>);
2228    <span class="keyword">try</span>
2229        in = img.current_params;
2230    <span class="keyword">catch</span>
2231        in = {<span class="string">'conductivity'</span>};
2232    <span class="keyword">end</span>
2233    <span class="comment">% make cell array of strings</span>
2234    <span class="keyword">if</span> ischar(in)
2235       in = {in};
2236       img.current_params = in;
2237    <span class="keyword">end</span>
2238    <span class="keyword">if</span> ischar(out)
2239       out = {out};
2240    <span class="keyword">end</span>
2241 
2242    <span class="comment">% if we have mixed data, check that we have a selector to differentiate between them</span>
2243    <span class="keyword">if</span> ~isfield(img, <span class="string">'params_sel'</span>)
2244       <span class="keyword">if</span> length(in(:)) == 1
2245          img.params_sel = {1:size(img.elem_data,1)};
2246       <span class="keyword">else</span>
2247          error(<span class="string">'found multiple parametrizations (params) but no params_sel cell array in img'</span>);
2248       <span class="keyword">end</span>
2249    <span class="keyword">end</span>
2250 
2251    <span class="comment">% create data?! we don't know how</span>
2252    <span class="keyword">if</span> length(out(:)) &gt; length(in(:))
2253       error(<span class="string">'missing data (more out types than in types)'</span>);
2254    <span class="keyword">elseif</span> length(out(:)) &lt; length(in(:))
2255       <span class="comment">% delete data: we can do that</span>
2256       <span class="comment">% TODO we could genearlize this into a reorganizing tool BUT we're just</span>
2257       <span class="comment">% interested in something that works, so if we have more than one out(:),</span>
2258       <span class="comment">% we don't know what to do currently and error out</span>
2259       <span class="keyword">if</span> length(out(:)) ~= 1
2260          error(<span class="string">'map_img can convert ALL parameters or select a SINGLE output type from multiple input types'</span>);
2261       <span class="keyword">end</span>
2262       inm  = <a href="#_sub47" class="code" title="subfunction type = to_base_types(type)">to_base_types</a>(in);
2263       outm = <a href="#_sub47" class="code" title="subfunction type = to_base_types(type)">to_base_types</a>(out);
2264       del = sort(find(~strcmp(outm(1), inm(:))), <span class="string">'descend'</span>); <span class="comment">% we do this loop backwards in the hopes of avoiding shuffling data that is about to be deleted</span>
2265       <span class="keyword">if</span> length(del)+1 ~= length(in)
2266          error(<span class="string">'Confused about what to remove from the img. You''ll need to sort the parametrizations out yourself when removing data.'</span>);
2267       <span class="keyword">end</span>
2268       <span class="keyword">for</span> i = del(:)' <span class="comment">% delete each of the extra indices</span>
2269          ndel = length(img.params_sel{i}); <span class="comment">% number of deleted elements</span>
2270          <span class="keyword">for</span> j = i+1:length(img.params_sel)
2271             img.params_sel{j} = img.params_sel{j} - ndel;
2272          <span class="keyword">end</span>
2273          img.elem_data(img.params_sel{i}) = []; <span class="comment">% rm elem_data</span>
2274          img.params_sel(i) = []; <span class="comment">% rm params_sel</span>
2275          img.current_params(i) = []; <span class="comment">% rm current_params</span>
2276       <span class="keyword">end</span>
2277       in = img.current_params;
2278    <span class="keyword">end</span>
2279 
2280    <span class="comment">% the sizes now match, we can do the mapping</span>
2281    <span class="keyword">for</span> i = 1:length(out(:))
2282       <span class="comment">% map the data</span>
2283       x = img.elem_data(img.params_sel{i});
2284       x = <a href="#_sub49" class="code" title="subfunction x = map_data(x, in, out)">map_data</a>(x, in{i}, out{i});
2285       img.elem_data(img.params_sel{i}) = x;
2286       img.current_params{i} = out{i};
2287    <span class="keyword">end</span>
2288    <a href="#_sub27" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(img.elem_data, <span class="string">'img-post'</span>);
2289 
2290    <span class="comment">% clean up params_sel/current_params if we only have one parametrization</span>
2291    <span class="keyword">if</span> length(img.current_params(:)) == 1
2292       img.current_params = img.current_params{1};
2293       img = rmfield(img, <span class="string">'params_sel'</span>); <span class="comment">% unnecessary since we know its all elem_data</span>
2294    <span class="keyword">end</span>
2295 
2296 <a name="_sub49" href="#_subfunctions" class="code">function x = map_data(x, in, out)</a>
2297    <span class="comment">% check that in and out are single strings, not lists of strings</span>
2298    <span class="keyword">if</span> ~ischar(in)
2299       <span class="keyword">if</span> iscell(in) &amp;&amp; (length(in(:)) == 1)
2300          in = in{1};
2301       <span class="keyword">else</span>
2302          error(<span class="string">'expecting single string for map_data() &quot;in&quot; type'</span>);
2303       <span class="keyword">end</span>
2304    <span class="keyword">end</span>
2305    <span class="keyword">if</span> ~ischar(out)
2306       <span class="keyword">if</span> iscell(out) &amp;&amp; (length(out(:)) == 1)
2307          out = out{1};
2308       <span class="keyword">else</span>
2309          error(<span class="string">'expecting single string for map_data() &quot;out&quot; type'</span>);
2310       <span class="keyword">end</span>
2311    <span class="keyword">end</span>
2312 
2313    <span class="comment">% quit early if there is nothing to do</span>
2314    <span class="keyword">if</span> strcmp(in, out) <span class="comment">% in == out</span>
2315       <span class="keyword">return</span>; <span class="comment">% do nothing</span>
2316    <span class="keyword">end</span>
2317 
2318    <span class="comment">% resistivity to conductivity conversion</span>
2319    <span class="comment">% we can't get here if in == out</span>
2320    <span class="comment">% we've already checked for log convserions on input or output</span>
2321    <span class="keyword">if</span> any(strcmp(in,  {<span class="string">'resistivity'</span>, <span class="string">'conductivity'</span>})) &amp;&amp; <span class="keyword">...</span>
2322       any(strcmp(out, {<span class="string">'resistivity'</span>, <span class="string">'conductivity'</span>}))
2323       x = 1./x; <span class="comment">% conductivity &lt;-&gt; resistivity</span>
2324    <span class="comment">% log conversion</span>
2325    <span class="keyword">elseif</span> any(strcmp({in(1:3), out(1:3)}, <span class="string">'log'</span>))
2326       <span class="comment">% log_10 x -&gt; x</span>
2327       <span class="keyword">if</span> strcmp(in(1:6), <span class="string">'log10_'</span>)
2328          <span class="keyword">if</span> any(x &gt;= log10(realmax)-eps) warning(<span class="string">'loss of precision -&gt; inf'</span>); <span class="keyword">end</span>
2329          x = <a href="#_sub49" class="code" title="subfunction x = map_data(x, in, out)">map_data</a>(10.^x, in(7:end), out);
2330       <span class="comment">% ln x -&gt; x</span>
2331       <span class="keyword">elseif</span> strcmp(in(1:4), <span class="string">'log_'</span>)
2332          <span class="keyword">if</span> any(x &gt;= log(realmax)-eps) warning(<span class="string">'loss of precision -&gt; inf'</span>); <span class="keyword">end</span>
2333          x = <a href="#_sub49" class="code" title="subfunction x = map_data(x, in, out)">map_data</a>(exp(x), in(5:end), out);
2334       <span class="comment">% x -&gt; log_10 x</span>
2335       <span class="keyword">elseif</span> strcmp(out(1:6), <span class="string">'log10_'</span>)
2336          <span class="keyword">if</span> any(x &lt;= 0 + eps) warning(<span class="string">'loss of precision -&gt; -inf'</span>); <span class="keyword">end</span>
2337          x = log10(<a href="#_sub49" class="code" title="subfunction x = map_data(x, in, out)">map_data</a>(x, in, out(7:end)));
2338       <span class="comment">% x -&gt; ln x</span>
2339       <span class="keyword">elseif</span> strcmp(out(1:4), <span class="string">'log_'</span>)
2340          <span class="keyword">if</span> any(x &lt;= 0 + eps) warning(<span class="string">'loss of precision -&gt; -inf'</span>); <span class="keyword">end</span>
2341          x = log(<a href="#_sub49" class="code" title="subfunction x = map_data(x, in, out)">map_data</a>(x, in, out(5:end)));
2342       <span class="keyword">else</span>
2343          error(sprintf(<span class="string">'unknown conversion (log conversion?) %s - &gt; %s'</span>, in, out));
2344       <span class="keyword">end</span>
2345    <span class="keyword">else</span>
2346       error(<span class="string">'unknown conversion %s -&gt; %s'</span>, in, out);
2347    <span class="keyword">end</span>
2348    x(x == +inf) = +realmax;
2349    x(x == -inf) = -realmax;
2350    <a href="#_sub27" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(x, <span class="string">'map_data-post'</span>);
2351 
2352 <a name="_sub50" href="#_subfunctions" class="code">function b = map_meas(b, N, in, out)</a>
2353    <a href="#_sub27" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(b, <span class="string">'map_meas-pre'</span>);
2354    <span class="keyword">if</span> strcmp(in, out) <span class="comment">% in == out</span>
2355       <span class="keyword">return</span>; <span class="comment">% do nothing</span>
2356    <span class="keyword">end</span>
2357 
2358    <span class="comment">% resistivity to conductivity conversion</span>
2359    <span class="comment">% we can't get here if in == out</span>
2360    <span class="keyword">if</span>     strcmp(in, <span class="string">'voltage'</span>) &amp;&amp; strcmp(out, <span class="string">'apparent_resistivity'</span>)
2361       <span class="keyword">if</span> N == 1
2362          error(<span class="string">'missing apparent resistivity conversion factor N'</span>);
2363       <span class="keyword">end</span>
2364       b = N * b; <span class="comment">% voltage -&gt; apparent resistivity</span>
2365    <span class="keyword">elseif</span> strcmp(in, <span class="string">'apparent_resistivity'</span>) &amp;&amp; strcmp(out, <span class="string">'voltage'</span>)
2366       <span class="keyword">if</span> N == 1
2367          error(<span class="string">'missing apparent resistivity conversion factor N'</span>);
2368       <span class="keyword">end</span>
2369       b = N \ b; <span class="comment">% apparent resistivity -&gt; voltage</span>
2370    <span class="comment">% log conversion</span>
2371    <span class="keyword">elseif</span> any(strcmp({in(1:3), out(1:3)}, <span class="string">'log'</span>))
2372       <span class="comment">% log_10 b -&gt; b</span>
2373       <span class="keyword">if</span> strcmp(in(1:6), <span class="string">'log10_'</span>)
2374          <span class="keyword">if</span> any(b &gt; log10(realmax)-eps) warning(<span class="string">'loss of precision -&gt; inf'</span>); <span class="keyword">end</span>
2375          b = <a href="#_sub50" class="code" title="subfunction b = map_meas(b, N, in, out)">map_meas</a>(10.^b, N, in(7:end), out);
2376       <span class="comment">% ln b -&gt; b</span>
2377       <span class="keyword">elseif</span> strcmp(in(1:4), <span class="string">'log_'</span>)
2378          <span class="keyword">if</span> any(b &gt; log(realmax)-eps) warning(<span class="string">'loss of precision -&gt; inf'</span>); <span class="keyword">end</span>
2379          b = <a href="#_sub50" class="code" title="subfunction b = map_meas(b, N, in, out)">map_meas</a>(exp(b), N, in(5:end), out);
2380       <span class="comment">% b -&gt; log_10 b</span>
2381       <span class="keyword">elseif</span> strcmp(out(1:6), <span class="string">'log10_'</span>)
2382          <span class="keyword">if</span> any(b &lt;= 0+eps) warning(<span class="string">'loss of precision -&gt; -inf'</span>); <span class="keyword">end</span>
2383          b = log10(<a href="#_sub50" class="code" title="subfunction b = map_meas(b, N, in, out)">map_meas</a>(b, N, in, out(7:end)));
2384       <span class="comment">% b -&gt; ln b</span>
2385       <span class="keyword">elseif</span> strcmp(out(1:4), <span class="string">'log_'</span>)
2386          <span class="keyword">if</span> any(b &lt;= 0+eps) warning(<span class="string">'loss of precision -&gt; -inf'</span>); <span class="keyword">end</span>
2387          b = log(<a href="#_sub50" class="code" title="subfunction b = map_meas(b, N, in, out)">map_meas</a>(b, N, in, out(5:end)));
2388       <span class="keyword">else</span>
2389          error(sprintf(<span class="string">'unknown conversion (log conversion?) %s - &gt; %s'</span>, in, out));
2390       <span class="keyword">end</span>
2391    <span class="keyword">else</span>
2392       error(<span class="string">'unknown conversion %s -&gt; %s'</span>, in, out);
2393    <span class="keyword">end</span>
2394    <a href="#_sub27" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(b, <span class="string">'map_meas-post'</span>);
2395 
2396 <a name="_sub51" href="#_subfunctions" class="code">function x=range(y)</a>
2397 x=max(y)-min(y);
2398 
2399 <a name="_sub52" href="#_subfunctions" class="code">function pass=do_unit_test(solver)</a>
2400    <span class="keyword">if</span> nargin == 0
2401       solver = <span class="string">'inv_solve_core'</span>;
2402       test = <span class="string">'all'</span>
2403    <span class="keyword">elseif</span> ((length(solver) &lt; 9) || ~strcmp(solver(1:9),<span class="string">'inv_solve'</span>))
2404       test = solver;
2405       solver = <span class="string">'inv_solve_core'</span>;
2406    <span class="keyword">else</span>
2407       test = <span class="string">'all'</span>
2408    <span class="keyword">end</span>
2409    <span class="keyword">switch</span>(test)
2410       <span class="keyword">case</span> <span class="string">'all'</span>
2411          <a href="#_sub55" class="code" title="subfunction do_unit_test_sub">do_unit_test_sub</a>;
2412          <a href="#_sub54" class="code" title="subfunction do_unit_test_diff()">do_unit_test_diff</a>;
2413          <a href="#_sub58" class="code" title="subfunction do_unit_test_rec1(solver)">do_unit_test_rec1</a>(solver);
2414          <a href="#_sub62" class="code" title="subfunction do_unit_test_rec2(solver)">do_unit_test_rec2</a>(solver);
2415          <a href="#_sub59" class="code" title="subfunction do_unit_test_rec_mv(solver)">do_unit_test_rec_mv</a>(solver);
2416          <a href="#_sub63" class="code" title="subfunction do_unit_test_img0_bg()">do_unit_test_img0_bg</a>();
2417          <a href="#_sub64" class="code" title="subfunction do_unit_test_diffseq(solver)">do_unit_test_diffseq</a>(solver);
2418          <a href="#_sub65" class="code" title="subfunction do_unit_test_absseq(solver)">do_unit_test_absseq</a>(solver);
2419       <span class="keyword">case</span> <span class="string">'sub'</span>
2420          <a href="#_sub55" class="code" title="subfunction do_unit_test_sub">do_unit_test_sub</a>;
2421       <span class="keyword">case</span> <span class="string">'diff'</span>
2422          <a href="#_sub54" class="code" title="subfunction do_unit_test_diff()">do_unit_test_diff</a>;
2423       <span class="keyword">case</span> <span class="string">'rec1'</span>
2424          <a href="#_sub58" class="code" title="subfunction do_unit_test_rec1(solver)">do_unit_test_rec1</a>(solver);
2425       <span class="keyword">case</span> <span class="string">'rec2'</span>
2426          <a href="#_sub62" class="code" title="subfunction do_unit_test_rec2(solver)">do_unit_test_rec2</a>(solver);
2427       <span class="keyword">case</span> <span class="string">'rec_mv'</span>
2428          <a href="#_sub59" class="code" title="subfunction do_unit_test_rec_mv(solver)">do_unit_test_rec_mv</a>(solver);
2429       <span class="keyword">case</span> <span class="string">'diffseq'</span>
2430          <a href="#_sub64" class="code" title="subfunction do_unit_test_diffseq(solver)">do_unit_test_diffseq</a>(solver);
2431       <span class="keyword">case</span> <span class="string">'absseq'</span>
2432          <a href="#_sub65" class="code" title="subfunction do_unit_test_absseq(solver)">do_unit_test_absseq</a>(solver);
2433       <span class="keyword">otherwise</span>
2434          error([<span class="string">'unrecognized solver or tests: '</span> test]);
2435    <span class="keyword">end</span>
2436 
2437 <a name="_sub53" href="#_subfunctions" class="code">function [imdl, vh, imgi, vi] = unit_test_imdl()</a>
2438    imdl = <a href="../../../eidors/models/mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>(<span class="string">'h22e'</span>,32);
2439    imdl.solve = <span class="string">'inv_solve_core'</span>;
2440    imdl.inv_solve_core.max_iterations = 1; <span class="comment">% see that we get the same as the GN 1-step difference soln</span>
2441    imdl.inv_solve_core.verbose = 0;
2442    imdl.reconst_type = <span class="string">'difference'</span>;
2443    imgh = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(imdl,1);
2444    vh = <a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(imgh);
2445 
2446    <span class="keyword">if</span> nargout &gt; 2
2447       imgi = imgh;
2448       ctrs = <a href="../../../eidors/models/interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>(imdl.fwd_model);
2449       x = ctrs(:,1);
2450       y = ctrs(:,2);
2451       r1 = sqrt((x+15).^2 + (y+25).^2);
2452       r2 = sqrt((x-85).^2 + (y+65).^2);
2453       imgi.elem_data(r1&lt;25)= 1/2;
2454       imgi.elem_data(r2&lt;30)= 2;
2455       clf; <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgi,1);
2456       vi = <a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(imgi);
2457    <span class="keyword">end</span>
2458 
2459 <a name="_sub54" href="#_subfunctions" class="code">function do_unit_test_diff()</a>
2460    [imdl, vh, imgi, vi] = <a href="#_sub53" class="code" title="subfunction [imdl, vh, imgi, vi] = unit_test_imdl()">unit_test_imdl</a>();
2461 
2462    imdl.reconst_type = <span class="string">'absolute'</span>;
2463    imdl.inv_solve_core.line_search_func = @<a href="#_sub42" class="code" title="subfunction [out, x, y, z] = ret1_func(varargin);">ret1_func</a>;
2464    img_abs = <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl,vi);
2465    imdl.reconst_type = <span class="string">'difference'</span>;
2466    img_itr = <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl,vh,vi);
2467    imdl.inv_solve_core.max_iterations = 1; <span class="comment">% see that we get the same as the GN 1-step difference soln</span>
2468    img_it1 = <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl,vh,vi);
2469    imdl.solve = <span class="string">'inv_solve_diff_GN_one_step'</span>;
2470    img_gn1 = <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl,vh,vi);
2471    clf; subplot(223); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img_it1,1); title(<span class="string">'GN 1-iter'</span>);
2472         subplot(224); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img_gn1,1); title(<span class="string">'GN 1-step'</span>);
2473         subplot(221); h=<a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgi,1);  title(<span class="string">'fwd model'</span>); set(h,<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>);
2474         subplot(222); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img_itr,1); title(<span class="string">'GN 10-iter'</span>);
2475         subplot(222); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img_abs,1); title(<span class="string">'GN abs 10-iter'</span>);
2476    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'core (1-step) vs. diff_GN_one_step'</span>, img_it1.elem_data, img_gn1.elem_data, eps*15);
2477    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'core (1-step) vs. core (N-step)   '</span>, img_it1.elem_data, img_itr.elem_data, eps*2);
2478    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'core (N-step) vs. abs  (N-step)   '</span>, img_it1.elem_data, img_abs.elem_data-1, eps);
2479 
2480 <span class="comment">% test sub-functions</span>
2481 <span class="comment">% map_meas, map_data</span>
2482 <span class="comment">% jacobian scalings</span>
2483 <a name="_sub55" href="#_subfunctions" class="code">function do_unit_test_sub</a>
2484 d = 1;
2485 <span class="keyword">while</span> d ~= 1 &amp; d ~= 0
2486   d = rand(1);
2487 <span class="keyword">end</span>
2488 disp(<span class="string">'TEST: map_data()'</span>);
2489 elem_types = {<span class="string">'conductivity'</span>, <span class="string">'log_conductivity'</span>, <span class="string">'log10_conductivity'</span>, <span class="keyword">...</span>
2490               <span class="string">'resistivity'</span>,  <span class="string">'log_resistivity'</span>,  <span class="string">'log10_resistivity'</span>};
2491 expected = [d         log(d)         log10(d)      1./d      log(1./d)      log10(1./d); <span class="keyword">...</span>
2492             exp(d)    d              log10(exp(d)) 1./exp(d) log(1./exp(d)) log10(1./exp(d)); <span class="keyword">...</span>
2493             10.^d     log(10.^d )    d             1./10.^d  log(1./10.^d ) log10(1./10.^d ); <span class="keyword">...</span>
2494             1./d      log(1./d  )    log10(1./d)   d         log(d)         log10(d); <span class="keyword">...</span>
2495             1./exp(d) log(1./exp(d)) log10(1./exp(d)) exp(d) d              log10(exp(d)); <span class="keyword">...</span>
2496             1./10.^d  log(1./10.^d)  log10(1./10.^d)  10.^d  log(10.^d)     d ];
2497 <span class="keyword">for</span> i = 1:length(elem_types)
2498   <span class="keyword">for</span> j = 1:length(elem_types)
2499     <a href="#_sub56" class="code" title="subfunction test_map_data(data, in, out, expected)">test_map_data</a>(d, elem_types{i}, elem_types{j}, expected(i,j));
2500   <span class="keyword">end</span>
2501 <span class="keyword">end</span>
2502 
2503 disp(<span class="string">'TEST: map_meas()'</span>);
2504 N = 1/15;
2505 Ninv = 1/N;
2506 <span class="comment">% function b = map_meas(b, N, in, out)</span>
2507 elem_types = {<span class="string">'voltage'</span>, <span class="string">'log_voltage'</span>, <span class="string">'log10_voltage'</span>, <span class="keyword">...</span>
2508               <span class="string">'apparent_resistivity'</span>,  <span class="string">'log_apparent_resistivity'</span>,  <span class="string">'log10_apparent_resistivity'</span>};
2509 expected = [d         log(d)         log10(d)      N*d      log(N*d)      log10(N*d); <span class="keyword">...</span>
2510             exp(d)    d              log10(exp(d)) N*exp(d) log(N*exp(d)) log10(N*exp(d)); <span class="keyword">...</span>
2511             10.^d     log(10.^d )    d             N*10.^d  log(N*10.^d ) log10(N*10.^d ); <span class="keyword">...</span>
2512             Ninv*d      log(Ninv*d  )    log10(Ninv*d)   d         log(d)         log10(d); <span class="keyword">...</span>
2513             Ninv*exp(d) log(Ninv*exp(d)) log10(Ninv*exp(d)) exp(d) d              log10(exp(d)); <span class="keyword">...</span>
2514             Ninv*10.^d  log(Ninv*10.^d)  log10(Ninv*10.^d)  10.^d  log(10.^d)     d ];
2515 <span class="keyword">for</span> i = 1:length(elem_types)
2516   <span class="keyword">for</span> j = 1:length(elem_types)
2517     <a href="#_sub57" class="code" title="subfunction test_map_meas(data, N, in, out, expected)">test_map_meas</a>(d, N, elem_types{i}, elem_types{j}, expected(i,j));
2518   <span class="keyword">end</span>
2519 <span class="keyword">end</span>
2520 
2521 disp(<span class="string">'TEST: Jacobian scaling'</span>);
2522 d = [d d]';
2523 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>( <span class="keyword">...</span>
2524    sprintf(<span class="string">'Jacobian scaling (%s)'</span>, <span class="string">'conductivity'</span>), <span class="keyword">...</span>
2525    <a href="#_sub42" class="code" title="subfunction [out, x, y, z] = ret1_func(varargin);">ret1_func</a>(d), 1);
2526 
2527 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>( <span class="keyword">...</span>
2528    sprintf(<span class="string">'Jacobian scaling (%s)'</span>, <span class="string">'log_conductivity'</span>), <span class="keyword">...</span>
2529    <a href="#_sub15" class="code" title="subfunction S = dx_dlogx(x);">dx_dlogx</a>(d), diag(d));
2530 
2531 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>( <span class="keyword">...</span>
2532    sprintf(<span class="string">'Jacobian scaling (%s)'</span>, <span class="string">'log10_conductivity'</span>), <span class="keyword">...</span>
2533    <a href="#_sub16" class="code" title="subfunction S = dx_dlog10x(x);">dx_dlog10x</a>(d), diag(d)*log(10));
2534 
2535 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>( <span class="keyword">...</span>
2536    sprintf(<span class="string">'Jacobian scaling (%s)'</span>, <span class="string">'resistivity'</span>), <span class="keyword">...</span>
2537    <a href="#_sub17" class="code" title="subfunction S = dx_dy(x);">dx_dy</a>(d), diag(-d.^2));
2538 
2539 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>( <span class="keyword">...</span>
2540    sprintf(<span class="string">'Jacobian scaling (%s)'</span>, <span class="string">'log_resistivity'</span>), <span class="keyword">...</span>
2541    <a href="#_sub18" class="code" title="subfunction S = dx_dlogy(x);">dx_dlogy</a>(d), diag(-d));
2542 
2543 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>( <span class="keyword">...</span>
2544    sprintf(<span class="string">'Jacobian scaling (%s)'</span>, <span class="string">'log10_resistivity'</span>), <span class="keyword">...</span>
2545    <a href="#_sub19" class="code" title="subfunction S = dx_dlog10y(x);">dx_dlog10y</a>(d), diag(-d)/log(10));
2546 
2547 
2548 <a name="_sub56" href="#_subfunctions" class="code">function test_map_data(data, in, out, expected)</a>
2549 <span class="comment">%fprintf('TEST: map_data(%s -&gt; %s)\n', in, out);</span>
2550    calc_val = <a href="#_sub49" class="code" title="subfunction x = map_data(x, in, out)">map_data</a>(data, in, out);
2551    str = sprintf(<span class="string">'map_data(%s -&gt; %s)'</span>, in, out);
2552    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(str, calc_val, expected)
2553 
2554 <a name="_sub57" href="#_subfunctions" class="code">function test_map_meas(data, N, in, out, expected)</a>
2555 <span class="comment">%fprintf('TEST: map_meas(%s -&gt; %s)\n', in, out);</span>
2556    calc_val = <a href="#_sub50" class="code" title="subfunction b = map_meas(b, N, in, out)">map_meas</a>(data, N, in, out);
2557    str = sprintf(<span class="string">'map_data(%s -&gt; %s)'</span>, in, out);
2558    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(str, calc_val, expected,100*eps)
2559 
2560 
2561 <span class="comment">% a couple easy reconstructions</span>
2562 <span class="comment">% check c2f, apparent_resistivity, log_conductivity, verbosity don't error out</span>
2563 <a name="_sub58" href="#_subfunctions" class="code">function do_unit_test_rec1(solver)</a>
2564 <span class="comment">% -------------</span>
2565 <span class="comment">% ADAPTED FROM</span>
2566 <span class="comment">% Create simulation data $Id: inv_solve_core.m 6503 2022-12-30 14:33:58Z aadler $</span>
2567 <span class="comment">%  http://eidors3d.sourceforge.net/tutorial/adv_image_reconst/basic_iterative.shtml</span>
2568 <span class="comment">% 3D Model</span>
2569 [imdl, vh, imgi, vi] = <a href="#_sub53" class="code" title="subfunction [imdl, vh, imgi, vi] = unit_test_imdl()">unit_test_imdl</a>();
2570 imdl.solve = solver;
2571 imdl.reconst_type = <span class="string">'absolute'</span>;
2572 imdl.inv_solve_core.prior_data = 1;
2573 imdl.inv_solve_core.elem_prior = <span class="string">'conductivity'</span>;
2574 imdl.inv_solve_core.elem_working = <span class="string">'log_conductivity'</span>;
2575 imdl.inv_solve_core.meas_working = <span class="string">'apparent_resistivity'</span>;
2576 imdl.inv_solve_core.calc_solution_error = 0;
2577 imdl.inv_solve_core.verbose = 0;
2578 
2579 imgp = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(imgi, <span class="string">'log10_conductivity'</span>);
2580 <span class="comment">% add noise</span>
2581 <span class="comment">%Add 30dB SNR noise to data</span>
2582 <span class="comment">%noise_level= std(vi.meas - vh.meas)/10^(30/20);</span>
2583 <span class="comment">%vi.meas = vi.meas + noise_level*randn(size(vi.meas));</span>
2584 <span class="comment">% Reconstruct Images</span>
2585 img1= <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vi);
2586 <span class="comment">% -------------</span>
2587 disp(<span class="string">'TEST: previous solved at default verbosity'</span>);
2588 disp(<span class="string">'TEST: now solve same at verbosity=0 --&gt; should be silent'</span>);
2589 imdl.inv_solve_core.verbose = 0;
2590 <span class="comment">%imdl.inv_solve_core.meas_working = 'apparent_resistivity';</span>
2591 img2= <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vi);
2592 <span class="comment">% -------------</span>
2593 imdl.inv_solve_core.elem_output = <span class="string">'log10_resistivity'</span>; <span class="comment">% resistivity output works</span>
2594 img3= <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vi);
2595 
2596 disp(<span class="string">'TEST: try coarse2fine mapping with background'</span>);
2597 ctrs= <a href="../../../eidors/models/interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>(imdl.rec_model);
2598 x= ctrs(:,1); y= ctrs(:,2);
2599 r=sqrt((x+5).^2 + (y+5).^2);
2600 imdl.rec_model.elems(x-y &gt; 300, :) = [];
2601 c2f = <a href="../../../eidors/models/mk_approx_c2f.html" class="code" title="function [mapping, outside] = mk_approx_c2f( f_mdl, c_mdl );">mk_approx_c2f</a>(imdl.fwd_model,imdl.rec_model);
2602 imdl.fwd_model.coarse2fine = c2f;
2603 <span class="comment">% solve</span>
2604 <span class="comment">%imdl.inv_solve_core.verbose = 10;</span>
2605 imdl.inv_solve_core.elem_output = <span class="string">'conductivity'</span>;
2606 img4= <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vi);
2607 
2608 clf; subplot(221); h=<a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgp,1); set(h,<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>); axis tight; title(<span class="string">'synthetic data, logC'</span>);
2609    subplot(222); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img1,1); axis tight; title(<span class="string">'#1 verbosity=default'</span>);
2610    subplot(223); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img2,1); axis tight; title(<span class="string">'#2 verbosity=0'</span>);
2611    subplot(223); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img3,1); axis tight; title(<span class="string">'#3 c2f + log10 resistivity out'</span>);
2612    subplot(224); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img4,1); axis tight; title(<span class="string">'#4 c2f cut'</span>);
2613    drawnow;
2614 d1 = img1.elem_data; d2 = img2.elem_data; d3 = img3.elem_data; d4 = img4.elem_data;
2615 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'img1 == img2'</span>, d1, d2, eps);
2616 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'img1 == img3'</span>, d1, 1./(10.^d3), eps);
2617 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'img1 == img4'</span>, (d1(x-y &lt;=300)-d4)./d4, 0, 0.05); <span class="comment">%  +-5% error</span>
2618 
2619 <span class="comment">%clf; subplot(211); plot((img3.elem_data - img1.elem_data)./img1.elem_data);</span>
2620 
2621 <span class="comment">% a couple easy reconstructions with movement or similar</span>
2622 <a name="_sub59" href="#_subfunctions" class="code">function do_unit_test_rec_mv(solver)</a>
2623 disp(<span class="string">'TEST: conductivity and movement --&gt; baseline conductivity only'</span>);
2624 <span class="comment">% -------------</span>
2625 <span class="comment">% ADAPTED FROM</span>
2626 <span class="comment">% Create simulation data $Id: inv_solve_core.m 6503 2022-12-30 14:33:58Z aadler $</span>
2627 <span class="comment">%  http://eidors3d.sourceforge.net/tutorial/adv_image_reconst/basic_iterative.shtml</span>
2628 <span class="comment">% 3D Model</span>
2629 imdl= <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'c2t4'</span>,16); <span class="comment">% 576 elements</span>
2630 ne = length(imdl.fwd_model.electrode);
2631 nt = length(imdl.fwd_model.elems);
2632 imdl.solve = solver;
2633 imdl.reconst_type = <span class="string">'absolute'</span>;
2634 <span class="comment">% specify the units to work in</span>
2635 imdl.inv_solve_core.meas_input   = <span class="string">'voltage'</span>;
2636 imdl.inv_solve_core.meas_working = <span class="string">'apparent_resistivity'</span>;
2637 imdl.inv_solve_core.elem_prior   = {   <span class="string">'conductivity'</span>   };
2638 imdl.inv_solve_core.prior_data   = {        1           };
2639 imdl.inv_solve_core.elem_working = {<span class="string">'log_conductivity'</span>};
2640 imdl.inv_solve_core.elem_output  = {<span class="string">'log10_conductivity'</span>};
2641 imdl.inv_solve_core.calc_solution_error = 0;
2642 imdl.inv_solve_core.verbose = 0;
2643 imdl.hyperparameter.value = 0.1;
2644 
2645 <span class="comment">% set homogeneous conductivity and simulate</span>
2646 imgsrc= <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>( imdl.fwd_model, 1);
2647 vh=<a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(imgsrc);
2648 <span class="comment">% set inhomogeneous conductivity</span>
2649 ctrs= <a href="../../../eidors/models/interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>(imdl.fwd_model);
2650 x= ctrs(:,1); y= ctrs(:,2);
2651 r1=sqrt((x+5).^2 + (y+5).^2); r2 = sqrt((x-45).^2 + (y-35).^2);
2652 imgsrc.elem_data(r1&lt;50)= 0.05;
2653 imgsrc.elem_data(r2&lt;30)= 100;
2654 
2655 <span class="comment">% inhomogeneous data</span>
2656 vi=<a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>( imgsrc );
2657 <span class="comment">% add noise</span>
2658 <span class="comment">%Add 30dB SNR noise to data</span>
2659 noise_level= std(vi.meas - vh.meas)/10^(30/20);
2660 vi.meas = vi.meas + noise_level*randn(size(vi.meas));
2661 
2662 <span class="comment">% show model</span>
2663 hh=clf; subplot(221); imgp = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(imgsrc, <span class="string">'log10_conductivity'</span>); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgp,1); axis tight; title(<span class="string">'synth baseline, logC'</span>);
2664 
2665 <span class="comment">% Reconstruct Images</span>
2666 img0= <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vi);
2667 figure(hh); subplot(222);
2668  img0 = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img0, <span class="string">'log10_conductivity'</span>);
2669  <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img0, 1); axis tight;
2670 
2671 disp(<span class="string">'TEST: conductivity + movement'</span>);
2672 imdl.fwd_model = rmfield(imdl.fwd_model, <span class="string">'jacobian'</span>);
2673 <span class="comment">% specify the units to work in</span>
2674 imdl.inv_solve_core.elem_prior   = {   <span class="string">'conductivity'</span>   , <span class="string">'movement'</span>};
2675 imdl.inv_solve_core.prior_data   = {        1           ,     0     };
2676 imdl.inv_solve_core.RtR_prior    = {     @<a href="../../../eidors/tools/eidors_default.html" class="code" title="function varargout = eidors_default(varargin)">eidors_default</a>, @<a href="#_sub61" class="code" title="subfunction RtR = prior_movement_only(imdl);">prior_movement_only</a>};
2677 imdl.inv_solve_core.elem_len     = {       nt           ,   ne*2    };
2678 imdl.inv_solve_core.elem_working = {  <span class="string">'log_conductivity'</span>, <span class="string">'movement'</span>};
2679 imdl.inv_solve_core.elem_output  = {<span class="string">'log10_conductivity'</span>, <span class="string">'movement'</span>};
2680 imdl.inv_solve_core.jacobian     = { @<a href="../../../eidors/solvers/forward/jacobian_adjoint.html" class="code" title="function J= jacobian_adjoint( fwd_model, img)">jacobian_adjoint</a>  , @<a href="#_sub60" class="code" title="subfunction Jm = jacobian_movement_only (fwd_model, img);">jacobian_movement_only</a>};
2681 imdl.inv_solve_core.hyperparameter = {   [1 1.1 0.9]    ,  sqrt(2e-3)     }; <span class="comment">% multiplied by imdl.hyperparameter.value</span>
2682 imdl.inv_solve_core.verbose = 0;
2683 
2684 <span class="comment">% electrode positions before</span>
2685 nn = [imgsrc.fwd_model.electrode(:).nodes];
2686 elec_orig = imgsrc.fwd_model.nodes(nn,:);
2687 <span class="comment">% set 2% radial movement</span>
2688 nn = imgsrc.fwd_model.nodes;
2689 imgsrc.fwd_model.nodes = nn * [1-0.02 0; 0 1+0.02]; <span class="comment">% 1% compress X, 1% expansion Y, NOT conformal</span>
2690 <span class="comment">% electrode positions after</span>
2691 nn = [imgsrc.fwd_model.electrode(:).nodes];
2692 elec_mv = imgsrc.fwd_model.nodes(nn,:);
2693 
2694 <span class="comment">% inhomogeneous data</span>
2695 vi=<a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>( imgsrc );
2696 <span class="comment">% add noise</span>
2697 <span class="comment">%Add 30dB SNR noise to data</span>
2698 noise_level= std(vi.meas - vh.meas)/10^(30/20);
2699 <span class="comment">%vi.meas = vi.meas + noise_level*randn(size(vi.meas));</span>
2700 
2701 <span class="comment">% show model</span>
2702 nn = [imgsrc.fwd_model.electrode(1:4).nodes];
2703 figure(hh); subplot(223); imgp = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(imgsrc, <span class="string">'log10_conductivity'</span>); <a href="../../../eidors/graphics/matlab/show_fem_move.html" class="code" title="function [hf,hh] = show_fem_move( img, move, scale, options )">show_fem_move</a>(imgp,elec_mv-elec_orig,10,1); axis tight; title(<span class="string">'synth mvmt, logC'</span>);
2704 
2705 <span class="comment">% Reconstruct Images</span>
2706 img1= <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vi);
2707 figure(hh); subplot(224);
2708  imgm = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img1, <span class="string">'movement'</span>);
2709  img1 = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img1, <span class="string">'log10_conductivity'</span>);
2710  <a href="../../../eidors/graphics/matlab/show_fem_move.html" class="code" title="function [hf,hh] = show_fem_move( img, move, scale, options )">show_fem_move</a>(img1,reshape(imgm.elem_data,16,2), 10, 1); axis tight;
2711 
2712 d0 = img0.elem_data; d1 = img1.elem_data;
2713 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'img0 == img1 + mvmt'</span>, d0-d1, 0, 0.40);
2714 
2715 <span class="comment">% helper function: calculate jacobian movement by itself</span>
2716 <a name="_sub60" href="#_subfunctions" class="code">function Jm = jacobian_movement_only (fwd_model, img);</a>
2717   pp = <a href="../../../eidors/solvers/forward/fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>(img.fwd_model);
2718   szJm = pp.n_elec * pp.n_dims; <span class="comment">% number of electrodes * dimensions</span>
2719   img = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img, <span class="string">'conductivity'</span>); <span class="comment">% expect conductivity only</span>
2720   Jcm = <a href="../../../eidors/solvers/forward/jacobian_movement.html" class="code" title="function J = jacobian_movement(fwd_model, img)">jacobian_movement</a>(fwd_model, img);
2721   Jm = Jcm(:,(end-szJm+1):end);
2722 <span class="comment">%% this plot shows we are grabing the right section of the Jacobian</span>
2723 <span class="comment">%  figure();</span>
2724 <span class="comment">%  subplot(311); imagesc(Jcm); axis ij equal tight; xlabel(sprintf('||Jcm||=%g',norm(Jcm))); colorbar;</span>
2725 <span class="comment">%  Jc = jacobian_adjoint(fwd_model, img);</span>
2726 <span class="comment">%  subplot(312); imagesc([Jc Jm]); axis ij equal tight; xlabel(sprintf('||[Jc Jm]||=%g',norm([Jc Jm]))); colorbar;</span>
2727 <span class="comment">%  dd = abs([Jc Jm]-Jcm); % difference</span>
2728 <span class="comment">%  subplot(313); imagesc(dd); axis ij equal tight; xlabel(sprintf('|| |[Jc Jm]-Jcm| ||=%g',norm(dd))); colorbar;</span>
2729 
2730 <a name="_sub61" href="#_subfunctions" class="code">function RtR = prior_movement_only(imdl);</a>
2731   imdl.image_prior.parameters(1) = 1; <span class="comment">% weighting of movement vs. conductivity ... but we're dropping conductivity here</span>
2732   pp = <a href="../../../eidors/solvers/forward/fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>(imdl.fwd_model);
2733   szPm = pp.n_elec * pp.n_dims; <span class="comment">% number of electrodes * dimensions</span>
2734   RtR = <a href="prior_movement.html" class="code" title="function Reg= prior_movement( inv_model );">prior_movement</a>(imdl);
2735   RtR = RtR((end-szPm+1):<span class="keyword">end</span>,(end-szPm+1):end);
2736 
2737 <a name="_sub62" href="#_subfunctions" class="code">function do_unit_test_rec2(solver)</a>
2738 disp(<span class="string">'TEST: reconstruct a discontinuity'</span>);
2739 [imdl, vh] = <a href="#_sub53" class="code" title="subfunction [imdl, vh, imgi, vi] = unit_test_imdl()">unit_test_imdl</a>();
2740 imgi = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(imdl, 1);
2741 ctrs = <a href="../../../eidors/models/interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>(imdl.fwd_model);
2742 x = ctrs(:,1); y = ctrs(:,2);
2743 imgi.elem_data(x-y&gt;100)= 1/10;
2744 vi = <a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(imgi); vi = vi.meas;
2745 clf; <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgi,1);
2746 
2747 imdl.solve = solver;
2748 imdl.hyperparameter.value = 1e2; <span class="comment">% was 0.1</span>
2749 
2750 imdl.reconst_type = <span class="string">'absolute'</span>;
2751 imdl.inv_solve_core.elem_working = <span class="string">'log_conductivity'</span>;
2752 imdl.inv_solve_core.elem_output = <span class="string">'log10_resistivity'</span>;
2753 imdl.inv_solve_core.meas_working = <span class="string">'apparent_resistivity'</span>;
2754 imdl.inv_solve_core.dtol_iter = 4; <span class="comment">% default 1 -&gt; start checking on the first iter</span>
2755 imdl.inv_solve_core.max_iterations = 20; <span class="comment">% default 10</span>
2756 imdl.inv_solve_core.calc_solution_error = 0;
2757 imdl.inv_solve_core.verbose = 10;
2758 imgr= <a href="inv_solve_core.html" class="code" title="function img= inv_solve_core( inv_model, data0, data1);">inv_solve_core</a>(imdl, vi);
2759 
2760 clf; <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgr,1);
2761 img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>( imdl );
2762 img.elem_data= 1./(10.^imgr.elem_data);
2763 
2764 <span class="comment">%I = 1; % TODO FIXME -&gt; I is diag(1./vh) the conversion to apparent resistivity</span>
2765 <span class="comment">%% TODO these plots are useful, get them built into the solver!</span>
2766 <span class="comment">%vCG= fwd_solve(img); vCG = vCG.meas; fmdl = imdl.fwd_model;</span>
2767 <span class="comment">%clf; plot(I*(vi-vCG)); title('data misfit');</span>
2768 <span class="comment">%clf; hist(abs(I*(vi-vCG)),50); title('|data misfit|, histogram'); xlabel('|misfit|'); ylabel('count');</span>
2769 <span class="comment">%clf; show_pseudosection( fmdl, I*vi); title('measurement data');</span>
2770 <span class="comment">%clf; show_pseudosection( fmdl, I*vCG); title('reconstruction data');</span>
2771 <span class="comment">%clf; show_pseudosection( fmdl, (vCG-vi)/vi*100); title('data misfit');</span>
2772 
2773 
2774 <a name="_sub63" href="#_subfunctions" class="code">function do_unit_test_img0_bg()</a>
2775    stim = <a href="../../../eidors/models/mk_stim_patterns.html" class="code" title="function [stim, meas_sel]= mk_stim_patterns(n_elec, n_rings, inj, meas, options, amplitude)">mk_stim_patterns</a>(32,1, <span class="keyword">...</span>
2776    [0,5],[0,5],{<span class="string">'meas_current'</span>});
2777    extra = {<span class="string">'ball'</span>,[<span class="string">'solid ball = '</span> <span class="keyword">...</span>
2778    <span class="string">'sphere(0.4,0,0.4; 0.1);'</span>]};
2779    fmdl = <a href="../../../eidors/meshing/netgen/ng_mk_cyl_models.html" class="code" title="function [fmdl,mat_idx] = ng_mk_cyl_models(cyl_shape, elec_pos,elec_shape, extra_ng_code);">ng_mk_cyl_models</a>([1,1,0.1],<span class="keyword">...</span>
2780    [16,0.3,0.7],0.05,extra);
2781    [~,fmdl] = <a href="../../../eidors/models/elec_rearrange.html" class="code" title="function [elec_idx, new_fmdl] = elec_rearrange( pattern, newarrange, fwd_model )">elec_rearrange</a>([16,2],<span class="keyword">...</span>
2782    <span class="string">'square'</span>,fmdl);
2783    fmdl.stimulation = stim;
2784    img= <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(fmdl,1);
2785    vh=<a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(img);
2786    img.elem_data(fmdl.mat_idx{2}) = 2;
2787    vi=<a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(img);
2788    cmdl = <a href="../../../eidors/meshing/netgen/ng_mk_cyl_models.html" class="code" title="function [fmdl,mat_idx] = ng_mk_cyl_models(cyl_shape, elec_pos,elec_shape, extra_ng_code);">ng_mk_cyl_models</a>([1,1,0.2],[],[]);
2789    fmdl.coarse2fine = <span class="keyword">...</span>
2790    <a href="../../../eidors/models/mk_coarse_fine_mapping.html" class="code" title="function [mapping, outside] = mk_coarse_fine_mapping(varargin)">mk_coarse_fine_mapping</a>(fmdl,cmdl);
2791    imdl1= <a href="../../../eidors/models/select_imdl.html" class="code" title="function inv_mdl= select_imdl( mdl, options )">select_imdl</a>(fmdl,{<span class="string">'Basic GN dif'</span>});
2792    imdl1.rec_model = cmdl;
2793    imdl1.hyperparameter.value = .0001;
2794    imdl1.inv_solve_gn.max_iterations = 1;
2795    imdl1.solve = @<a href="inv_solve_gn.html" class="code" title="function img= inv_solve_gn( inv_model, data1, data2);">inv_solve_gn</a>;
2796    <span class="comment">%imdl1.solve = @inv_solve_diff_GN_one_step;</span>
2797    imgr1 = <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl1, vh, vi);
2798    <span class="comment">% we don't know what the exact answer should be, but this could should not explode</span>
2799    <span class="comment">% Error was due to not striping background from img0 in difference reconstructions:</span>
2800    <span class="comment">%  Arrays have incompatible sizes for this operation.</span>
2801    <span class="comment">%  Error in inv_solve_core (line 408)</span>
2802    <span class="comment">%  img.elem_data = img.elem_data - img0.elem_data;</span>
2803 
2804 
2805 <span class="comment">% sequence of time series difference data</span>
2806 <a name="_sub64" href="#_subfunctions" class="code">function do_unit_test_diffseq(solver)</a>
2807    lvl = <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>,1);
2808    imdl = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'f2C'</span>,16);
2809    imdl.solve = solver;
2810    imdl.hyperparameter.value = 1e-2; <span class="comment">% was 0.1</span>
2811 
2812    imgh = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(imdl,1);
2813    xyr = [];
2814    <span class="keyword">for</span> deg = [0:5:360]
2815       R = [sind(deg) cosd(deg); cosd(deg) -sind(deg)]; <span class="comment">% rotation matrix</span>
2816       xyr(:,end+1) = [R*[0.5 0.5]'; 0.2];
2817    <span class="keyword">end</span>
2818    [vh, vi, ~, imgm] = <a href="../../../eidors/models/simulate_movement.html" class="code" title="function [vh,vi,xyzr,c2f]= simulate_movement( img, xyzr, UNUSED );">simulate_movement</a>(imgh, xyr);
2819    disp(<span class="string">'*** alert: inverse crime underway ***'</span>);
2820    disp(<span class="string">' - no noise has been added to this data'</span>);
2821    disp(<span class="string">' - reconstructing to the same FEM discretization as simulated data'</span>);
2822    disp(<span class="string">'***'</span>);
2823    vv.meas = [];
2824    vv.time = nan;
2825    vv.name = <span class="string">'asfd'</span>;
2826    vv.type = <span class="string">'data'</span>;
2827    n_frames = size(vi,2);
2828    <span class="keyword">for</span> ii = 1:7
2829       <span class="keyword">switch</span> ii
2830          <span class="keyword">case</span> 1
2831             fprintf(<span class="string">'\n\nvh:numeric, vi:numeric data\n'</span>);
2832             vhi = vh;
2833             vii = vi;
2834          <span class="keyword">case</span> 2
2835             fprintf(<span class="string">'\n\nvh:struct, vi:numeric data\n'</span>);
2836             vhi = vv; vhi.meas = vh;
2837             vii = vi;
2838          <span class="keyword">case</span> 3
2839             fprintf(<span class="string">'\n\nvh:numeric, vi:struct data\n'</span>);
2840             vhi = vh;
2841             clear vii;
2842             <span class="keyword">for</span> jj=1:n_frames;
2843                vii(jj) = vv; vii(jj).meas = vi(:,jj);
2844             <span class="keyword">end</span>
2845          <span class="keyword">case</span> 4
2846             fprintf(<span class="string">'\n\nvh:struct, vi:struct data\n'</span>);
2847             vhi = vv; vhi.meas = vh;
2848             clear vii;
2849             <span class="keyword">for</span> jj=1:n_frames;
2850                vii(jj) = vv; vii(jj).meas = vi(:,jj);
2851             <span class="keyword">end</span>
2852          <span class="keyword">case</span> 5
2853             fprintf(<span class="string">'method = Cholesky\n'</span>);
2854             imdl.inv_solve_core.update_method = <span class="string">'cholesky'</span>;
2855          <span class="keyword">case</span> 6
2856             fprintf(<span class="string">'method = PCG\n'</span>);
2857             imdl.inv_solve_core.update_method = <span class="string">'pcg'</span>;
2858          <span class="keyword">otherwise</span>
2859             fprintf(<span class="string">'method = default\n'</span>);
2860             imdl.inv_solve_core = rmfield(imdl.inv_solve_core,<span class="string">'update_method'</span>);
2861       <span class="keyword">end</span>
2862       img= <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vhi, vii);
2863       <span class="keyword">for</span> i=1:size(imgm,2)
2864          clf;
2865          subplot(211); imgi=imgh; imgi.elem_data = imgm(:,i); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgi); title(sprintf(<span class="string">'fwd#%d'</span>,i));
2866          subplot(212); imgi=imgh; imgi.elem_data = img.elem_data(:,i); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgi); title(<span class="string">'reconst'</span>);
2867          drawnow;
2868          err(i) = norm(imgm(:,i)/max(imgm(:,i)) - img.elem_data(:,i)/max(img.elem_data(:,i)));
2869          fprintf(<span class="string">'image#%d: reconstruction error = %g\n'</span>,i,err(i));
2870       <span class="keyword">end</span>
2871       <span class="keyword">for</span> i=1:size(imgm,2)
2872          <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>( sprintf(<span class="string">'diff seq image#%d'</span>,i), <span class="keyword">...</span>
2873             imgm(:,i)/max(imgm(:,i)), <span class="keyword">...</span>
2874             img.elem_data(:,i)/max(img.elem_data(:,i)), <span class="keyword">...</span>
2875             0.90 );
2876       <span class="keyword">end</span>
2877    <span class="keyword">end</span>
2878    <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>,lvl);
2879 
2880 <span class="comment">% sequence of time series data</span>
2881 <a name="_sub65" href="#_subfunctions" class="code">function do_unit_test_absseq(solver)</a>
2882    lvl = <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>,1);
2883    imdl = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'f2C'</span>,16);
2884    imdl.reconst_type = <span class="string">'absolute'</span>;
2885    imdl.solve = solver;
2886    imdl.hyperparameter.value = 1e-2; <span class="comment">% was 0.1</span>
2887 
2888    imgh = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(imdl,1);
2889    xyr = [];
2890    <span class="keyword">for</span> deg = [0:5:360]
2891       R = [sind(deg) cosd(deg); cosd(deg) -sind(deg)]; <span class="comment">% rotation matrix</span>
2892       xyr(:,end+1) = [R*[0.5 0.5]'; 0.2];
2893    <span class="keyword">end</span>
2894    [~, vi, ~, imgm] = <a href="../../../eidors/models/simulate_movement.html" class="code" title="function [vh,vi,xyzr,c2f]= simulate_movement( img, xyzr, UNUSED );">simulate_movement</a>(imgh, xyr);
2895    imgm = imgm + 1; <span class="comment">% simulate_movement returns difference images but we're doing absolute solver work</span>
2896    disp(<span class="string">'*** alert: inverse crime underway ***'</span>);
2897    disp(<span class="string">' - no noise has been added to this data'</span>);
2898    disp(<span class="string">' - reconstructing to the same FEM discretization as simulated data'</span>);
2899    disp(<span class="string">'***'</span>);
2900    vv.meas = [];
2901    vv.time = nan;
2902    vv.name = <span class="string">'asfd'</span>;
2903    vv.type = <span class="string">'data'</span>;
2904    n_frames = size(vi,2);
2905    <span class="keyword">for</span> ii = 1:5
2906       <span class="keyword">switch</span> ii
2907          <span class="keyword">case</span> 1
2908             fprintf(<span class="string">'\n\nvi:numeric data\n'</span>);
2909             vii = vi;
2910          <span class="keyword">case</span> 2
2911             fprintf(<span class="string">'\n\nvi:struct data\n'</span>);
2912             clear vii;
2913             <span class="keyword">for</span> jj=1:n_frames;
2914                vii(jj) = vv; vii(jj).meas = vi(:,jj);
2915             <span class="keyword">end</span>
2916          <span class="keyword">case</span> 3
2917             fprintf(<span class="string">'method = Cholesky\n'</span>);
2918             imdl.inv_solve_core.update_method = <span class="string">'cholesky'</span>;
2919          <span class="keyword">case</span> 4
2920             fprintf(<span class="string">'method = PCG\n'</span>);
2921             imdl.inv_solve_core.update_method = <span class="string">'pcg'</span>;
2922          <span class="keyword">otherwise</span>
2923             fprintf(<span class="string">'method = default\n'</span>);
2924             imdl.inv_solve_core = rmfield(imdl.inv_solve_core,<span class="string">'update_method'</span>);
2925       <span class="keyword">end</span>
2926       img= <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vii);
2927       <span class="keyword">for</span> i=1:size(imgm,2)
2928          clf;
2929          subplot(211); imgi=imgh; imgi.elem_data = imgm(:,i); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgi); title(sprintf(<span class="string">'fwd#%d'</span>,i));
2930          subplot(212); imgi=imgh; imgi.elem_data = img.elem_data(:,i); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgi); title(<span class="string">'reconst'</span>);
2931          drawnow;
2932          err(i) = norm(imgm(:,i)/max(imgm(:,i)) - img.elem_data(:,i)/max(img.elem_data(:,i)));
2933          fprintf(<span class="string">'image#%d: reconstruction error = %g\n'</span>,i,err(i));
2934       <span class="keyword">end</span>
2935       <span class="keyword">for</span> i=1:size(imgm,2)
2936          <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>( sprintf(<span class="string">'abs seq image#%d'</span>,i), <span class="keyword">...</span>
2937             imgm(:,i)/max(imgm(:,i)), <span class="keyword">...</span>
2938             img.elem_data(:,i)/max(img.elem_data(:,i)), <span class="keyword">...</span>
2939             0.46 );
2940       <span class="keyword">end</span>
2941    <span class="keyword">end</span>
2942    <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>,lvl);</pre></div>
<hr><address>Generated on Fri 30-Dec-2022 20:46:51 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>
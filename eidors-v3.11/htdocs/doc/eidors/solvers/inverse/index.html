<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Index for Directory eidors/solvers/inverse</title>
  <meta name="keywords" content="eidors/solvers/inverse">
  <meta name="description" content="Index for Directory eidors/solvers/inverse">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/solvers/inverse&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>

<h1>Index for eidors/solvers/inverse</h1>

<h2>Matlab files in this directory:</h2>
<table>
<tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="GREIT_desired_img_FEMmesh.html">GREIT_desired_img_FEMmesh</a></td><td>GREIT_DESIRED_IMG_FEMmesh  GREIT onto a FEM mesh </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="GREIT_desired_img_original.html">GREIT_desired_img_original</a></td><td>GREIT_DESIRED_IMG_ORIGINAL The original desired solution for GREIT </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="GREIT_desired_img_sigmoid.html">GREIT_desired_img_sigmoid</a></td><td>GREIT_DESIRED_IMG_SIGMOID sigmoid-decay desired image function for GREIT </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="RtR_prior_elem2nodes.html">RtR_prior_elem2nodes</a></td><td>RtR_PRIOR_ELEM2NODES: Convert elem to nodal RtR Image Prior </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="TV_operator_2D.html">TV_operator_2D</a></td><td>03/12/00 By Andrea Borsic </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="TV_operator_3D.html">TV_operator_3D</a></td><td>L=TV_operator_3D( msh ) </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="calc_GREIT_RM.html">calc_GREIT_RM</a></td><td>CALCULATE GREIT reconstruction matrix </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="calc_TSVD_RM.html">calc_TSVD_RM</a></td><td>CALC_TSVD_RM: Calculated truncated Jacobian SVD reconstruction matrix </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="calc_image_SNR.html">calc_image_SNR</a></td><td>% CALC_IMAGE_SNR: Calculates the signal-to-noise ratio (SNR) in the image </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="calc_lambda_regtools.html">calc_lambda_regtools</a></td><td>% CALC_LAMBDA_REGTOOLS: Find optimal hyperparameter by the L-curve (LCC) </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="calc_noise_figure.html">calc_noise_figure</a></td><td>CALC_NOISE_FIGURE: calculate the noise amplification (NF) of an algorithm </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="calc_reciproc_error.html">calc_reciproc_error</a></td><td>CALC_RECIPROC_ERROR: CALCULATE RECIPROCITY ERROR MATRIX </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="calc_solution_error.html">calc_solution_error</a></td><td>CALC_SOLUTION_ERROR Calculate residuals for a solution </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="choose_image_SNR.html">choose_image_SNR</a></td><td>% CHOOSE_IMAGE_SNR: choose hyperparameter based on image SNR calculation </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="choose_noise_figure.html">choose_noise_figure</a></td><td>CHOOSE_NOISE_FIGURE: choose hyperparameter based on NF calculation </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="get_RM.html">get_RM</a></td><td>% GET_RM: obtains the reconstruction matrix from a given inverse model </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="inv_solve_TSVD.html">inv_solve_TSVD</a></td><td>INV_SOLVE_TSVD: inverse solver based on truncatated SVD </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="inv_solve_TV_irls.html">inv_solve_TV_irls</a></td><td>INV_SOLVE_TV_IRLS Iteratively Reweighted Least Squares inverse solver </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="inv_solve_TV_pdipm.html">inv_solve_TV_pdipm</a></td><td>INV_SOLVE_TV_PDIPM inverse solver for Andrea Borsic's </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="inv_solve_abs_GN_constrain.html">inv_solve_abs_GN_constrain</a></td><td>Do Gauss Netwon Method with barrier to ensure positvity of the con </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="inv_solve_abs_GN_prior.html">inv_solve_abs_GN_prior</a></td><td>INV_SOLVE_ABS_GN_PRIOR inverse solver (WITH DIFFERENT PRIOR AT ITERATION!!!!!) </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="inv_solve_abs_annealingMetropolis_params.html">inv_solve_abs_annealingMetropolis_params</a></td><td>INV_SOLVE_ABS_ANNEALINGSIMPLEX_PARAMS absolute solver using the simplex annealing method. </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="inv_solve_abs_annealingSimplex_params.html">inv_solve_abs_annealingSimplex_params</a></td><td>INV_SOLVE_ABS_ANNEALINGSIMPLEX_PARAMS absolute solver using the simplex annealing method. </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="inv_solve_abs_pdipm.html">inv_solve_abs_pdipm</a></td><td>INV_SOLVE_ABS_PDIPM  inverse solver for absolute data using Primal/Dual interior point method </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="inv_solve_backproj.html">inv_solve_backproj</a></td><td>INV_SOLVE_BACKPROJ inverse solver using backprojection </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="inv_solve_cg.html">inv_solve_cg</a></td><td>function img= inv_solve_cg( inv_model, data1); </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="inv_solve_conj_grad.html">inv_solve_conj_grad</a></td><td>INV_SOLVE_CONJ_GRAD inverse solver based on the CG </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="inv_solve_core.html">inv_solve_core</a></td><td>INV_SOLVE_CORE Solver using a generic iterative algorithm </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="inv_solve_diff_GN_one_step.html">inv_solve_diff_GN_one_step</a></td><td>INV_SOLVE_DIFF_GN_ONE_STEP inverse solver using approach of Adler&Guardo 1996 </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="inv_solve_diff_kalman.html">inv_solve_diff_kalman</a></td><td>INV_SOLVE_DIFF_KALMAN inverse solver for difference EIT </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="inv_solve_diff_pdipm.html">inv_solve_diff_pdipm</a></td><td>INV_SOLVE_DIFF_PDIPM inverse solver for difference data using Primal/Dual interior point method </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="inv_solve_gn.html">inv_solve_gn</a></td><td>function img= inv_solve_gn( inv_model, data1); </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="inv_solve_mcmc.html">inv_solve_mcmc</a></td><td>NP_INV_SOLVE inverse solver for Nick Polydorides EIDORS3D code </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="inv_solve_time_prior.html">inv_solve_time_prior</a></td><td>INV_SOLVE_TIME_PRIOR inverse solver to account for time differences </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="inv_solve_trunc_iterative.html">inv_solve_trunc_iterative</a></td><td>INV_SOLVE_TRUNC_ITERATIVE using Morozov truncated iteration </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="line_optimize.html">line_optimize</a></td><td>LINE_OPTIMIZE Cheap line optimizer </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="line_search_o2.html">line_search_o2</a></td><td>function  [alpha, img, dv, opt] = line_search_o2(imgk, dx, data1, img1, N, W, hps2RtR, dv0, opt) </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="line_search_onm2.html">line_search_onm2</a></td><td>function  [alpha, img, dv, opt] = line_search_onm2(imgk, dx, data1, img1, N, W, hps2RtR, hpt2LLt, dv0, opt) </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="meas_icov_rm_elecs.html">meas_icov_rm_elecs</a></td><td>MEAS_ICOV_RM_ELECS: remove electrodes from consideration </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="mk_GN_model.html">mk_GN_model</a></td><td>MK_GN_MODEL: make EIDORS inverse models using the GREIT approach </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="nodal_solve.html">nodal_solve</a></td><td>NODAL_SOLVE inverse solver using approach of Adler&Guardo 1996 </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="primaldual_tvrecon_lsearch.html">primaldual_tvrecon_lsearch</a></td><td>[rs,x]=primaldual_tvrecon_lsearch(inv_mdl, vmeas, ... </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="prior_TV.html">prior_TV</a></td><td>PRIOR_TV calculate Total Variation image prior </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="prior_covar.html">prior_covar</a></td><td>PRIOR_COVAR image prior with distance-based interelement covar </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="prior_exponential_covar.html">prior_exponential_covar</a></td><td>PRIOR_EXPONENTIAL_COVAR image prior with exponential </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="prior_gaussian_HPF.html">prior_gaussian_HPF</a></td><td>PRIOR_GAUSSIAN_HPF calculate image prior </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="prior_gaussian_likelihood.html">prior_gaussian_likelihood</a></td><td>Parameters for image </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="prior_laplace.html">prior_laplace</a></td><td>PRIOR_LAPLACE calculate image prior </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="prior_laplace_old.html">prior_laplace_old</a></td><td>PRIOR_LAPLACE calculate image prior </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="prior_movement.html">prior_movement</a></td><td>PRIOR_MOVEMENT calculate image prior </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="prior_noser.html">prior_noser</a></td><td>PRIOR_NOSER calculate image prior </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="prior_tikhonov.html">prior_tikhonov</a></td><td>PRIOR_TIKHONOV calculate image prior </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="prior_time_smooth.html">prior_time_smooth</a></td><td>PRIOR_TIME_SMOOTH calculate image prior </td></tr><tr><td><img src="../../../matlabicon.gif" alt="" border="">&nbsp;<a href="solve_use_matrix.html">solve_use_matrix</a></td><td>SOLVE_USE_MATRIX solve using reconstruction matrix </td></tr></table>




<hr><address>Generated on Fri 30-Dec-2022 20:46:50 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>
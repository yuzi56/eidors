<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of inv_solve_time_prior</title>
  <meta name="keywords" content="inv_solve_time_prior">
  <meta name="description" content="INV_SOLVE_TIME_PRIOR inverse solver to account for time differences">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">eidors</a> &gt; <a href="../index.html">solvers</a> &gt; <a href="index.html">inverse</a> &gt; inv_solve_time_prior.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/solvers/inverse&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>inv_solve_time_prior
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>INV_SOLVE_TIME_PRIOR inverse solver to account for time differences</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function img= inv_solve_time_prior( inv_model, data1, data2) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> INV_SOLVE_TIME_PRIOR inverse solver to account for time differences
 img= inv_solve_time_prior( inv_model, data1, data2)
 img        =&gt; output image (or vector of images)
 inv_model  =&gt; inverse model struct
 data1      =&gt; differential data at earlier time
 data2      =&gt; differential data at later time

 both data1 and data2 may be matrices (MxT) each of
  M measurements at T times
 if either data1 or data2 is a vector, then it is expanded
  to be the same size matrix

 Parameters
   inv_model.inv_solve_time_prior.time_steps =&gt; time_steps</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>	SHOW_FEM: show the EIDORS3D finite element model</li><li><a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="../../../eidors/models/mk_library_model.html" class="code" title="function out = mk_library_model(shape,elec_pos,elec_shape,maxsz,nfft,scale)">mk_library_model</a>	MK_LIBRARY_MODEL - FEM models based on library shapes</li><li><a href="../../../eidors/models/mk_stim_patterns.html" class="code" title="function [stim, meas_sel]= mk_stim_patterns(n_elec, n_rings, inj, meas, options, amplitude)">mk_stim_patterns</a>	MK_STIM_PATTERNS: create an EIDORS stimulation pattern structure</li><li><a href="../../../eidors/models/simulate_2d_movement.html" class="code" title="function [vh,vi,xyr_pt]= simulate_2d_movement( n_sims, fmdl, rad_pr, movefcn )">simulate_2d_movement</a>	SIMULATE_2D_MOVEMENT simulate rotational movement in 2D</li><li><a href="../../../eidors/models/simulate_3d_movement.html" class="code" title="function [vh,vi,xyzr_pt]= simulate_3d_movement( n_sims, fmdl, rad_pr,movefcn )">simulate_3d_movement</a>	SIMULATE_3D_MOVEMENT simulate rotational movement in 3D</li><li><a href="../../../eidors/solvers/calc_RtR_prior.html" class="code" title="function RtR_prior = calc_RtR_prior( inv_model )">calc_RtR_prior</a>	RtR = calc_RtR_prior( inv_model )</li><li><a href="../../../eidors/solvers/calc_difference_data.html" class="code" title="function dva = calc_difference_data( data1, data2, fwd_model)">calc_difference_data</a>	CALC_DIFFERENCE_DATA: calculate difference data between</li><li><a href="../../../eidors/solvers/calc_hyperparameter.html" class="code" title="function hyperparameter = calc_hyperparameter( inv_model )">calc_hyperparameter</a>	CALC_HYPERPARAMETER: calculate hyperparameter value</li><li><a href="../../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>	CALC_JACOBIAN: calculate jacobian from an inv_model</li><li><a href="../../../eidors/solvers/calc_jacobian_bkgnd.html" class="code" title="function img_bkgnd = calc_jacobian_bkgnd( inv_model )">calc_jacobian_bkgnd</a>	CALC_JACOBIAN_BKGND: calculate background image around</li><li><a href="../../../eidors/solvers/calc_meas_icov.html" class="code" title="function meas_icov = calc_meas_icov( inv_model )">calc_meas_icov</a>	meas_icov = calc_meas_icov( inv_model )</li><li><a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>	INV_SOLVE: calculate imag from an inv_model and data</li><li><a href="inv_solve_time_prior.html" class="code" title="function img= inv_solve_time_prior( inv_model, data1, data2)">inv_solve_time_prior</a>	INV_SOLVE_TIME_PRIOR inverse solver to account for time differences</li><li><a href="prior_noser.html" class="code" title="function Reg= prior_noser( inv_model );">prior_noser</a>	PRIOR_NOSER calculate image prior</li><li><a href="prior_time_smooth.html" class="code" title="function Reg= prior_time_smooth( inv_model );">prior_time_smooth</a>	PRIOR_TIME_SMOOTH calculate image prior</li><li><a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>	EIDORS_CACHE Control eidors caching</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/deprecated/time_prior_solve.html" class="code" title="function img= time_prior_solve(inv_model, varargin )">time_prior_solve</a>	TIME_PRIOR_SOLVE inverse solver to account for time differences</li><li><a href="../../../eidors/examples/moving_tank_objs.html" class="code" title="function imgs= moving_tank_objs(data_sel, inv_sel, options)">moving_tank_objs</a>	MOVING_TANK_OBJS: create movies of objects moving in tanks</li><li><a href="inv_solve_time_prior.html" class="code" title="function img= inv_solve_time_prior( inv_model, data1, data2)">inv_solve_time_prior</a>	INV_SOLVE_TIME_PRIOR inverse solver to account for time differences</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function one_step_inv= standard_form( inv_model)</a></li><li><a href="#_sub2" class="code">function one_step_inv= data_form( inv_model)</a></li><li><a href="#_sub3" class="code">function delta_vec= calc_delta( inv_model, J)</a></li><li><a href="#_sub4" class="code">function do_unit_test</a></li><li><a href="#_sub5" class="code">function do_unit_test_2d</a></li><li><a href="#_sub6" class="code">function do_unit_test_3d</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function img= inv_solve_time_prior( inv_model, data1, data2)</a>
0002 <span class="comment">% INV_SOLVE_TIME_PRIOR inverse solver to account for time differences</span>
0003 <span class="comment">% img= inv_solve_time_prior( inv_model, data1, data2)</span>
0004 <span class="comment">% img        =&gt; output image (or vector of images)</span>
0005 <span class="comment">% inv_model  =&gt; inverse model struct</span>
0006 <span class="comment">% data1      =&gt; differential data at earlier time</span>
0007 <span class="comment">% data2      =&gt; differential data at later time</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% both data1 and data2 may be matrices (MxT) each of</span>
0010 <span class="comment">%  M measurements at T times</span>
0011 <span class="comment">% if either data1 or data2 is a vector, then it is expanded</span>
0012 <span class="comment">%  to be the same size matrix</span>
0013 <span class="comment">%</span>
0014 <span class="comment">% Parameters</span>
0015 <span class="comment">%   inv_model.inv_solve_time_prior.time_steps =&gt; time_steps</span>
0016 
0017 <span class="comment">% TODO: This function really should be calling the proper</span>
0018 <span class="comment">%   prior calculator functions, and not reimplementing</span>
0019 <span class="comment">%   them internally</span>
0020 
0021 <span class="comment">% (C) 2005 Andy Adler. License: GPL version 2 or version 3</span>
0022 <span class="comment">% $Id: inv_solve_time_prior.m 5112 2015-06-14 13:00:41Z aadler $</span>
0023 
0024 <span class="keyword">if</span> ischar(inv_model) &amp;&amp; strcmp(inv_model,<span class="string">'UNIT_TEST'</span>); <a href="#_sub4" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0025 
0026 fwd_model= inv_model.fwd_model;
0027 time_steps = inv_model.inv_solve_time_prior.time_steps;
0028 l_ts  = time_steps*2 + 1;
0029 
0030 <span class="comment">% The one_step reconstruction matrix is cached</span>
0031 
0032 one_step_inv= <a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub2" class="code" title="subfunction one_step_inv= data_form( inv_model)">data_form</a>, inv_model, <span class="string">'inv_solve_time_prior'</span> );
0033 
0034 dva = <a href="../../../eidors/solvers/calc_difference_data.html" class="code" title="function dva = calc_difference_data( data1, data2, fwd_model)">calc_difference_data</a>( data1, data2, inv_model.fwd_model);
0035 
0036 l_dva = size( dva, 2);
0037 
0038 idx= [-time_steps:time_steps]'*ones(1,l_dva) + <span class="keyword">...</span>
0039      ones(l_ts,1)*(1:l_dva);
0040 <span class="comment">% replicate first and last measurements</span>
0041 idx(idx&lt;1) = 1;
0042 idx(idx&gt;l_dva) = l_dva;
0043 
0044 dvat= reshape(dva(:,idx),[],l_dva);
0045  
0046 sol = one_step_inv * dvat;
0047 
0048 <span class="comment">% create a data structure to return</span>
0049 img.name= <span class="string">'solved by inv_solve_time_prior'</span>;
0050 img.elem_data = sol;
0051 img.inv_model= inv_model;
0052 img.fwd_model= fwd_model;
0053 
0054 <span class="comment">% calculate the one_step_inverse using the standard</span>
0055 <span class="comment">% formulation (JtWJ + hp^2*RtR)\JtW</span>
0056 <a name="_sub1" href="#_subfunctions" class="code">function one_step_inv= standard_form( inv_model)</a>
0057     RtR = <a href="../../../eidors/solvers/calc_RtR_prior.html" class="code" title="function RtR_prior = calc_RtR_prior( inv_model )">calc_RtR_prior</a>( inv_model );
0058     W   = <a href="../../../eidors/solvers/calc_meas_icov.html" class="code" title="function meas_icov = calc_meas_icov( inv_model )">calc_meas_icov</a>( inv_model );
0059     hp  = <a href="../../../eidors/solvers/calc_hyperparameter.html" class="code" title="function hyperparameter = calc_hyperparameter( inv_model )">calc_hyperparameter</a>( inv_model );
0060 
0061     time_steps = inv_model.inv_solve_time_prior.time_steps;
0062     l_ts  = time_steps*2 + 1;
0063 
0064     JtWJ = kron( speye(l_ts), J'*W*J);
0065     JtW  = kron( speye(l_ts), J'*W);
0066     one_step_inv= (JtWJ +  hp^2*RtR)\JtW;
0067 
0068     n_el= size(J,2);
0069     one_step_inv= one_step_inv(n_el*time_steps + (1:n_el),:);
0070 
0071 <span class="comment">% calculate the one_step_inverse using the data form</span>
0072 <span class="comment">% CovX * J' * inv(J*CovX*J' + CovZ)</span>
0073 <span class="comment">%   iRtR*Jt/(Ji*RtR*Jt +  hp^2*iW);</span>
0074 <a name="_sub2" href="#_subfunctions" class="code">function one_step_inv= data_form( inv_model)</a>
0075     img_bkgnd= <a href="../../../eidors/solvers/calc_jacobian_bkgnd.html" class="code" title="function img_bkgnd = calc_jacobian_bkgnd( inv_model )">calc_jacobian_bkgnd</a>( inv_model );
0076     J = <a href="../../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>(img_bkgnd);
0077     space_prior= inv_model.prior_time_smooth.space_prior;
0078     time_weight= inv_model.prior_time_smooth.time_weight;
0079     ts         = inv_model.inv_solve_time_prior.time_steps;
0080 
0081     space_Reg= feval(space_prior, inv_model);
0082 
0083     iRtRJt_frac=  (space_Reg\J');
0084     JiRtRJt_frac= J*iRtRJt_frac;
0085 
0086     <span class="comment">% JiRtRJt_mult accounts for different parts of the</span>
0087     <span class="comment">% frame being taken at different times</span>
0088     delta_vec= <a href="#_sub3" class="code" title="subfunction delta_vec= calc_delta( inv_model, J)">calc_delta</a>( inv_model, J);
0089     delta_vec1= delta_vec*ones(1,length(delta_vec));
0090     JiRtRJt_mult = time_weight.^abs(delta_vec1 - delta_vec1');
0091 
0092     [x,y]= meshgrid(-ts:ts,  -ts:ts);
0093     time_w_mat= time_weight.^abs(x-y);
0094 
0095     JiRtRJt= kron( time_w_mat, JiRtRJt_frac .* JiRtRJt_mult );
0096 
0097     <span class="comment">%FIXME: do we multiply be JiRtRJt_mult here?</span>
0098     iRtRJt=  kron( time_w_mat(ts+1,:), iRtRJt_frac );
0099 
0100     iW   = kron( speye(1+2*ts), inv( <span class="keyword">...</span>
0101                  <a href="../../../eidors/solvers/calc_meas_icov.html" class="code" title="function meas_icov = calc_meas_icov( inv_model )">calc_meas_icov</a>( inv_model ) ));
0102     hp   = <a href="../../../eidors/solvers/calc_hyperparameter.html" class="code" title="function hyperparameter = calc_hyperparameter( inv_model )">calc_hyperparameter</a>( inv_model );
0103 
0104     one_step_inv= iRtRJt/(JiRtRJt +  hp^2*iW);
0105 
0106 <span class="comment">% if measurements are taken at different times,</span>
0107 <span class="comment">% then calculate a delta of each wrt the centre time</span>
0108 <a name="_sub3" href="#_subfunctions" class="code">function delta_vec= calc_delta( inv_model, J)</a>
0109    stimulation= inv_model.fwd_model.stimulation;
0110    n_N= size(J,1);
0111 
0112    <span class="keyword">if</span> isfield(stimulation(1),<span class="string">'delta_time'</span>)
0113       delta_time= [stimulation(:).delta_time];
0114       <span class="keyword">if</span> diff(delta_time) ~= 0;
0115          error(<span class="string">'All time steps must be same for kalman filter'</span>);
0116       <span class="keyword">end</span>
0117    <span class="keyword">else</span>
0118       delta_time=0;
0119    <span class="keyword">end</span>
0120 
0121    <span class="comment">% sequence is a vector location of each stimulation in the frame</span>
0122    <span class="keyword">if</span> delta_time == 0
0123       seq= size(J,1);
0124    <span class="keyword">else</span>
0125       <span class="keyword">for</span> i=1:length(stimulation)
0126          seq(i) = size(stimulation(i).meas_pattern,1);
0127       <span class="keyword">end</span>
0128       seq= cumsum( seq );
0129    <span class="keyword">end</span>
0130 
0131    delta_time= cumsum(delta_time);
0132 
0133    delta_vec= zeros(size(J,1),1);
0134    seq= [0;seq(:)];
0135    <span class="keyword">for</span> i=1:length(seq)-1
0136       delta_vec( (seq(i)+1):seq(i+1) )= delta_time(i);
0137    <span class="keyword">end</span>
0138 
0139    <span class="comment">% normalize so middle time is centre, and max time is 1</span>
0140    delta_vec= (delta_vec - mean(delta_vec)) / <span class="keyword">...</span>
0141               (sum(delta_time) + eps );
0142 
0143    
0144 <a name="_sub4" href="#_subfunctions" class="code">function do_unit_test</a>
0145    <a href="#_sub5" class="code" title="subfunction do_unit_test_2d">do_unit_test_2d</a>
0146    <a href="#_sub6" class="code" title="subfunction do_unit_test_3d">do_unit_test_3d</a>
0147 
0148 <a name="_sub5" href="#_subfunctions" class="code">function do_unit_test_2d</a>
0149    time_steps=  3;
0150    time_weight= .8;
0151 
0152    [vh,vi,xyr_pt]=<a href="../../../eidors/models/simulate_2d_movement.html" class="code" title="function [vh,vi,xyr_pt]= simulate_2d_movement( n_sims, fmdl, rad_pr, movefcn )">simulate_2d_movement</a>(7, [], [],[1,0.5,0.4]);
0153 
0154    imdl_TS = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>( <span class="string">'c2c2'</span>, 16 ); <span class="comment">% 576 element</span>
0155    imdl_TS.fwd_model.normalize_measurements= 0;
0156    imdl_TS.hyperparameter.value= 0.10;
0157 
0158    imdl_TS.RtR_prior= @<a href="prior_time_smooth.html" class="code" title="function Reg= prior_time_smooth( inv_model );">prior_time_smooth</a>;
0159    imdl_TS.prior_time_smooth.space_prior= @<a href="prior_noser.html" class="code" title="function Reg= prior_noser( inv_model );">prior_noser</a>;
0160    imdl_TS.prior_noser.exponent= .5;
0161    imdl_TS.prior_time_smooth.time_weight= time_weight;
0162    imdl_TS.prior_time_smooth.time_steps=  time_steps;
0163    imdl_TS.solve= @<a href="inv_solve_time_prior.html" class="code" title="function img= inv_solve_time_prior( inv_model, data1, data2)">inv_solve_time_prior</a>;
0164    imdl_TS.inv_solve_time_prior.time_steps=   time_steps;
0165 
0166 image_select= floor(length(xyr_pt)/2)+1;  <span class="comment">% this image is at 9 O'Clock</span>
0167 time_steps=  3; ts_expand= 1;
0168 time_weight= .8;
0169 ts_vec= -time_steps:time_steps;
0170 
0171     im_sel= image_select+ ts_vec*ts_expand;
0172     vi_sel= vi(:,im_sel);
0173     sel  = 1 + time_steps; <span class="comment">% choose the middle</span>
0174 
0175    img= <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>( imdl_TS, vh, vi_sel);
0176    img.elem_data= img.elem_data(:,sel);
0177    <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img);
0178 
0179 
0180 <a name="_sub6" href="#_subfunctions" class="code">function do_unit_test_3d</a>
0181    n_sims= 20;
0182    stim = <a href="../../../eidors/models/mk_stim_patterns.html" class="code" title="function [stim, meas_sel]= mk_stim_patterns(n_elec, n_rings, inj, meas, options, amplitude)">mk_stim_patterns</a>(16,2,<span class="string">'{ad}'</span>,<span class="string">'{ad}'</span>,{},1);
0183    fmdl = <a href="../../../eidors/models/mk_library_model.html" class="code" title="function out = mk_library_model(shape,elec_pos,elec_shape,maxsz,nfft,scale)">mk_library_model</a>(<span class="string">'cylinder_16x2el_vfine'</span>);
0184    fmdl.stimulation = stim;
0185    [vh,vi,xyzr_pt]= <a href="../../../eidors/models/simulate_3d_movement.html" class="code" title="function [vh,vi,xyzr_pt]= simulate_3d_movement( n_sims, fmdl, rad_pr,movefcn )">simulate_3d_movement</a>( n_sims, fmdl);
0186</pre></div>
<hr><address>Generated on Fri 30-Dec-2022 20:46:51 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>
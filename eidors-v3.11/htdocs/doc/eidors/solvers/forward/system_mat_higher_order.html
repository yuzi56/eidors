<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of system_mat_higher_order</title>
  <meta name="keywords" content="system_mat_higher_order">
  <meta name="description" content="Assemble the total stiffness matrix : s_mat.E=At;">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">eidors</a> &gt; <a href="../index.html">solvers</a> &gt; <a href="index.html">forward</a> &gt; system_mat_higher_order.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/solvers/forward&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>system_mat_higher_order
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>Assemble the total stiffness matrix : s_mat.E=At;</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [s_mat]=system_mat_higher_order(fwd_model,img) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">Assemble the total stiffness matrix : s_mat.E=At;
M Crabb - 29.06.2012
TODO - Sparse assignment of the matrices</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/meshing/netgen/ng_mk_cyl_models.html" class="code" title="function [fmdl,mat_idx] = ng_mk_cyl_models(cyl_shape, elec_pos,elec_shape, extra_ng_code);">ng_mk_cyl_models</a>	NG_MAKE_CYL_MODELS: create cylindrical models using netgen</li><li><a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>	MK_IMAGE: create eidors image object</li><li><a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>	SPARSE Create sparse matrix (EIDORS overload).</li><li><a href="../../../eidors/solvers/calc_system_mat.html" class="code" title="function system_mat = calc_system_mat( fwd_model, img)">calc_system_mat</a>	CALC_SYSTEM_MAT: calculate FEM system matrix from fwd_model and image</li><li><a href="boundary_shape_function.html" class="code" title="function shape=boundary_shape_function(type,x,y)">boundary_shape_function</a>	BOUNDSHAPEFUNC  Shape functions on the boundary in local coordiantes</li><li><a href="element_d_shape_function.html" class="code" title="function dshape = element_d_shape_function(type,x,y,z)">element_d_shape_function</a>	DELEMSHAPEFUNC</li><li><a href="fem_1st_to_higher_order.html" class="code" title="function [boundary,elems,nodes]=fem_1st_to_higher_order(fwd_model)">fem_1st_to_higher_order</a>	FEM_1ST_TO_HIGH_ORDER:  Modify the FEM for high order FEM called as</li><li><a href="find_electrode_bdy.html" class="code" title="function [bdy_idx, bdy_area] = find_electrode_bdy( bdy, vtx, elec_nodes)">find_electrode_bdy</a>	FIND_ELECTRODE_BDY: find the boundary index area for electrode</li><li><a href="gauss_points.html" class="code" title="function [w,x,y,z]=gauss_points(dim,order)">gauss_points</a>	GAUSS_POINTS</li><li><a href="system_mat_1st_order.html" class="code" title="function s_mat= system_mat_1st_order( fwd_model, img)">system_mat_1st_order</a>	SYSTEM_MAT_1ST_ORDER: SS= system_mat_1st_order( fwd_model, img)</li><li><a href="system_mat_higher_order.html" class="code" title="function [s_mat]=system_mat_higher_order(fwd_model,img)">system_mat_higher_order</a>	Assemble the total stiffness matrix : s_mat.E=At;</li><li><a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>	UNIT_TEST_CMP: compare matrices in eidors output</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="fwd_solve_higher_order.html" class="code" title="function[data] = fwd_solve_higher_order(fwd_model,img)">fwd_solve_higher_order</a>	Solve for voltages (nodes/electrodes) for a forward model.</li><li><a href="jacobian_adjoint_higher_order.html" class="code" title="function J = jacobian_adjoint_higher_order(fwd_model,img)">jacobian_adjoint_higher_order</a>	Find the Jacobian associated with an image (and forward model)</li><li><a href="system_mat_higher_order.html" class="code" title="function [s_mat]=system_mat_higher_order(fwd_model,img)">system_mat_higher_order</a>	Assemble the total stiffness matrix : s_mat.E=At;</li><li><a href="../../../eidors/solvers/forward/tools-beta/calc_error_norms_for_square_domain.html" class="code" title="function [L2_tot_error,H1semi_tot_error,H1_tot_error,I_err,U_errS,U_errM,U_errSM,timing_solver,DOF]=error_2D_squ_CEM(img,eletype,plot_on)">calc_error_norms_for_square_domain</a>	Get forward model of the img and the conductivity per element</li><li><a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>	FWD_SOLVE: calculate data from a fwd_model object and an image</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [Agal,elemstiff]=mc_calc_stiffness(fwd_model,img)</a></li><li><a href="#_sub2" class="code">function [Aw,Az,Ad]=mc_calc_complete(fwd_model)</a></li><li><a href="#_sub3" class="code">function do_unit_test</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [s_mat]=system_mat_higher_order(fwd_model,img)</a>
0002 <span class="comment">%Assemble the total stiffness matrix : s_mat.E=At;</span>
0003 <span class="comment">%M Crabb - 29.06.2012</span>
0004 <span class="comment">%TODO - Sparse assignment of the matrices</span>
0005 <span class="keyword">if</span> ischar(fwd_model) &amp;&amp; strcmp(fwd_model,<span class="string">'UNIT_TEST'</span>); <a href="#_sub3" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0006 
0007 <span class="keyword">if</span> nargin == 1
0008    img= fwd_model;
0009 <span class="keyword">elseif</span>  strcmp(getfield(warning(<span class="string">'query'</span>,<span class="string">'EIDORS:DeprecatedInterface'</span>),<span class="string">'state'</span>),<span class="string">'on'</span>)
0010    warning(<span class="string">'EIDORS:DeprecatedInterface'</span>, <span class="keyword">...</span>
0011       [<span class="string">'Calling SYSTEM_MAT_HIGHER_ORDER with two arguments is deprecated and will cause'</span> <span class="keyword">...</span>
0012        <span class="string">' an error in a future version. First argument ignored.'</span>]);
0013 <span class="keyword">end</span>
0014 fwd_model= img.fwd_model;
0015 
0016 <span class="comment">%Find no. of electrodes and no. of ndoes</span>
0017 elecstruc=fwd_model.electrode; nelecs=size(elecstruc,2);
0018 nodestruc=fwd_model.nodes; nnodes=size(nodestruc,1); 
0019 
0020 <span class="comment">%Test - Point/Complete electrodes. Assume no mixed model so test first elect</span>
0021 <span class="keyword">if</span> isfield(elecstruc,<span class="string">'faces'</span>);
0022    error(<span class="string">'Can''t process faces-type electrodes. See mat_idx_to_electrode for help'</span>);
0023 <span class="keyword">end</span>
0024 <span class="keyword">if</span>(size(elecstruc(1).nodes,2)==1 &amp;&amp; size(elecstruc(1).nodes,1)==1) <span class="comment">%POINT ELECTRODE</span>
0025     <span class="comment">%IF POINT ELECTRODE</span>
0026     [At,elemstiff]=<a href="#_sub1" class="code" title="subfunction [Agal,elemstiff]=mc_calc_stiffness(fwd_model,img)">mc_calc_stiffness</a>(fwd_model,img);
0027 <span class="keyword">else</span> <span class="comment">%COMPLETE ELECTRODE</span>
0028     [Am,elemstiff]=<a href="#_sub1" class="code" title="subfunction [Agal,elemstiff]=mc_calc_stiffness(fwd_model,img)">mc_calc_stiffness</a>(fwd_model,img);
0029     
0030      [Aw,Az,Ad]=<a href="#_sub2" class="code" title="subfunction [Aw,Az,Ad]=mc_calc_complete(fwd_model)">mc_calc_complete</a>(fwd_model);
0031      At=<a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(nnodes+nelecs,nnodes+nelecs);     
0032 <span class="comment">%     [i,j,s] = find(Am);</span>
0033 <span class="comment">%     At=At+sparse(i,j,s,nnodes+nelecs,nnodes+nelecs);</span>
0034 <span class="comment">%     [i,j,s] = find(Az);</span>
0035 <span class="comment">%     At=At+sparse(i,j,s,nnodes+nelecs,nnodes+nelecs);</span>
0036 <span class="comment">%     [i,j,s] = find(Aw);</span>
0037 <span class="comment">%     At=At+sparse(i,j+nnodes,s,nnodes+nelecs,nnodes+nelecs);</span>
0038 <span class="comment">%     At=At+sparse(j+nnodes,i,s,nnodes+nelecs,nnodes+nelecs);</span>
0039 <span class="comment">%     [i,j,s] = find(Ad);</span>
0040 <span class="comment">%     At=At+sparse(i+nnodes,j+nnodes,s,nnodes+nelecs,nnodes+nelecs);</span>
0041     At(1:nnodes,1:nnodes) = Am+Az;
0042     At(1:nnodes,nnodes+1:nnodes+nelecs) = Aw;
0043     At(nnodes+1:nnodes+nelecs,1:nnodes)=Aw';
0044     At(nnodes+1:nnodes+nelecs,nnodes+1:nnodes+nelecs)=Ad;
0045 <span class="keyword">end</span>
0046 
0047 <span class="comment">%Put in structure to be compatibile with eidors</span>
0048 s_mat.E=<a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(At);
0049 
0050 <span class="comment">%Store individual stiffness matrices for Jacobian</span>
0051 s_mat.elemstiff=elemstiff;
0052 <span class="keyword">end</span>
0053 
0054 <span class="comment">%STIFFNESS MATRIX PART</span>
0055 <a name="_sub1" href="#_subfunctions" class="code">function [Agal,elemstiff]=mc_calc_stiffness(fwd_model,img)</a>
0056 <span class="comment">%Stiffness matrix, including piecewise conductivity, for EIT. The second</span>
0057 <span class="comment">%argument is for Jacobian, it gives discretied gradients in element.</span>
0058 
0059 <span class="comment">%If function called only with image, extract forward model</span>
0060 <span class="keyword">if</span>(nargin==1)
0061     img=fwd_model; fwd_model=img.fwd_model;
0062 <span class="keyword">end</span>
0063 
0064 <span class="comment">%Cache node structure and find no. of spatial dimensions and nodes</span>
0065 <span class="comment">%Cache element structure and find no. of elements</span>
0066 nodestruc=fwd_model.nodes; nodedim=size(nodestruc,2); nnodes=size(nodestruc,1); 
0067 elemstruc=fwd_model.elems; nelems=size(elemstruc,1);
0068 
0069 <span class="comment">%Find quadrature points/weights for integration by switching between cases</span>
0070 eletype=fwd_model.approx_type; 
0071 <span class="keyword">if</span>(strcmp(eletype,<span class="string">'tri3'</span>))
0072     dim=2; order=0;
0073 <span class="keyword">elseif</span>(strcmp(eletype,<span class="string">'tri6'</span>))
0074     dim=2; order=2;
0075 <span class="keyword">elseif</span>(strcmp(eletype,<span class="string">'tri10'</span>))
0076     dim=2; order=4;
0077 <span class="keyword">elseif</span>(strcmp(eletype,<span class="string">'tet4'</span>))
0078     dim=3; order=0;
0079 <span class="keyword">elseif</span>(strcmp(eletype,<span class="string">'tet10'</span>))
0080     dim=3; order=2;
0081 <span class="keyword">else</span>  
0082     error(<span class="string">'Element type not recognised for integration rules'</span>);
0083 <span class="keyword">end</span>
0084 [weight,xcoord,ycoord,zcoord]=<a href="gauss_points.html" class="code" title="function [w,x,y,z]=gauss_points(dim,order)">gauss_points</a>(dim,order);
0085 
0086 <span class="comment">%Find derivative of shape function on domain element</span>
0087 <span class="keyword">for</span> kk=size(weight,2):-1:1
0088     dphi(:,:,kk) = <a href="element_d_shape_function.html" class="code" title="function dshape = element_d_shape_function(type,x,y,z)">element_d_shape_function</a>(eletype,xcoord(kk),ycoord(kk),zcoord(kk));
0089 <span class="keyword">end</span>
0090 
0091 <span class="comment">%Initialise global stiffness matrix</span>
0092 <span class="comment">%Agal=sparse(nnodes,nnodes);</span>
0093 
0094 <span class="comment">%Loop over the elements and calculate local Am matrix</span>
0095 <span class="keyword">for</span> i=nelems:-1:1
0096     <span class="comment">%Find the list of node numbers for each element</span>
0097     eleminodelist=elemstruc(i,:);
0098     
0099     <span class="comment">%List by row of coordinate on the element</span>
0100     thise = nodestruc(eleminodelist,:);
0101     
0102     <span class="comment">%Find the Jacobian of the mapping in 2D and 3D</span>
0103     <span class="keyword">if</span>(nodedim==2); jacobianelem = <span class="keyword">...</span><span class="comment"> %2D Jacobian of mapping</span>
0104             [thise(2,1)-thise(1,1),thise(2,2)-thise(1,2); <span class="keyword">...</span>
0105             thise(3,1)-thise(1,1),thise(3,2)-thise(1,2)];  
0106     <span class="keyword">elseif</span>(nodedim==3); jacobianelem = <span class="keyword">...</span><span class="comment"> %3D Jacobian of mapping</span>
0107             [thise(2,1)-thise(1,1),thise(2,2)-thise(1,2),thise(2,3)-thise(1,3); <span class="keyword">...</span>
0108             thise(3,1)-thise(1,1),thise(3,2)-thise(1,2),thise(3,3)-thise(1,3); <span class="keyword">...</span>
0109             thise(4,1)-thise(1,1),thise(4,2)-thise(1,2),thise(4,3)-thise(1,3)];
0110     <span class="keyword">end</span>
0111     
0112     <span class="comment">%Find the magnitude of the Jacobian of the mapping</span>
0113     <span class="comment">% magjacelem=det(jacobianelem);</span>
0114     magjacelem=abs(det(jacobianelem));
0115 
0116     <span class="comment">%Initialise and find elemental stiffness matrices</span>
0117     Ammat=0;
0118     <span class="keyword">for</span> kk=1:size(weight,2)
0119 <span class="comment">%         Ammat = Ammat + weight(kk)* ...</span>
0120 <span class="comment">%             (jacobianelem\dphi(:,:,kk))'* ...</span>
0121 <span class="comment">%             (jacobianelem\dphi(:,:,kk))*magjacelem;</span>
0122         jdphitemp=jacobianelem\dphi(:,:,kk);
0123         Ammat = Ammat + weight(kk)* <span class="keyword">...</span>
0124             (jdphitemp'*jdphitemp)*magjacelem;
0125     <span class="keyword">end</span>
0126 
0127     <span class="comment">%SPEED UP</span>
0128     <span class="comment">%Can we get system_mat_fields here to speed Jacobian?</span>
0129     
0130     <span class="comment">%Store the Ammat without multiplication of conductivity for Jacobian</span>
0131     elemstiff(i).elemstiff=Ammat;
0132    
0133     <span class="comment">%This is element stiffness matrix (and multiply by its conductivity)</span>
0134 
0135     stiff=Ammat*img.elem_data(i); 
0136     
0137     <span class="comment">%Assemble global stiffness matrix (Silvester's book!!)</span>
0138 <span class="comment">%   Agal(elemstruc(i,:), elemstruc(i,:)) = Agal(elemstruc(i,:), elemstruc(i,:)) + stiff;</span>
0139 <span class="comment">%   [ii,jj]= meshgrid(eleminodelist); ll = length(eleminodelist)^2; %% meshgrid CRAZY SLOW</span>
0140     ll = length(eleminodelist);
0141     ii = eleminodelist(ones(ll,1),:); jj=ii';
0142     idx = (i-1)*ll^2 + (1:ll^2);
0143     AI(idx) = ii(:);
0144     AJ(idx) = jj(:);
0145     Aval(idx) = stiff(:); 
0146 
0147 <span class="keyword">end</span>
0148 <span class="comment">%Agal2= sparse(AI, AJ, Aval, nnodes, nnodes); norm(Agal-Agal2,'fro')</span>
0149 Agal= <a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(AI, AJ, Aval, nnodes, nnodes);
0150 <span class="keyword">end</span>
0151 
0152 <span class="comment">%COMPLETE ELECTRODE MATRICES</span>
0153 <a name="_sub2" href="#_subfunctions" class="code">function [Aw,Az,Ad]=mc_calc_complete(fwd_model)</a>
0154 <span class="comment">%Takes a forward model and calculates Az, Aw, Ad for complete electrode</span>
0155 
0156 <span class="comment">%Get the electrode structure, find number of electrodes</span>
0157 <span class="comment">%Get the boundary strucutre, find number of boundaries</span>
0158 <span class="comment">%Get the node structrue, find number of nodes and problem dim</span>
0159 elecstruc=fwd_model.electrode; nelecs=size(elecstruc,2);boundstruc=fwd_model.boundary; nodestruc=fwd_model.nodes; 
0160 nnodes=size(nodestruc,1); nodedim=size(nodestruc,2);
0161 
0162 <span class="comment">%Connect boundary/electrode -Put boundary into old matrix strucutre</span>
0163 <span class="comment">%for i=nbounds:-1:1</span>
0164 <span class="comment">%    boundstrucold(i,:)=boundstruc(i).nodes;</span>
0165 <span class="comment">%end</span>
0166 
0167 <span class="comment">%Find quadrature points/weights for integration by switching between cases</span>
0168 eletype=fwd_model.approx_type; 
0169 <span class="keyword">if</span>(strcmp(eletype,<span class="string">'tri3'</span>))
0170     dim=1; order=2;
0171 <span class="keyword">elseif</span>(strcmp(eletype,<span class="string">'tri6'</span>))
0172     dim=1; order=4;
0173 <span class="keyword">elseif</span>(strcmp(eletype,<span class="string">'tri10'</span>))
0174     dim=1; order=6;
0175 <span class="keyword">elseif</span>(strcmp(eletype,<span class="string">'tet4'</span>))
0176     dim=2; order=2;
0177 <span class="keyword">elseif</span>(strcmp(eletype,<span class="string">'tet10'</span>))
0178     dim=2; order=4;
0179 <span class="keyword">else</span>  
0180     error(<span class="string">'Element type not recognised for integration rules'</span>);
0181 <span class="keyword">end</span>
0182 [weight,xcoord,ycoord]=<a href="gauss_points.html" class="code" title="function [w,x,y,z]=gauss_points(dim,order)">gauss_points</a>(dim,order);
0183 
0184 <span class="comment">%Find shape function on boundary element</span>
0185 <span class="keyword">for</span> kk=size(weight,2):-1:1
0186     phi(:,kk) = <a href="boundary_shape_function.html" class="code" title="function shape=boundary_shape_function(type,x,y)">boundary_shape_function</a>(eletype,xcoord(kk),ycoord(kk))';
0187 <span class="keyword">end</span>
0188 
0189 <span class="comment">%1. Initialise global Az/Aw/Ad matrices and assemble a la Silvester</span>
0190 Az=<a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(nnodes,nnodes); <span class="comment">%sparse updating non zero slow</span>
0191 Aw=zeros(nnodes,nelecs); Ad=zeros(nelecs,nelecs);
0192 
0193 <span class="comment">%Loop over the electrodes</span>
0194 <span class="keyword">for</span> ke=1:nelecs    
0195     <span class="comment">%The boundary numbers and areas, outputs rows of mdl.boundary of electrode</span>
0196     [bdy_idx,bdy_area]=<a href="find_electrode_bdy.html" class="code" title="function [bdy_idx, bdy_area] = find_electrode_bdy( bdy, vtx, elec_nodes)">find_electrode_bdy</a>(boundstruc(:,1:nodedim),nodestruc,elecstruc(ke).nodes);
0197     
0198     <span class="comment">%Store boundary numbers, and corresponding areas</span>
0199     boundidx_ke=bdy_idx; area_ke=bdy_area;
0200     
0201     <span class="comment">%Find contact impedance of electrode</span>
0202     elecimped=elecstruc(ke).z_contact;   
0203            
0204     <span class="comment">%Find total electrode area (absolute values)</span>
0205     elecarea=0;
0206     <span class="keyword">for</span> i=1:size(area_ke,2)
0207         elecarea = elecarea + abs(area_ke(i));
0208     <span class="keyword">end</span>
0209     
0210     <span class="comment">%Form the matrix Ad</span>
0211     Ad(ke,ke)=elecarea/elecimped; 
0212     
0213     
0214     <span class="comment">%Loop over boundarys and calculate Aw/Az matrices</span>
0215     <span class="keyword">for</span> ii=1:length(boundidx_ke)
0216         <span class="comment">%List by row of coordinates of on the boundaryNodal coordinates on the boundary</span>
0217         thisb=nodestruc(boundstruc(boundidx_ke(ii),:),:);
0218     
0219         <span class="comment">%Find the magnitude Jacobian of the mapping in 2D/3D</span>
0220         <span class="comment">%NB:Scalings are consistent with reference element shape</span>
0221         <span class="keyword">if</span>(nodedim==2)
0222             <span class="comment">%Jacobian = 0.5*|(x2-x1)| (x1,x2 vector of coords)</span>
0223             diff21=thisb(2,:)-thisb(1,:);
0224             magjacbound=0.5*sqrt(diff21(1)^2+diff21(2)^2);
0225         <span class="keyword">elseif</span>(nodedim==3)
0226             <span class="comment">%Jacobian = |(x3-x1)x(x3-x2)| (x1,x2,x3 vector of coords)</span>
0227             diffprod=cross(thisb(3,:)-thisb(1,:),thisb(3,:)-thisb(2,:));
0228             magjacbound=sqrt(diffprod(1)^2+diffprod(2)^2+diffprod(3)^2);
0229         <span class="keyword">end</span>
0230 
0231         <span class="comment">%Initialise Azlocmat/Awlocmat and find local matrices</span>
0232         Azmat=0; Awmat=0;
0233         <span class="keyword">for</span> kk=1:size(weight,2)            
0234             temphikk = phi(:,kk);
0235             Azmat = Azmat + weight(kk)* <span class="keyword">...</span>
0236                 (temphikk*temphikk')*magjacbound;
0237             Awmat = Awmat + weight(kk)* <span class="keyword">...</span>
0238                 (phi(:,kk))'*magjacbound;            
0239             <span class="comment">%Azmat = Azmat + weight(kk)* ...</span>
0240             <span class="comment">%    (phi(:,kk))* ...</span>
0241             <span class="comment">%    (phi(:,kk))'*magjacbound;</span>
0242             <span class="comment">%Awmat = Awmat + weight(kk)* ...</span>
0243             <span class="comment">%    (phi(:,kk))'*magjacbound;</span>
0244         <span class="keyword">end</span>         
0245         
0246         <span class="comment">%Node numbers for this boundary</span>
0247         boundnodes=boundstruc(boundidx_ke(ii),:);
0248         
0249         <span class="comment">%Assemble the matrices</span>
0250         Az(boundnodes,boundnodes) = Az(boundnodes,boundnodes)+Azmat/elecimped;
0251         Aw(boundnodes,ke) = Aw(boundnodes,ke) - Awmat'/elecimped;
0252     <span class="keyword">end</span>
0253        
0254 <span class="keyword">end</span>
0255 
0256 <span class="keyword">end</span>
0257 
0258 <a name="_sub3" href="#_subfunctions" class="code">function do_unit_test</a>
0259    <span class="keyword">for</span> i=0:100 ; <span class="keyword">switch</span> i
0260       <span class="keyword">case</span> 0;img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>( <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'c2C2'</span>,16),1);
0261              str = <span class="string">'c2C2'</span>;
0262              tst= [4,[1,1,1]/3];
0263              ap0 = <span class="string">'tri3'</span>; ap1 = <span class="string">'tri6'</span>;
0264       <span class="keyword">case</span> 1;img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>( <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'b3cr'</span>,16),1);
0265              str = <span class="string">'b3cr'</span>;
0266              tst= [0.268642857142857,0.028,0.009333333333333,0.028];
0267              ap0 = <span class="string">'tet4'</span>; ap1 = <span class="string">'tet10'</span>;
0268       <span class="keyword">case</span> 2;img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>( <a href="../../../eidors/meshing/netgen/ng_mk_cyl_models.html" class="code" title="function [fmdl,mat_idx] = ng_mk_cyl_models(cyl_shape, elec_pos,elec_shape, extra_ng_code);">ng_mk_cyl_models</a>(1,[6,0.5],.1),1);
0269              str = <span class="string">'ng_mk_cyl1'</span>;
0270              tst= [0.131643427733397,0.000323024820911,0,0];
0271              ap0 = <span class="string">'tet4'</span>; ap1 = <span class="string">'tet10'</span>;
0272       <span class="keyword">case</span> 3;img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>( <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'d3cr'</span>,16),1);
0273              str = <span class="string">'d3cr'</span>;
0274              tst= [0.11125, 0.01, 0.003333333333333,0.01];
0275              ap0 = <span class="string">'tet4'</span>; ap1 = <span class="string">'tet10'</span>;
0276       <span class="keyword">case</span> 4;img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>( <a href="../../../eidors/meshing/netgen/ng_mk_cyl_models.html" class="code" title="function [fmdl,mat_idx] = ng_mk_cyl_models(cyl_shape, elec_pos,elec_shape, extra_ng_code);">ng_mk_cyl_models</a>([1,1,.1],[6,0.5],.1),1);
0277              str = <span class="string">'ng_mk_cyl2'</span>;
0278              tst= [0.061014587493642, 0.000551387020511, 0, 0];
0279              ap0 = <span class="string">'tet4'</span>; ap1 = <span class="string">'tet10'</span>;
0280       <span class="keyword">case</span> 5;<span class="keyword">break</span>
0281       <span class="keyword">end</span>
0282 
0283       img.fwd_model.approx_type = ap0;
0284       S1= <a href="system_mat_1st_order.html" class="code" title="function s_mat= system_mat_1st_order( fwd_model, img)">system_mat_1st_order</a>( img );
0285       Sl= <a href="system_mat_higher_order.html" class="code" title="function [s_mat]=system_mat_higher_order(fwd_model,img)">system_mat_higher_order</a>( img );
0286       <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>([<span class="string">'Linear '</span>,str], S1.E, Sl.E, 1e-13) 
0287 
0288       img.fwd_model.approx_type = ap1;
0289       img.fwd_model.system_mat = @<a href="system_mat_higher_order.html" class="code" title="function [s_mat]=system_mat_higher_order(fwd_model,img)">system_mat_higher_order</a>;
0290       [img.fwd_model.boundary,img.fwd_model.elems,img.fwd_model.nodes] = <span class="keyword">...</span>
0291             <a href="fem_1st_to_higher_order.html" class="code" title="function [boundary,elems,nodes]=fem_1st_to_higher_order(fwd_model)">fem_1st_to_higher_order</a>(img.fwd_model);
0292       Sh= <a href="../../../eidors/solvers/calc_system_mat.html" class="code" title="function system_mat = calc_system_mat( fwd_model, img)">calc_system_mat</a>( img );
0293       <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>([<span class="string">'Linear '</span>,str], Sh.E(1,1:4), tst, 1e-13) 
0294    <span class="keyword">end</span>
0295 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 30-Dec-2022 20:46:51 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>
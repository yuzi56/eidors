<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of jacobian_movement</title>
  <meta name="keywords" content="jacobian_movement">
  <meta name="description" content="JACOBIAN_MOVEMENT   Computes the Jacobian matrix for conductivity and">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">eidors</a> &gt; <a href="../index.html">solvers</a> &gt; <a href="index.html">forward</a> &gt; jacobian_movement.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/solvers/forward&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>jacobian_movement
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>JACOBIAN_MOVEMENT   Computes the Jacobian matrix for conductivity and</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function J = jacobian_movement(fwd_model, img) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> JACOBIAN_MOVEMENT   Computes the Jacobian matrix for conductivity and
 electrode movement variables in 3D EIT.
 Args:     fwd_model - the EIDORS object forward model
            img - the image background conductivity

 fwd_model.conductivity_jacobian - function to calculate conductivity
                                   Jacobian (defaults to jacobian_adjoint)

 Returns:          J - the Jacobian matrix [Jc, Jm]

 WARNING: THIS CODE IS EXPERIMENTAL AND GIVES PROBLEMS
 SEE: Camille Gomez-Laberge, Andy Adler
 Direct EIT Jacobian calculations for conductivity change
  and electrode movement,  Physiol. Meas., 29:S89-S99, 208</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG eidors progress and status messages</li><li><a href="../../../eidors/models/mdl_normalize.html" class="code" title="function out = mdl_normalize(mdl, val)">mdl_normalize</a>	MDL_NORMALIZE Check or set the normalize_measurements flag on a model.</li><li><a href="../../../eidors/models/mk_coarse_fine_mapping.html" class="code" title="function [mapping, outside] = mk_coarse_fine_mapping(varargin)">mk_coarse_fine_mapping</a>	MK_COARSE_FINE_MAPPING: create a mapping matrix from coarse to fine FEM</li><li><a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="../../../eidors/models/mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>	MK_GRID_MODEL: Create reconstruction model on pixelated grid</li><li><a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>	MK_IMAGE: create eidors image object</li><li><a href="../../../eidors/models/mk_library_model.html" class="code" title="function out = mk_library_model(shape,elec_pos,elec_shape,maxsz,nfft,scale)">mk_library_model</a>	MK_LIBRARY_MODEL - FEM models based on library shapes</li><li><a href="../../../eidors/models/mk_stim_patterns.html" class="code" title="function [stim, meas_sel]= mk_stim_patterns(n_elec, n_rings, inj, meas, options, amplitude)">mk_stim_patterns</a>	MK_STIM_PATTERNS: create an EIDORS stimulation pattern structure</li><li><a href="../../../eidors/models/select_imdl.html" class="code" title="function inv_mdl= select_imdl( mdl, options )">select_imdl</a>	SELECT_IMDL: select pre-packaged inverse model features</li><li><a href="../../../eidors/models/shape_library.html" class="code" title="function out = shape_library(action, shape, varargin)">shape_library</a>	SHAPE_LIBRARY Common shapes for models</li><li><a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>	SPARSE Create sparse matrix (EIDORS overload).</li><li><a href="../../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>	CALC_JACOBIAN: calculate jacobian from an inv_model</li><li><a href="../../../eidors/solvers/calc_system_mat.html" class="code" title="function system_mat = calc_system_mat( fwd_model, img)">calc_system_mat</a>	CALC_SYSTEM_MAT: calculate FEM system matrix from fwd_model and image</li><li><a href="fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>	FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)</li><li><a href="jacobian_adjoint.html" class="code" title="function J= jacobian_adjoint( fwd_model, img)">jacobian_adjoint</a>	JACOBIAN_ADJOINT: J= jacobian_adjoint( img )</li><li><a href="jacobian_movement.html" class="code" title="function J = jacobian_movement(fwd_model, img)">jacobian_movement</a>	JACOBIAN_MOVEMENT   Computes the Jacobian matrix for conductivity and</li><li><a href="jacobian_movement_perturb.html" class="code" title="function J= jacobian_movement_perturb( fwd_model, img)">jacobian_movement_perturb</a>	JACOBIAN_MOVEMENT_PERTURB: J= jacobian_movement_perturb( img )</li><li><a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>	FWD_SOLVE: calculate data from a fwd_model object and an image</li><li><a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>	INV_SOLVE: calculate imag from an inv_model and data</li><li><a href="../../../eidors/solvers/inverse/prior_movement.html" class="code" title="function Reg= prior_movement( inv_model );">prior_movement</a>	PRIOR_MOVEMENT calculate image prior</li><li><a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>	UNIT_TEST_CMP: compare matrices in eidors output</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/deprecated/calc_move_jacobian.html" class="code" title="function J = calc_move_jacobian(varargin)">calc_move_jacobian</a>	CALC_MOVE_JACOBIAN   Computes the Jacobian matrix for conductivity and</li><li><a href="../../../eidors/models/select_imdl.html" class="code" title="function inv_mdl= select_imdl( mdl, options )">select_imdl</a>	SELECT_IMDL: select pre-packaged inverse model features</li><li><a href="jacobian_movement.html" class="code" title="function J = jacobian_movement(fwd_model, img)">jacobian_movement</a>	JACOBIAN_MOVEMENT   Computes the Jacobian matrix for conductivity and</li><li><a href="jacobian_movement_2p5d_1st_order.html" class="code" title="function J = jacobian_movement_2p5d_1st_order( fwd_model, img)">jacobian_movement_2p5d_1st_order</a>	JACOBIAN_MOVEMENT_2P5D: J = jacobian_movement_2p5d_1st_order( img )</li><li><a href="../../../eidors/solvers/inverse/inv_solve_core.html" class="code" title="function img= inv_solve_core( inv_model, data0, data1);">inv_solve_core</a>	INV_SOLVE_CORE Solver using a generic iterative algorithm</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function Ce= connectivity_matrix( pp );</a></li><li><a href="#_sub2" class="code">function [Vc, Re] = Vc_Re_matrices( pp, fwd_model, s_mat );</a></li><li><a href="#_sub3" class="code">function J= nodes_to_stim_jacobian( delV, fwd_model, pp )</a></li><li><a href="#_sub4" class="code">function Jc = calc_conductivity_jacobian(pp, fwd_model, img);</a></li><li><a href="#_sub5" class="code">function Jm = calc_movement_jacobian(pp, fwd_model, img)</a></li><li><a href="#_sub6" class="code">function delVm=  calc_delVm( elec_nodes_array, pp, fwd_model, img, colidx, Re_Ce, cond_Ce_Vc)</a></li><li><a href="#_sub7" class="code">function SS= calc_unconnected_system_mat( fwd_model, img)</a></li><li><a href="#_sub8" class="code">function do_unit_test;</a></li><li><a href="#_sub9" class="code">function unit_test_compare_approaches</a></li><li><a href="#_sub10" class="code">function unit_test_matrix_derivatives</a></li><li><a href="#_sub11" class="code">function unit_test_diff_jacobian_b2C_const_cond</a></li><li><a href="#_sub12" class="code">function unit_test_diff_jacobian_n3r2_const_cond</a></li><li><a href="#_sub13" class="code">function unit_test_diff_jacobian_b2C_rand_cond</a></li><li><a href="#_sub14" class="code">function unit_test_diff_jacobian_n3r2_rand_cond</a></li><li><a href="#_sub15" class="code">function unit_test_3d_inv_solve1</a></li><li><a href="#_sub16" class="code">function unit_test_3d_inv_solve2</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function J = jacobian_movement(fwd_model, img)</a>
0002 <span class="comment">% JACOBIAN_MOVEMENT   Computes the Jacobian matrix for conductivity and</span>
0003 <span class="comment">% electrode movement variables in 3D EIT.</span>
0004 <span class="comment">% Args:     fwd_model - the EIDORS object forward model</span>
0005 <span class="comment">%            img - the image background conductivity</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% fwd_model.conductivity_jacobian - function to calculate conductivity</span>
0008 <span class="comment">%                                   Jacobian (defaults to jacobian_adjoint)</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% Returns:          J - the Jacobian matrix [Jc, Jm]</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% WARNING: THIS CODE IS EXPERIMENTAL AND GIVES PROBLEMS</span>
0013 <span class="comment">% SEE: Camille Gomez-Laberge, Andy Adler</span>
0014 <span class="comment">% Direct EIT Jacobian calculations for conductivity change</span>
0015 <span class="comment">%  and electrode movement,  Physiol. Meas., 29:S89-S99, 208</span>
0016 
0017 <span class="comment">% (C) 2007, Camille Gomez-Laberge and Andy Adler.</span>
0018 <span class="comment">%  License: GPL version 2 or version 3</span>
0019 <span class="comment">% $Id: jacobian_movement.m 5196 2016-03-04 07:12:05Z alistair_boyle $</span>
0020 
0021 <span class="keyword">if</span> ischar(fwd_model) &amp;&amp; strcmp(fwd_model,<span class="string">'UNIT_TEST'</span>); do_unit_test; <span class="keyword">return</span> ; <span class="keyword">end</span>
0022 
0023 <span class="keyword">if</span> nargin == 1
0024    img= fwd_model;
0025 <span class="keyword">elseif</span>  strcmp(getfield(warning(<span class="string">'query'</span>,<span class="string">'EIDORS:DeprecatedInterface'</span>),<span class="string">'state'</span>),<span class="string">'on'</span>)
0026    warning(<span class="string">'EIDORS:DeprecatedInterface'</span>, <span class="keyword">...</span>
0027       [<span class="string">'Calling JACOBIAN_MOVEMENT with two arguments is deprecated and will cause'</span> <span class="keyword">...</span>
0028        <span class="string">' an error in a future version. First argument ignored.'</span>]);
0029    warning off EIDORS:DeprecatedInterface
0030 
0031 <span class="keyword">end</span>
0032 fwd_model= img.fwd_model;
0033 
0034 
0035 <span class="comment">% System matrix and its parameters</span>
0036 pp = <a href="fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>( fwd_model, <span class="string">'skip_VOLUME'</span> );
0037 pp.dfact = factorial(pp.n_dims);
0038 pp.DEBUG = 0;
0039 <span class="keyword">if</span> pp.DEBUG
0040     pp.ss_mat = <a href="#_sub7" class="code" title="subfunction SS= calc_unconnected_system_mat( fwd_model, img)">calc_unconnected_system_mat</a>( fwd_model, img);
0041     pp.fwd_meas =<a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>( fwd_model, img);
0042 <span class="keyword">end</span>
0043 
0044 <span class="comment">%Tensor product for conductivity matrix %MC 25/05/2012</span>
0045 I_nd=speye(pp.n_dims+1); 
0046 sigma_mat=spdiags(img.elem_data,0,pp.n_elem,pp.n_elem);
0047 pp.kron_cond=kron(sigma_mat,I_nd);
0048 
0049 pp.Ce= <a href="#_sub1" class="code" title="subfunction Ce= connectivity_matrix( pp );">connectivity_matrix</a>( pp );
0050 s_mat= <a href="../../../eidors/solvers/calc_system_mat.html" class="code" title="function system_mat = calc_system_mat( fwd_model, img)">calc_system_mat</a>( img );
0051 [pp.Vc, pp.Re] = <a href="#_sub2" class="code" title="subfunction [Vc, Re] = Vc_Re_matrices( pp, fwd_model, s_mat );">Vc_Re_matrices</a>( pp, fwd_model, s_mat.E );
0052 
0053 <span class="keyword">if</span> isfield(fwd_model,<span class="string">'conductivity_jacobian'</span>)
0054    img.fwd_model.jacobian = fwd_model.conductivity_jacobian;
0055    Jc= <a href="../../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>( img );
0056 <span class="keyword">else</span>
0057    img.fwd_model = <a href="../../../eidors/models/mdl_normalize.html" class="code" title="function out = mdl_normalize(mdl, val)">mdl_normalize</a>(fwd_model, 0); <span class="comment">% we normalize on our own</span>
0058    Jc = <a href="jacobian_adjoint.html" class="code" title="function J= jacobian_adjoint( fwd_model, img)">jacobian_adjoint</a>(img);
0059 <span class="comment">%    Jc = calc_conductivity_jacobian(pp, fwd_model, img);</span>
0060 <span class="keyword">end</span>
0061 
0062 
0063 Jm = <a href="#_sub5" class="code" title="subfunction Jm = calc_movement_jacobian(pp, fwd_model, img)">calc_movement_jacobian</a>(pp, fwd_model, img);
0064 J=[Jc,Jm];
0065 
0066 <span class="keyword">if</span> pp.normalize
0067     data= <a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>( img );
0068     J= J ./ (data.meas(:)*ones(1,size(J,2)));
0069 <span class="keyword">end</span>
0070 
0071 
0072 
0073 <span class="comment">% Define the element connectivity matrix Ce</span>
0074 <a name="_sub1" href="#_subfunctions" class="code">function Ce= connectivity_matrix( pp );</a>
0075 lengthX = (pp.n_dims+1)*pp.n_elem;
0076 <span class="comment">%%%%%lengthY = pp.n_node; %MC 11/05/2012</span>
0077 lengthY=size(pp.N2E,2);
0078 Xidx = pp.ELEM(:);
0079 Yidx = ones(lengthX, 1);
0080 Ce = <a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(1:lengthX, Xidx, Yidx, lengthX, lengthY);
0081 
0082 
0083 
0084 <span class="comment">% Calculate fwd_solution and Impedance mapper matrices</span>
0085 <a name="_sub2" href="#_subfunctions" class="code">function [Vc, Re] = Vc_Re_matrices( pp, fwd_model, s_mat );</a>
0086 <span class="comment">% Define the stimulation matrix Vc for each node I, and pattern</span>
0087 <span class="comment">% Ground node is never excited; remove it from the index</span>
0088 <span class="comment">%%%%%%nodeidx = 1:pp.n_node; %MC 11/05/2012</span>
0089 nodeidx = 1:size(s_mat);
0090 nodeidx( fwd_model.gnd_node ) = [];
0091 
0092 <span class="comment">% The stimulation matrix Vc is the voltage at each node (row) for a</span>
0093 <span class="comment">% stimulation (column)</span>
0094 Vc = zeros(pp.n_node, pp.n_stim);
0095 Vc(nodeidx, :) = s_mat(nodeidx, nodeidx) \ pp.QQ(nodeidx,:);
0096 
0097 <span class="comment">% Define the electrode resistance matrix Re</span>
0098 <span class="comment">% Calculate the resistance between electrodes (row) and all nodes (col)</span>
0099 <span class="comment">% N2E matrix maps each electrode to its node(s); we exclude GND</span>
0100 Re = zeros(pp.n_elec, pp.n_node);
0101 Re(:, nodeidx) = pp.N2E(:, nodeidx) / s_mat(nodeidx, nodeidx);
0102 
0103 <span class="comment">% FIXME: why do we calculate the negative??</span>
0104 Re = -Re;
0105 
0106 
0107 
0108 <span class="comment">% Calculate Meas jacobian from derivative on nodes</span>
0109 <span class="comment">% Input delVc</span>
0110 <span class="comment">% Ouput J</span>
0111 <a name="_sub3" href="#_subfunctions" class="code">function J= nodes_to_stim_jacobian( delV, fwd_model, pp )</a>
0112 
0113 sz_out= size(delV,3);
0114 <span class="comment">% Define the conductivity Jacobian Jc</span>
0115 J = zeros(pp.n_meas, sz_out);
0116 <span class="comment">% Calculate the Jacobian columns for each stimulation pattern</span>
0117 rowidx = 0;
0118 <span class="keyword">for</span> j = 1:pp.n_stim
0119     <span class="comment">% Get the measurement pattern for the stimulation pattern j</span>
0120     meas_pattern = fwd_model.stimulation(j).meas_pattern;
0121     n_measj = size(meas_pattern, 1);
0122     <span class="comment">% Extract the voltage sensitivity for electrode j</span>
0123     delVcj = reshape( delV(:,j,:), pp.n_elec, sz_out);
0124     <span class="comment">% Calculate sensitivity block for measurements during stimulation j</span>
0125     J(rowidx+(1:n_measj), :) = meas_pattern*delVcj;
0126     rowidx = rowidx+n_measj;
0127 <span class="keyword">end</span>
0128 
0129 
0130 
0131 <span class="comment">% CONDUCTIVITY JACOBIAN (Based on Andy Adler's 1996 algorithms)</span>
0132 <span class="comment">% Define the voltage sensitivity delVc on electrode I, for stimulation</span>
0133 <span class="comment">% pattern J, for a change in conductivity of element K as a 3D array</span>
0134 <a name="_sub4" href="#_subfunctions" class="code">function Jc = calc_conductivity_jacobian(pp, fwd_model, img);</a>
0135 delVc = zeros(pp.n_elec, pp.n_stim, pp.n_elem);
0136 <span class="comment">% Calculate the values for the voltage sensitivity for each element</span>
0137 <span class="keyword">for</span> k = 1:pp.n_elem
0138     <span class="keyword">if</span> ~mod(k,500)
0139         fprintf(<span class="string">'   JC: element # %d\n'</span>,k);
0140     <span class="keyword">end</span>
0141     <span class="comment">% Extract the coordinates of the element's four nodes</span>
0142     Ae = pp.NODE(:,pp.ELEM(:,k))';
0143     <span class="comment">% Augment Ae by adding a column of ones to invert</span>
0144     Ae = inv([ones(pp.n_dims+1,1), Ae]);
0145     <span class="comment">% Define Be as the matrix Ae with row 1 deleted</span>
0146     Be = Ae(2:pp.n_dims+1,:);
0147     <span class="comment">% Calculate the system submatrix subSe for the element i</span>
0148     <span class="comment">%%%%%subSe = 2*Be'*Be/pp.dfact/abs(det(Ae)); %MC 11/05/2012</span>
0149     subSe = Be'*Be/pp.dfact/abs(det(Ae)); 
0150     <span class="comment">% Select the same submatrix of Ce</span>
0151     subidx = (pp.n_dims+1)*(k-1)+1 : (pp.n_dims+1)*k;
0152     <span class="comment">% The system submatrix is given by the product</span>
0153     <span class="keyword">if</span> ~pp.DEBUG
0154         delVc(:,:,k) = pp.Re * pp.Ce(subidx,:)' * subSe * pp.Ce(subidx,:)<span class="keyword">...</span>
0155             * pp.Vc;
0156     <span class="keyword">else</span>
0157         sz= (pp.n_dims+1)*pp.n_elem;
0158         delSe = <a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(sz,sz);
0159         se_idx= (pp.n_dims+1)*k+(-pp.n_dims : 0);
0160         delSe(se_idx, se_idx) = subSe;
0161 
0162         delVc(:,:,k) = pp.Re * pp.Ce' * delSe * pp.Ce * pp.Vc;
0163 
0164         <span class="keyword">if</span> mod(k,50) == 0
0165             delta=1e-6;
0166             img_delta = img;
0167             img_delta.elem_data(k) = img_delta.elem_data(k) + delta;
0168             ss_mat_delta= <a href="#_sub7" class="code" title="subfunction SS= calc_unconnected_system_mat( fwd_model, img)">calc_unconnected_system_mat</a>( fwd_model, img_delta);
0169             delSe_pert = (ss_mat_delta - pp.ss_mat) / delta;
0170 
0171             <span class="keyword">if</span> norm(delSe -delSe_pert ,1) &gt; 1e-6
0172                 <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'delSe calc wrong'</span>,1);
0173             <span class="keyword">end</span>
0174         <span class="keyword">end</span>
0175     <span class="keyword">end</span>
0176 
0177 <span class="keyword">end</span>
0178 Jc= <a href="#_sub3" class="code" title="subfunction J= nodes_to_stim_jacobian( delV, fwd_model, pp )">nodes_to_stim_jacobian</a>( delVc, fwd_model, pp );
0179 
0180 
0181 
0182 <span class="comment">% MOVEMENT JACOBIAN</span>
0183 <a name="_sub5" href="#_subfunctions" class="code">function Jm = calc_movement_jacobian(pp, fwd_model, img)</a>
0184 <span class="comment">% The movement Jacobian is defined for each coordinate Jm = [Jmx Jmy Jmz]</span>
0185 <span class="comment">% Define the voltage sensitivity delVm on electrode I, for stimulation</span>
0186 <span class="comment">% pattern J, for a movement of electrode K as a 3D array</span>
0187 delVm = zeros(pp.n_elec, pp.n_stim, pp.n_elec*pp.n_dims);
0188 
0189 <span class="comment">% Precalculate</span>
0190 Re_Ce      = pp.Re * pp.Ce';
0191 cond_Ce_Vc = pp.kron_cond * pp.Ce * pp.Vc;
0192 <span class="keyword">for</span> colidx = 1:pp.n_dims
0193 <span class="comment">%    fprintf('   JM: direction # %d\n',colidx);</span>
0194     <span class="comment">% Calculate the values for the voltage sensitivity for each electrode</span>
0195     <span class="keyword">for</span> k = 1:pp.n_elec
0196         <span class="comment">% Find which elements touch this electrode</span>
0197         elec_nodes = fwd_model.electrode(k).nodes;
0198  
0199         <span class="comment">%for compound electrodes, average jacobian for each node</span>
0200 <span class="comment">%         delVm_part = zeros(pp.n_elec,pp.n_stim);</span>
0201         delVm_part = <a href="#_sub6" class="code" title="subfunction delVm=  calc_delVm( elec_nodes_array, pp, fwd_model, img, colidx, Re_Ce, cond_Ce_Vc)">calc_delVm</a>(elec_nodes(:)',pp,fwd_model,img,colidx,<span class="keyword">...</span>
0202                 Re_Ce, cond_Ce_Vc);
0203 <span class="comment">%         delVm_part = sparse(length(pp.kron_cond),length(pp.kron_cond));</span>
0204 <span class="comment">%         for each_elec_node= elec_nodes(:)';</span>
0205 <span class="comment">%            delVm_part =  delVm_part + ...</span>
0206 <span class="comment">%                 calc_delVm(each_elec_node,pp,fwd_model,img,colidx,...</span>
0207 <span class="comment">%                 Re_Ce, cond_Ce_Vc);</span>
0208 <span class="comment">%         end</span>
0209 <span class="comment">%         delVm_part = Re_Ce * delVm_part * cond_Ce_Vc;</span>
0210         <span class="comment">%%%%% delVm_part = delVm_part/length(elec_nodes); %MC 25/05/2012</span>
0211 <span class="comment">%         delVm_part = delVm_part;</span>
0212 
0213         vm_idx= k + pp.n_elec*(colidx-1);
0214         delVm(:,:,vm_idx) = delVm_part;
0215 
0216         <span class="keyword">if</span> pp.DEBUG
0217             delta=1e-8;
0218             mdl_delta = fwd_model;
0219             mdl_delta.nodes(elec_nodes, colidx) = <span class="keyword">...</span>
0220                 mdl_delta.nodes(elec_nodes, colidx) + delta;
0221             img_delta = img;
0222             img_delta.fwd_model = mdl_delta;
0223             S= <a href="../../../eidors/solvers/calc_system_mat.html" class="code" title="function system_mat = calc_system_mat( fwd_model, img)">calc_system_mat</a>(img_delta); 
0224             S=S.E;
0225 <span class="comment">% FIXME: AA+CG 30/1/12</span>
0226             [Vc_delta] = <a href="#_sub2" class="code" title="subfunction [Vc, Re] = Vc_Re_matrices( pp, fwd_model, s_mat );">Vc_Re_matrices</a>( pp, mdl_delta, S);
0227             delVm_pert = pp.N2E*(Vc_delta - pp.Vc) / delta;
0228             nn = norm(delVm_part - delVm_pert,1 ); <span class="comment">% WHY NEGATIVE?</span>
0229 
0230             <span class="comment">%%%%% if nn &gt; 5e-5 ; keyboard; end %MC 25/05/2012</span>
0231             <span class="keyword">if</span> nn &gt; 5e-3 ; keyboard; <span class="keyword">end</span>
0232 
0233         <span class="keyword">end</span>
0234     <span class="keyword">end</span>
0235 <span class="keyword">end</span>
0236 Jm= <a href="#_sub3" class="code" title="subfunction J= nodes_to_stim_jacobian( delV, fwd_model, pp )">nodes_to_stim_jacobian</a>( delVm, fwd_model, pp );
0237 
0238 
0239 
0240 <a name="_sub6" href="#_subfunctions" class="code">function delVm=  calc_delVm( elec_nodes_array, pp, fwd_model, img, colidx, Re_Ce, cond_Ce_Vc)</a>
0241 I = []; J=[]; S= [];
0242 <span class="keyword">for</span> elec_nodes= elec_nodes_array(:)';
0243 [rowidx, elemidx] = find(pp.ELEM == elec_nodes);
0244 <span class="comment">% Define the system sensitivity matrix to movement delSm</span>
0245 sz= (pp.n_dims+1)*pp.n_elem;
0246 <span class="comment">%delSm = sparse(sz,sz);</span>
0247 <span class="comment">% For each touching element, calculate the perturbation</span>
0248 jcount = 1;
0249 <span class="keyword">for</span> j = elemidx'
0250     <span class="comment">% Extract the coordinates of the element's four nodes</span>
0251     Ae = pp.NODE(:,pp.ELEM(:, j))';
0252     <span class="comment">% Define the invertible matrix P: augment Ae by adding a</span>
0253     <span class="comment">% column of ones to invert</span>
0254     P = [ones(pp.n_dims+1,1), Ae];
0255     Ae = inv(P);
0256     absdetAe = abs(det(Ae));
0257     <span class="comment">% Define Be as the matrix Ae with row 1 deleted</span>
0258     Be = Ae(2:pp.n_dims+1,:);
0259     <span class="comment">% For this coordinate, perturb P by [rowidx,colidx], which are</span>
0260     <span class="comment">% our paper's perturbation vectors [a,b]</span>
0261     a = zeros(pp.n_dims+1,1);
0262     b = a;
0263     a(rowidx(jcount)) = 1;
0264     jcount = jcount + 1;
0265     b(colidx+1) = 1;
0266     <span class="comment">% Calculate the system submatrix subSm for the element j by</span>
0267     <span class="comment">% asymmetric perturbation of the electrode node k</span>
0268     deldetAe =   1/absdetAe*b'*Ae*a;
0269     delBe = -Ae*a*b'*Ae;
0270     delBe = delBe(2:pp.n_dims+1,:);
0271     <span class="comment">%%%%%subSm = 2/pp.dfact*(...</span>
0272     <span class="comment">%%%%%    deldetAe*Be'*Be + ...</span>
0273     <span class="comment">%%%%%    delBe'*Be/absdetAe + ...</span>
0274     <span class="comment">%%%%%    Be'*delBe/absdetAe); %MC 11/05/2012</span>
0275     subSm = 1/pp.dfact*(<span class="keyword">...</span>
0276         deldetAe*Be'*Be + <span class="keyword">...</span>
0277         delBe'*Be/absdetAe + <span class="keyword">...</span>
0278         Be'*delBe/absdetAe);
0279 
0280     <span class="keyword">if</span> pp.DEBUG
0281         delta=1e-8;
0282         <span class="comment">%%%%% subSe = 2*Be'*Be/pp.dfact/abs(det(Ae)); %MC 25/05/2012</span>
0283         subSe = Be'*Be/pp.dfact/abs(det(Ae));
0284         d_NODE= pp.NODE;
0285         d_NODE(colidx,elec_nodes) =  d_NODE(colidx,elec_nodes) + delta;
0286         Ae = d_NODE(:,pp.ELEM(:, j))';
0287         Ae = inv( [ones(pp.n_dims+1,1), Ae] );
0288         absdetAe_pert = abs(det(Ae));
0289         deldetAe_pert = (absdetAe_pert - absdetAe) / delta;
0290         <span class="comment">% Define Be as the matrix Ae with row 1 deleted</span>
0291         Be = Ae(2:pp.n_dims+1,:);
0292         <span class="comment">%%%%% subSe_delta = 2*Be'*Be/pp.dfact/abs(det(Ae)); %MC 25/05/2012</span>
0293         subSe_delta = Be'*Be/pp.dfact/abs(det(Ae));
0294         subSm_pert= (subSe_delta - subSe ) / delta;
0295         <span class="keyword">if</span> norm(subSm_pert - subSm,1) &gt; 1e-5
0296             <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'subSm calc wrong'</span>,1);
0297             dd= (subSm_pert - 2/pp.dfact/absdetAe *<span class="keyword">...</span>
0298                 (delBe'*Be + Be'*delBe) )./(Be'*Be);
0299 
0300             fprintf(<span class="string">'colidx=%d, j=%d std=%6.4f &gt;'</span>,<span class="keyword">...</span>
0301                 colidx,j, std(dd(:)));
0302             keyboard
0303             subSm= subSm_pert;
0304         <span class="keyword">end</span>
0305     <span class="keyword">end</span>
0306 
0307     <span class="comment">% Embed subSm into delSm such that subSm(1,1) is the</span>
0308     <span class="comment">% (4j+1,4j+1) element of delSm</span>
0309     se_idx= (pp.n_dims+1)*j+(-pp.n_dims : 0);
0310     <span class="keyword">switch</span> pp.n_dims
0311        <span class="keyword">case</span> 2
0312           Iidx = vertcat(se_idx,se_idx,se_idx);
0313           I = [I Iidx(:)];
0314           J = [J, se_idx,se_idx,se_idx];
0315           
0316        <span class="keyword">case</span> 3
0317           Iidx = vertcat(se_idx,se_idx,se_idx,se_idx);
0318           I = [I Iidx(:)];
0319           J = [J, se_idx,se_idx,se_idx,se_idx];
0320     <span class="keyword">end</span>
0321     S = [S subSm(:)];
0322 <span class="comment">%     delSm(se_idx, se_idx) = subSm;</span>
0323 <span class="keyword">end</span>
0324 <span class="keyword">end</span>
0325 delSm = <a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(I,J,S,sz,sz);
0326 delVm = Re_Ce * delSm * cond_Ce_Vc;
0327 
0328 
0329 <span class="comment">% The system submatrix is given by the product where delSm is</span>
0330 <span class="comment">% non-zero only in submatrices corresponding to touching elements</span>
0331 <span class="comment">%%%%% delVm = pp.Re * pp.Ce' * delSm * pp.Ce * pp.Vc; %MC 25/05/2012</span>
0332 <span class="comment">% delVm = Re_Ce * delSm * cond_Ce_Vc;</span>
0333 <span class="keyword">if</span> pp.DEBUG
0334     delta=1e-8;
0335     mdl_delta = fwd_model;
0336     mdl_delta.nodes(elec_nodes, colidx) = <span class="keyword">...</span>
0337         mdl_delta.nodes(elec_nodes, colidx) + delta;
0338     ss_mat_delta= <a href="#_sub7" class="code" title="subfunction SS= calc_unconnected_system_mat( fwd_model, img)">calc_unconnected_system_mat</a>( mdl_delta, img );
0339      delSm_pert = (ss_mat_delta - pp.ss_mat) / delta;
0340     <span class="comment">% delSe_pert shound be Ce'*delSe*Ce</span>
0341     <span class="keyword">if</span> norm(delSm -delSm_pert ,1) &gt; 1e-5
0342         <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'delSm calc wrong'</span>,1);
0343         <span class="comment">%%%%% delVm = pp.Re * pp.Ce' * delSm_pert * pp.Ce * pp.Vc; %MC 25/05/2012</span>
0344         delVm = pp.Re * pp.Ce' * delSm_pert * pp.kron_cond * pp.Ce * pp.Vc;
0345     
0346         keyboard
0347     <span class="keyword">end</span>
0348 <span class="keyword">end</span>
0349 
0350 
0351 
0352 <a name="_sub7" href="#_subfunctions" class="code">function SS= calc_unconnected_system_mat( fwd_model, img)</a>
0353 <span class="comment">% Calc system matrix for Andy Adler's EIT code</span>
0354 <span class="comment">% fwd_model = forward model</span>
0355 <span class="comment">% img       = image background for system matrix calc</span>
0356 <span class="comment">% s_mat = CC' * SS * conductivites * CC;</span>
0357 <span class="comment">% where:</span>
0358 <span class="comment">%   SS  = Unconnected system Matrix</span>
0359 <span class="comment">%   CC  = Connectivity Matrix</span>
0360 
0361 p= <a href="fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>( fwd_model, <span class="string">'skip_VOLUME'</span> );
0362 
0363 d= p.n_dims+1;
0364 e= p.n_elem;
0365 n= p.n_node;
0366 
0367 SSiidx= floor([0:d*e-1]'/d)*d*ones(1,d) + ones(d*e,1)*(1:d) ;
0368 SSjidx= [1:d*e]'*ones(1,d);
0369 SSdata= zeros(d*e,d);
0370 dfact= (d-1)*(d-2); <span class="comment">% Valid for d&lt;=3</span>
0371 <span class="keyword">for</span> j=1:e
0372     a=  inv([ ones(d,1), p.NODE( :, p.ELEM(:,j) )' ]);
0373     idx= d*(j-1)+1 : d*j;
0374     SSdata(idx,1:d)= a(2:d,:)'*a(2:d,:)/dfact/abs(det(a));
0375 
0376 <span class="keyword">end</span> <span class="comment">%for j=1:ELEMs</span>
0377 idx= 1:e*d;
0378 SS= <a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(SSiidx,SSjidx,SSdata) * <span class="keyword">...</span>
0379     <a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(idx,idx, img.elem_data(ceil(idx/d)) );
0380 
0381 
0382 <a name="_sub8" href="#_subfunctions" class="code">function do_unit_test;</a>
0383    <a href="#_sub9" class="code" title="subfunction unit_test_compare_approaches">unit_test_compare_approaches</a>
0384    <a href="#_sub10" class="code" title="subfunction unit_test_matrix_derivatives">unit_test_matrix_derivatives</a>
0385    <a href="#_sub11" class="code" title="subfunction unit_test_diff_jacobian_b2C_const_cond">unit_test_diff_jacobian_b2C_const_cond</a>
0386    <a href="#_sub12" class="code" title="subfunction unit_test_diff_jacobian_n3r2_const_cond">unit_test_diff_jacobian_n3r2_const_cond</a>
0387    <a href="#_sub13" class="code" title="subfunction unit_test_diff_jacobian_b2C_rand_cond">unit_test_diff_jacobian_b2C_rand_cond</a>
0388    <a href="#_sub14" class="code" title="subfunction unit_test_diff_jacobian_n3r2_rand_cond">unit_test_diff_jacobian_n3r2_rand_cond</a>
0389   <a href="#_sub15" class="code" title="subfunction unit_test_3d_inv_solve1">unit_test_3d_inv_solve1</a>
0390   <a href="#_sub16" class="code" title="subfunction unit_test_3d_inv_solve2">unit_test_3d_inv_solve2</a>
0391    
0392 <a name="_sub9" href="#_subfunctions" class="code">function unit_test_compare_approaches</a>
0393    inv_model = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'d2t2'</span>,16);
0394    img  = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>( inv_model);
0395    fwd_model = inv_model.fwd_model;
0396 
0397    pp = <a href="fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>( fwd_model );
0398    pp.DEBUG = 0;
0399    pp.dfact = factorial(pp.n_dims);
0400    s_mat= <a href="../../../eidors/solvers/calc_system_mat.html" class="code" title="function system_mat = calc_system_mat( fwd_model, img)">calc_system_mat</a>(img );
0401    [pp.Vc, pp.Re] = <a href="#_sub2" class="code" title="subfunction [Vc, Re] = Vc_Re_matrices( pp, fwd_model, s_mat );">Vc_Re_matrices</a>( pp, fwd_model, s_mat.E );
0402    pp.Ce= <a href="#_sub1" class="code" title="subfunction Ce= connectivity_matrix( pp );">connectivity_matrix</a>( pp );
0403 
0404    Jc1= <a href="#_sub4" class="code" title="subfunction Jc = calc_conductivity_jacobian(pp, fwd_model, img);">calc_conductivity_jacobian</a>(pp, fwd_model, img);
0405    Jc2= <a href="jacobian_adjoint.html" class="code" title="function J= jacobian_adjoint( fwd_model, img)">jacobian_adjoint</a>(fwd_model,img);
0406    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Compare J d2t2'</span>, Jc1, Jc2, 1e-13);
0407 
0408    fwd_model.normalize_measurements = 1;
0409    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Compare J norm'</span>, Jc1, Jc2, 1e-13);
0410 
0411 
0412 
0413 <span class="comment">% TEST CODE FOR MATRIX DERIVATIVES</span>
0414 <a name="_sub10" href="#_subfunctions" class="code">function unit_test_matrix_derivatives</a>
0415 
0416 TEST= <span class="string">'d/dt det(X + t*a*b'')'</span>;
0417 d= 1e-8;
0418 X= rand(5);
0419 a=zeros(5,1); a(ceil(5*rand))=1;
0420 b=zeros(5,1); b(ceil(5*rand))=1;
0421 dX_p= (det(X + d*a*b') - det(X) )/d;
0422 dX  = b'*inv(X)*a*det(X);
0423 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(TEST, dX_p,dX,1e-6);
0424 
0425 TEST= <span class="string">'d/dt inv(X + t*a*b'')'</span>;
0426 dX_p= (inv(X + d*a*b') - inv(X) )/d;
0427 dX  = -inv(X)*a*b'*inv(X);
0428 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(TEST, dX_p,dX,1e-5);
0429 
0430 <span class="comment">% TEST d/dt 1/abs(det(X + t*a*b')) = abs(1/det(X+t*a*b'))</span>
0431 <span class="keyword">for</span> i=1:10
0432     TEST = sprintf(<span class="string">'d/dt abs(1/det(X+t*a*b'')) [%02d]'</span>,i);
0433     X= rand(5);
0434     a=zeros(5,1); a(ceil(5*rand))=1;
0435     b=zeros(5,1); b(ceil(5*rand))=1;
0436     dX_p= (1/abs(det(X + d*a*b')) - 1/abs(det(X)) )/d;
0437     dX  = - 1/abs(det(X))*b'*inv(X)*a;
0438     <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(TEST, norm([dX_p-dX]),0, 1e-5*norm(dX));
0439 <span class="keyword">end</span>
0440 
0441 
0442    
0443 <a name="_sub11" href="#_subfunctions" class="code">function unit_test_diff_jacobian_b2C_const_cond</a>
0444    TEST= <span class="string">'J_perturb-J_direct - b2C model (const sigma)'</span>;
0445    mdl3dim = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>( <span class="string">'b2C'</span> );
0446    img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(mdl3dim);
0447    J_pert=<a href="jacobian_movement_perturb.html" class="code" title="function J= jacobian_movement_perturb( fwd_model, img)">jacobian_movement_perturb</a>(img);
0448    J_direct =<a href="jacobian_movement.html" class="code" title="function J = jacobian_movement(fwd_model, img)">jacobian_movement</a>(img);
0449    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(TEST, norm([J_pert-J_direct]),0, 1e-5*norm(J_direct));
0450 
0451    
0452 <a name="_sub12" href="#_subfunctions" class="code">function unit_test_diff_jacobian_n3r2_const_cond</a>
0453    TEST= <span class="string">'J_perturb-J_direct - n3r2 model (const sigma)'</span>;
0454    mdl3dim = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>( <span class="string">'n3r2'</span>, [16,2] );
0455    img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(mdl3dim);
0456    J_pert=<a href="jacobian_movement_perturb.html" class="code" title="function J= jacobian_movement_perturb( fwd_model, img)">jacobian_movement_perturb</a>(img);
0457    J_direct =<a href="jacobian_movement.html" class="code" title="function J = jacobian_movement(fwd_model, img)">jacobian_movement</a>(img);
0458    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(TEST, norm([J_pert-J_direct]),0, 1e-5*norm(J_direct));
0459    
0460 <a name="_sub13" href="#_subfunctions" class="code">function unit_test_diff_jacobian_b2C_rand_cond</a>
0461    TEST= <span class="string">'J_perturb-J_direct - b2C model (rand sigma)'</span>;
0462    mdl3dim = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>( <span class="string">'b2C'</span> );
0463    cond=0.5+rand(size(mdl3dim.fwd_model.elems,1),1);
0464    img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(mdl3dim,cond);
0465    J_direct =<a href="jacobian_movement.html" class="code" title="function J = jacobian_movement(fwd_model, img)">jacobian_movement</a>(img);
0466    J_pert=<a href="jacobian_movement_perturb.html" class="code" title="function J= jacobian_movement_perturb( fwd_model, img)">jacobian_movement_perturb</a>(img);   
0467    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(TEST, norm([J_pert-J_direct]),0, 1e-5*norm(J_direct));
0468    
0469 <a name="_sub14" href="#_subfunctions" class="code">function unit_test_diff_jacobian_n3r2_rand_cond</a>
0470    TEST= <span class="string">'J_perturb-J_direct - n3r2 model (rand sigma)'</span>;
0471    mdl3dim = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>( <span class="string">'n3r2'</span>, [16,2] );
0472    cond=0.5+rand(size(mdl3dim.fwd_model.elems,1),1);
0473    img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(mdl3dim,cond);
0474    J_pert=<a href="jacobian_movement_perturb.html" class="code" title="function J= jacobian_movement_perturb( fwd_model, img)">jacobian_movement_perturb</a>(img);
0475    J_direct =<a href="jacobian_movement.html" class="code" title="function J = jacobian_movement(fwd_model, img)">jacobian_movement</a>(img);
0476    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(TEST, norm([J_pert-J_direct]),0, 1e-5*norm(J_direct));
0477   
0478 <a name="_sub15" href="#_subfunctions" class="code">function unit_test_3d_inv_solve1</a>
0479    mdl3dim = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>( <span class="string">'n3r2'</span>, [16,2] );
0480    img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(mdl3dim);
0481    vh = <a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>( img );
0482    mdl3dim.fwd_model.jacobian = @<a href="jacobian_movement.html" class="code" title="function J = jacobian_movement(fwd_model, img)">jacobian_movement</a>;
0483 
0484    mdl3dim.RtR_prior = @<a href="../../../eidors/solvers/inverse/prior_movement.html" class="code" title="function Reg= prior_movement( inv_model );">prior_movement</a>;
0485 
0486    imgM = <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(mdl3dim, vh, vh);
0487 
0488  <a name="_sub16" href="#_subfunctions" class="code">function unit_test_3d_inv_solve2</a>
0489     fmdl = <a href="../../../eidors/models/mk_library_model.html" class="code" title="function out = mk_library_model(shape,elec_pos,elec_shape,maxsz,nfft,scale)">mk_library_model</a>(<span class="string">'adult_male_16el_lungs'</span>);
0490     [fmdl.stimulation, fmdl.meas_select] = <span class="keyword">...</span>
0491        <a href="../../../eidors/models/mk_stim_patterns.html" class="code" title="function [stim, meas_sel]= mk_stim_patterns(n_elec, n_rings, inj, meas, options, amplitude)">mk_stim_patterns</a>(16,1,[0,1],[0,1],{<span class="string">'no_meas_current'</span>}, 1);
0492     
0493     outline = <a href="../../../eidors/models/shape_library.html" class="code" title="function out = shape_library(action, shape, varargin)">shape_library</a>(<span class="string">'get'</span>,<span class="string">'adult_male'</span>,<span class="string">'boundary'</span>);
0494     
0495     minnode = min(fmdl.nodes);
0496     maxnode = max(fmdl.nodes);
0497     imgsz = [32 32];
0498     
0499     xgrid = linspace(minnode(1),maxnode(1),imgsz(1));
0500     ygrid = linspace(minnode(2),maxnode(2),imgsz(2));
0501     rmdl = <a href="../../../eidors/models/mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>([],xgrid,ygrid);
0502     
0503     <span class="comment">% remove pixels outside the model</span>
0504     x_avg = conv2(xgrid, [1,1]/2,<span class="string">'valid'</span>);
0505     y_avg = conv2(ygrid, [1,1]/2,<span class="string">'valid'</span>);
0506     [x,y] = ndgrid( x_avg, y_avg);
0507     inside = inpolygon(x(:),y(:),outline(:,1),outline(:,2));
0508     ff = find(~inside);
0509     
0510     rmdl.elems([2*ff, 2*ff-1],:)= [];
0511     rmdl.coarse2fine([2*ff, 2*ff-1],:)= [];
0512     rmdl.coarse2fine(:,ff)= [];
0513     rmdl.mk_coarse_fine_mapping.f2c_offset = [0 0 0.5];
0514     rmdl.mk_coarse_fine_mapping.z_depth = 0.25;
0515     
0516     
0517     <span class="comment">% calculate coarse2fine</span>
0518     fmdl.coarse2fine = <a href="../../../eidors/models/mk_coarse_fine_mapping.html" class="code" title="function [mapping, outside] = mk_coarse_fine_mapping(varargin)">mk_coarse_fine_mapping</a>(fmdl,rmdl);
0519     
0520     imdl = <a href="../../../eidors/models/select_imdl.html" class="code" title="function inv_mdl= select_imdl( mdl, options )">select_imdl</a>( fmdl,{<span class="string">'Basic GN dif'</span>});
0521     imdl.rec_model = rmdl;
0522     
0523     img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(imdl,1);
0524    vh = <a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>( img );
0525    imdl.prior_use_fwd_not_rec = 1;
0526    imdl.fwd_model.jacobian = @<a href="jacobian_movement.html" class="code" title="function J = jacobian_movement(fwd_model, img)">jacobian_movement</a>;
0527    imdl.RtR_prior = @<a href="../../../eidors/solvers/inverse/prior_movement.html" class="code" title="function Reg= prior_movement( inv_model );">prior_movement</a>;
0528    imgM = <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vh, vh);
0529</pre></div>
<hr><address>Generated on Fri 30-Dec-2022 20:46:51 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>
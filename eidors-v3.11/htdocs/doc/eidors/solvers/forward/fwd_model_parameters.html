<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of fwd_model_parameters</title>
  <meta name="keywords" content="fwd_model_parameters">
  <meta name="description" content="FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">eidors</a> &gt; <a href="../index.html">solvers</a> &gt; <a href="index.html">forward</a> &gt; fwd_model_parameters.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/solvers/forward&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>fwd_model_parameters
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function param = fwd_model_parameters( fwd_model, opt ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)
   Internal function to extract parameters from a fwd_model
   param.n_elem     =&gt; number of elements
   param.n_elec     =&gt; number of electrodes
   param.n_node     =&gt; number of nodes (vertices)
   param.n_stim     =&gt; number of current stimulation patterns
   param.n_elec     =&gt; number of electrodes
   param.n_dims     =&gt; dimentions (2= 2D, 3=3D)
   param.n_meas     =&gt; number of measurements (total)
   param.boundary   =&gt; FEM boundary
   param.NODE       =&gt; vertex matrix
   param.ELEM       =&gt; connection matrix
   param.QQ         =&gt; Current into each NODE (Neuman Boundary Conditions)
   param.VV         =&gt; Voltage driven into each NODE (Dirichlet BC - only where QQ is NaN)
   param.YY         =&gt; Output Admittance (1/Impedance) of each node current (for each value in QQ)
   param.VOLUME     =&gt; Volume (or area) of each element
   param.normalize  =&gt; difference measurements normalized?
   param.N2E        =&gt; Node to electrode converter
   param.v2meas     =&gt; Convert node voltages to measurements

 If the stimulation patterns has a 'interior_sources' field,
   the node current QQ, is set to this value for this stimulation.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG eidors progress and status messages</li><li><a href="../../../eidors/models/mdl_normalize.html" class="code" title="function out = mdl_normalize(mdl, val)">mdl_normalize</a>	MDL_NORMALIZE Check or set the normalize_measurements flag on a model.</li><li><a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>	SPARSE Create sparse matrix (EIDORS overload).</li><li><a href="find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>	[srf, idx] = find_boundary(simp);</li><li><a href="find_electrode_bdy.html" class="code" title="function [bdy_idx, bdy_area] = find_electrode_bdy( bdy, vtx, elec_nodes)">find_electrode_bdy</a>	FIND_ELECTRODE_BDY: find the boundary index area for electrode</li><li><a href="fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>	FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)</li><li><a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>	EIDORS_CACHE Control eidors caching</li><li><a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>	UNIT_TEST_CMP: compare matrices in eidors output</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/algorithms/left_divide.html" class="code" title="function [V] = left_divide(E,I,tol,~,V)">left_divide</a>	[V] = LEFT_DIVIDE(E,I,tol,pp,V);</li><li><a href="../../../eidors/deprecated/aa_fwd_parameters.html" class="code" title="function param = aa_fwd_parameters( fwd_model )">aa_fwd_parameters</a>	AA_FWD_PARAMETERS: data= aa_fwd_solve( fwd_model, image)</li><li><a href="../../../eidors/deprecated/exponential_covar_prior.html" class="code" title="function Reg= exponential_covar_prior( inv_model );">exponential_covar_prior</a>	EXPONENTIAL_COVAR_PRIOR image prior with exponential</li><li><a href="../../../eidors/examples/cheating_2d.html" class="code" title="function out=cheating_2d( figno, rand_seed )">cheating_2d</a>	code to simulate inverse crimes in EIT</li><li><a href="../../../eidors/examples/eidors2d_demo1.html" class="code" title="">eidors2d_demo1</a>	EidorsDemo1 Demonstrates the use of 2D EIT Package with linear basis</li><li><a href="../../../eidors/graphics/matlab/show_fem_move.html" class="code" title="function [hf,hh] = show_fem_move( img, move, scale, options )">show_fem_move</a>	SHOW_FEM_MOVE   Plot EIT finite element model (FEM) and movement</li><li><a href="../../../eidors/graphics/matlab/show_slices_move.html" class="code" title="function show_slices_move( img, move, move_scale )">show_slices_move</a>	SHOW_SLICES_MOVE   Shows planar slices of a 3D FEM with movement vectors</li><li><a href="../../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>	CALC_JACOBIAN: calculate jacobian from an inv_model</li><li><a href="fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>	FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)</li><li><a href="fwd_solve_1st_order.html" class="code" title="function data =fwd_solve_1st_order(fwd_model, img)">fwd_solve_1st_order</a>	FWD_SOLVE_1ST_ORDER: data= fwd_solve_1st_order( img)</li><li><a href="fwd_solve_2p5d_1st_order.html" class="code" title="function data =fwd_solve_2p5d_1st_order(fwd_model, img)">fwd_solve_2p5d_1st_order</a>	FWD_SOLVE_2P5D_1ST_ORDER: data= fwd_solve_2p5d_1st_order( img)</li><li><a href="fwd_solve_halfspace.html" class="code" title="function data = fwd_solve_halfspace(fwd_model, img)">fwd_solve_halfspace</a>	FWD_SOLVE_HALFSPACE: data = fwd_solve_halfspace(img)</li><li><a href="jacobian_adjoint.html" class="code" title="function J= jacobian_adjoint( fwd_model, img)">jacobian_adjoint</a>	JACOBIAN_ADJOINT: J= jacobian_adjoint( img )</li><li><a href="jacobian_adjoint_2p5d_1st_order.html" class="code" title="function J= jacobian_adjoint_2p5d_1st_order( fwd_model, img)">jacobian_adjoint_2p5d_1st_order</a>	JACOBIAN_ADJOINT_2P5D: J= jacobian_adjoint_2p5d_1st_order( img )</li><li><a href="jacobian_movement.html" class="code" title="function J = jacobian_movement(fwd_model, img)">jacobian_movement</a>	JACOBIAN_MOVEMENT   Computes the Jacobian matrix for conductivity and</li><li><a href="jacobian_movement_2p5d_1st_order.html" class="code" title="function J = jacobian_movement_2p5d_1st_order( fwd_model, img)">jacobian_movement_2p5d_1st_order</a>	JACOBIAN_MOVEMENT_2P5D: J = jacobian_movement_2p5d_1st_order( img )</li><li><a href="jacobian_movement_halfspace.html" class="code" title="function J= jacobian_movement_perturb( fwd_model, img)">jacobian_movement_halfspace</a>	JACOBIAN_MOVEMENT_PERTURB: J= jacobian_movement_perturb( img )</li><li><a href="jacobian_movement_perturb.html" class="code" title="function J= jacobian_movement_perturb( fwd_model, img)">jacobian_movement_perturb</a>	JACOBIAN_MOVEMENT_PERTURB: J= jacobian_movement_perturb( img )</li><li><a href="system_mat_2p5d_fields.html" class="code" title="function FT= system_mat_2p5d_fields( fwd_model )">system_mat_2p5d_fields</a>	SYSTEM_MAT_2P5D_FIELDS: fields (elem to nodes) fraction of system mat</li><li><a href="system_mat_fields.html" class="code" title="function FC= system_mat_fields( fwd_model )">system_mat_fields</a>	SYSTEM_MAT_FIELDS: fields (elem to nodes) fraction of system mat</li><li><a href="update_system_mat_fields.html" class="code" title="function FC1 = update_system_mat_fields( fwd_model0, fwd_model1 )">update_system_mat_fields</a>	UPDATE_SYSTEM_MAT_FIELDS: fields (elem to nodes) fraction of system mat</li><li><a href="../../../eidors/solvers/inverse/inv_solve_backproj.html" class="code" title="function img= inv_solve_backproj( inv_model, data1, data2)">inv_solve_backproj</a>	INV_SOLVE_BACKPROJ inverse solver using backprojection</li><li><a href="../../../eidors/solvers/inverse/inv_solve_conj_grad.html" class="code" title="function img= inv_solve_conj_grad( inv_model, data1, data2)">inv_solve_conj_grad</a>	INV_SOLVE_CONJ_GRAD inverse solver based on the CG</li><li><a href="../../../eidors/solvers/inverse/inv_solve_core.html" class="code" title="function img= inv_solve_core( inv_model, data0, data1);">inv_solve_core</a>	INV_SOLVE_CORE Solver using a generic iterative algorithm</li><li><a href="../../../eidors/solvers/inverse/inv_solve_diff_kalman.html" class="code" title="function img= inv_solve_diff_kalman( inv_model, data1, data2)">inv_solve_diff_kalman</a>	INV_SOLVE_DIFF_KALMAN inverse solver for difference EIT</li><li><a href="../../../eidors/solvers/inverse/prior_exponential_covar.html" class="code" title="function Reg= prior_exponential_covar( inv_model );">prior_exponential_covar</a>	PRIOR_EXPONENTIAL_COVAR image prior with exponential</li><li><a href="../../../eidors/solvers/inverse/prior_laplace_old.html" class="code" title="function Reg= prior_laplace_old( inv_model );">prior_laplace_old</a>	PRIOR_LAPLACE calculate image prior</li><li><a href="../../../eidors/solvers/inverse/prior_movement.html" class="code" title="function Reg= prior_movement( inv_model );">prior_movement</a>	PRIOR_MOVEMENT calculate image prior</li><li><a href="../../../eidors/solvers/inverse/prior_time_smooth.html" class="code" title="function Reg= prior_time_smooth( inv_model );">prior_time_smooth</a>	PRIOR_TIME_SMOOTH calculate image prior</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function pp= calc_param( fwd_model, opt )</a></li><li><a href="#_sub2" class="code">function v2meas = get_v2meas(n_elec,n_stim,stim)</a></li><li><a href="#_sub3" class="code">function VOLUME = element_volume( NODE, ELEM, e, d)</a></li><li><a href="#_sub4" class="code">function [N2E,cem_electrodes] = calculate_N2E( fwd_model, bdy, n_elec, n);</a></li><li><a href="#_sub5" class="code">function [N2Ei,N2Ei_nodes,cem_electrodes]= N2Ei_from_nodes(</a></li><li><a href="#_sub6" class="code">function [QQ, VV, n_meas] = calc_QQ_slow(N2E, stim, p)</a></li><li><a href="#_sub7" class="code">function [QQ, VV, n_meas] = calc_QQ_fast(N2E, stim, p)</a></li><li><a href="#_sub8" class="code">function do_unit_test</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function param = fwd_model_parameters( fwd_model, opt )</a>
0002 <span class="comment">% FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)</span>
0003 <span class="comment">%   Internal function to extract parameters from a fwd_model</span>
0004 <span class="comment">%   param.n_elem     =&gt; number of elements</span>
0005 <span class="comment">%   param.n_elec     =&gt; number of electrodes</span>
0006 <span class="comment">%   param.n_node     =&gt; number of nodes (vertices)</span>
0007 <span class="comment">%   param.n_stim     =&gt; number of current stimulation patterns</span>
0008 <span class="comment">%   param.n_elec     =&gt; number of electrodes</span>
0009 <span class="comment">%   param.n_dims     =&gt; dimentions (2= 2D, 3=3D)</span>
0010 <span class="comment">%   param.n_meas     =&gt; number of measurements (total)</span>
0011 <span class="comment">%   param.boundary   =&gt; FEM boundary</span>
0012 <span class="comment">%   param.NODE       =&gt; vertex matrix</span>
0013 <span class="comment">%   param.ELEM       =&gt; connection matrix</span>
0014 <span class="comment">%   param.QQ         =&gt; Current into each NODE (Neuman Boundary Conditions)</span>
0015 <span class="comment">%   param.VV         =&gt; Voltage driven into each NODE (Dirichlet BC - only where QQ is NaN)</span>
0016 <span class="comment">%   param.YY         =&gt; Output Admittance (1/Impedance) of each node current (for each value in QQ)</span>
0017 <span class="comment">%   param.VOLUME     =&gt; Volume (or area) of each element</span>
0018 <span class="comment">%   param.normalize  =&gt; difference measurements normalized?</span>
0019 <span class="comment">%   param.N2E        =&gt; Node to electrode converter</span>
0020 <span class="comment">%   param.v2meas     =&gt; Convert node voltages to measurements</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% If the stimulation patterns has a 'interior_sources' field,</span>
0023 <span class="comment">%   the node current QQ, is set to this value for this stimulation.</span>
0024 
0025 <span class="comment">% (C) 2005 Andy Adler. License: GPL version 2 or version 3</span>
0026 <span class="comment">% $Id: fwd_model_parameters.m 6473 2022-12-25 22:41:48Z aadler $</span>
0027 
0028 <span class="keyword">if</span> ischar(fwd_model) &amp;&amp; strcmp(fwd_model, <span class="string">'UNIT_TEST'</span>); <a href="#_sub8" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0029 
0030 <span class="keyword">if</span> nargin &lt; 2
0031    opt.skip_VOLUME = 0;
0032 <span class="keyword">else</span>
0033    assert(ischar(opt),<span class="string">'opt must be a string'</span>);
0034    assert(strcmp(opt,<span class="string">'skip_VOLUME'</span>),<span class="string">'opt can only be ''skip_VOLUME'''</span>);
0035    opt = struct;
0036    opt.skip_VOLUME = 1;
0037 <span class="keyword">end</span>
0038 
0039 copt.fstr = <span class="string">'fwd_model_parameters'</span>;
0040 copt.log_level = 4;
0041 
0042 param = <a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub1" class="code" title="subfunction pp= calc_param( fwd_model, opt )">calc_param</a>,{fwd_model, opt},copt);
0043 
0044 
0045 <span class="comment">% perform actual parameter calculation</span>
0046 <a name="_sub1" href="#_subfunctions" class="code">function pp= calc_param( fwd_model, opt )</a>
0047 
0048 pp.NODE= fwd_model.nodes';
0049 pp.ELEM= fwd_model.elems';
0050 
0051 n= size(pp.NODE,2);        <span class="comment">%NODEs</span>
0052 d= size(pp.ELEM,1);        <span class="comment">%dimentions+1</span>
0053 e= size(pp.ELEM,2);        <span class="comment">%ELEMents</span>
0054 <span class="keyword">try</span>
0055    p = length(fwd_model.stimulation );
0056 <span class="keyword">catch</span> 
0057    p = 0;
0058 <span class="keyword">end</span>
0059 <span class="keyword">try</span>
0060    n_elec= length( fwd_model.electrode );
0061 <span class="keyword">catch</span>
0062    n_elec= 0;
0063    fwd_model.electrode = [];
0064 <span class="keyword">end</span>
0065 
0066 <span class="keyword">if</span> ~opt.skip_VOLUME
0067    copt.fstr = <span class="string">'element_volume'</span>;
0068    copt.log_level = 4;
0069    pp.VOLUME= <a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub3" class="code" title="subfunction VOLUME = element_volume( NODE, ELEM, e, d)">element_volume</a>, {pp.NODE, pp.ELEM, e, d}, copt );
0070 <span class="keyword">end</span>
0071 
0072 <span class="keyword">if</span> isfield(fwd_model,<span class="string">'boundary'</span>)
0073     bdy = double( fwd_model.boundary ); <span class="comment">% double because of stupid matlab bugs</span>
0074 <span class="keyword">else</span>
0075     bdy = <a href="find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>(fwd_model.elems);
0076 <span class="keyword">end</span>
0077 <span class="keyword">try</span> <span class="comment">%add system_mat_fields.CEM_boundary if it exists</span>
0078    bdy = [bdy;fwd_model.system_mat_fields.CEM_boundary];
0079 <span class="keyword">end</span>
0080 
0081 <span class="comment">% Matrix to convert Nodes to Electrodes</span>
0082 <span class="comment">% Complete electrode model for all electrodes</span>
0083 <span class="comment">%  N2E = sparse(1:n_elec, n+ (1:n_elec), 1, n_elec, n+n_elec);</span>
0084 <span class="comment">%  pp.QQ= sparse(n+n_elec,p);</span>
0085 copt.cache_obj = {fwd_model.nodes,fwd_model.elems,fwd_model.electrode};
0086 copt.fstr = <span class="string">'calculate_N2E'</span>;
0087 [N2E,cem_electrodes] = <a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub4" class="code" title="subfunction [N2E,cem_electrodes] = calculate_N2E( fwd_model, bdy, n_elec, n);">calculate_N2E</a>,{fwd_model, bdy, n_elec, n}, copt);
0088 
0089 <span class="comment">% pack into a parameter return list</span>
0090 pp.n_elem   = e;
0091 pp.n_elec   = n_elec;
0092 pp.n_node   = n;
0093 pp.n_stim   = p;
0094 pp.n_dims   = d-1;
0095 pp.N2E      = N2E;
0096 pp.boundary = bdy;
0097 pp.normalize = <a href="../../../eidors/models/mdl_normalize.html" class="code" title="function out = mdl_normalize(mdl, val)">mdl_normalize</a>(fwd_model);
0098 
0099 <span class="keyword">if</span> p&gt;0
0100   stim = fwd_model.stimulation;
0101   [pp.QQ, pp.VV, pp.n_meas] = <a href="#_sub7" class="code" title="subfunction [QQ, VV, n_meas] = calc_QQ_fast(N2E, stim, p)">calc_QQ_fast</a>(N2E, stim, p);
0102 
0103   pp.v2meas   = <a href="#_sub2" class="code" title="subfunction v2meas = get_v2meas(n_elec,n_stim,stim)">get_v2meas</a>(pp.n_elec, pp.n_stim, stim);
0104 <span class="keyword">end</span>
0105 
0106 
0107 <a name="_sub2" href="#_subfunctions" class="code">function v2meas = get_v2meas(n_elec,n_stim,stim)</a>
0108     v2meas = <a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(n_elec*n_stim,0);
0109     <span class="keyword">for</span> i=1:n_stim
0110         meas_pat= stim(i).meas_pattern;
0111         n_meas  = size(meas_pat,1);
0112         <span class="keyword">if</span> n_elec ~= size(meas_pat,2)
0113            error(<span class="string">'meas_pattern %d ~= n_elec'</span>,i)
0114         <span class="keyword">end</span>
0115         v2meas((i-1)*n_elec + 1: i*n_elec,end+(1:n_meas)) = meas_pat.';
0116     <span class="keyword">end</span>
0117     v2meas = v2meas'; <span class="comment">% Conjugate transpose. For derivation</span>
0118                       <span class="comment">% see Chapter 5 of Adler&amp;Holder 2021</span>
0119 
0120 
0121 <span class="comment">% calculate element volume and surface area</span>
0122 <a name="_sub3" href="#_subfunctions" class="code">function VOLUME = element_volume( NODE, ELEM, e, d)</a>
0123    VOLUME=zeros(e,1);
0124    ones_d = ones(1,d);
0125    d1fac = prod( 1:d-1 );
0126    <span class="keyword">if</span> d &gt; size(NODE,1)
0127       <span class="keyword">for</span> i=1:e
0128           this_elem = NODE(:,ELEM(:,i)); 
0129           VOLUME(i)= abs(det([ones_d;this_elem])) / d1fac;
0130       <span class="keyword">end</span>
0131    <span class="keyword">elseif</span> d == 3 <span class="comment">% 3D nodes in 2D mesh</span>
0132       <span class="keyword">for</span> i=1:e
0133           this_elem = NODE(:,ELEM(:,i)); 
0134           d12= det([ones_d;this_elem([1,2],:)])^2;
0135           d13= det([ones_d;this_elem([1,3],:)])^2;
0136           d23= det([ones_d;this_elem([2,3],:)])^2;
0137           VOLUME(i)= sqrt(d12 + d13 + d23 ) / d1fac;
0138       <span class="keyword">end</span>
0139    <span class="keyword">elseif</span> d == 2 <span class="comment">% 3D nodes in 1D mesh (ie resistor mesh)</span>
0140       <span class="keyword">for</span> i=1:e
0141           this_elem = NODE(:,ELEM(:,i)); 
0142           d12= det([ones_d;this_elem([1],:)])^2;
0143           d13= det([ones_d;this_elem([2],:)])^2;
0144           d23= det([ones_d;this_elem([3],:)])^2;
0145           VOLUME(i)= sqrt(d12 + d13 + d23 ) / d1fac;
0146       <span class="keyword">end</span>
0147    <span class="keyword">else</span>
0148       warning(<span class="string">'mesh size not understood when calculating volumes'</span>)
0149       VOLUME = NaN;
0150    <span class="keyword">end</span>
0151 
0152 
0153 <a name="_sub4" href="#_subfunctions" class="code">function [N2E,cem_electrodes] = calculate_N2E( fwd_model, bdy, n_elec, n);</a>
0154    cem_electrodes= 0; <span class="comment">% num electrodes part of Compl. Elec Model</span>
0155    N2E = <a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(n_elec, n+n_elec);
0156    <span class="keyword">for</span> i=1:n_elec
0157       eleci = fwd_model.electrode(i);
0158 <span class="comment">% The faces field is used only if</span>
0159       <span class="keyword">if</span> isfield(eleci,<span class="string">'faces'</span>)  &amp;&amp; ~isempty(eleci.faces)
0160         <span class="keyword">if</span> ~isempty(eleci.nodes)
0161            <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'Warning: electrode %d has both faces and nodes'</span>,i);
0162         <span class="keyword">end</span>
0163         <span class="comment">% This is a CEM electrode</span>
0164         cem_electrodes = cem_electrodes+1;
0165         N2Ei= 1;
0166         N2Ei_nodes = n+cem_electrodes;
0167 
0168       <span class="keyword">elseif</span> isfield(eleci,<span class="string">'nodes'</span>) 
0169           elec_nodes = fwd_model.electrode(i).nodes;
0170          [N2Ei,N2Ei_nodes,cem_electrodes] =  <span class="keyword">...</span>
0171              <a href="#_sub5" class="code" title="subfunction [N2Ei,N2Ei_nodes,cem_electrodes]= N2Ei_from_nodes( ">N2Ei_from_nodes</a>(fwd_model, <span class="keyword">...</span>
0172               bdy, elec_nodes, cem_electrodes,n);
0173       <span class="keyword">else</span>
0174           <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'Warning: electrode %d has no nodes'</span>,i);
0175           <span class="keyword">break</span>; <span class="comment">%Not a real electrode so don't include</span>
0176       <span class="keyword">end</span>
0177       N2E(i, N2Ei_nodes) = N2Ei;
0178    <span class="keyword">end</span>
0179    <span class="comment">% Extra nodes are added if nodes for electronics components are added</span>
0180    <span class="keyword">try</span>
0181       extra_nodes = fwd_model.extra_nodes;
0182    <span class="keyword">catch</span>
0183       extra_nodes = 0;
0184    <span class="keyword">end</span>
0185    N2E = N2E(:, 1:(n+cem_electrodes+extra_nodes));
0186 
0187 <span class="comment">% If N2E can be made a logical (0-1) matrix, do it.</span>
0188    <span class="keyword">if</span> all(N2E(find(N2E(:)))==1)
0189       N2E = logical(N2E);
0190    <span class="keyword">end</span>
0191 
0192 
0193 <a name="_sub5" href="#_subfunctions" class="code">function [N2Ei,N2Ei_nodes,cem_electrodes]= N2Ei_from_nodes( </a><span class="keyword">...</span>
0194       fwd_model, bdy, elec_nodes, cem_electrodes,n);
0195   <span class="comment">% Instrument nodes are added here like a CEM node but with no connections,</span>
0196   <span class="comment">% Use system_mat_instrument to add</span>
0197   <span class="keyword">if</span> ischar(elec_nodes) &amp;&amp; strcmp(elec_nodes,<span class="string">'instrument'</span>)
0198      cem_electrodes = cem_electrodes+1;
0199      N2Ei= 1;
0200      N2Ei_nodes = n+cem_electrodes;
0201      <span class="keyword">return</span>
0202   <span class="keyword">end</span>
0203 
0204   <span class="keyword">if</span> length(elec_nodes) ==1 <span class="comment">% point electrode (maybe inside body)</span>
0205      N2Ei = 1;
0206      N2Ei_nodes = elec_nodes;
0207   <span class="keyword">elseif</span> length(elec_nodes) ==0
0208     error(<span class="string">'EIDORS:fwd_model_parameters:electrode'</span>,<span class="string">'zero length electrode specified'</span>);
0209   <span class="keyword">else</span>
0210      bdy_idx= <a href="find_electrode_bdy.html" class="code" title="function [bdy_idx, bdy_area] = find_electrode_bdy( bdy, vtx, elec_nodes)">find_electrode_bdy</a>( bdy, [], elec_nodes);
0211 
0212      <span class="keyword">if</span> ~isempty(bdy_idx) <span class="comment">% CEM electrode</span>
0213         cem_electrodes = cem_electrodes+1;
0214         N2Ei= 1;
0215         N2Ei_nodes = n+cem_electrodes;
0216      <span class="keyword">else</span> <span class="comment">% a set of point electrodes</span>
0217           <span class="comment">% FIXME: make current defs between point electrodes and CEMs compatible</span>
0218         [bdy_idx,srf_area]= <a href="find_electrode_bdy.html" class="code" title="function [bdy_idx, bdy_area] = find_electrode_bdy( bdy, vtx, elec_nodes)">find_electrode_bdy</a>( bdy, <span class="keyword">...</span>
0219                        fwd_model.nodes, elec_nodes);
0220         s_srf_area =  sum(srf_area);
0221         <span class="keyword">if</span> s_srf_area == 0;
0222            error(<span class="string">'Surface area for elec#%d is zero. Is boundary correct?'</span>,i);
0223         <span class="keyword">end</span>
0224         N2Ei = srf_area/s_srf_area;
0225         N2Ei_nodes= elec_nodes;
0226      <span class="keyword">end</span>
0227   <span class="keyword">end</span>
0228 
0229 
0230 <a name="_sub6" href="#_subfunctions" class="code">function [QQ, VV, n_meas] = calc_QQ_slow(N2E, stim, p)</a>
0231    QQ = <a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(size(N2E,2),p);
0232    VV = <a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(size(N2E,2),p); N2E0 = N2E&gt;0;
0233    n_meas= 0; <span class="comment">% sum total number of measurements</span>
0234    <span class="keyword">for</span> i=1:p
0235        src= zeros(size(N2E,2),1);
0236        <span class="keyword">try</span>;  src =       N2E' * stim(i).stim_pattern; <span class="keyword">end</span>
0237        <span class="keyword">try</span>;  src = src + stim(i).interior_sources;    <span class="keyword">end</span>
0238        <span class="keyword">if</span> all(size(src) == [1,1]) &amp;&amp; src==0
0239           error(<span class="string">'no stim_patterns or interior_sources provided for pattern #%d'</span>,i);
0240        <span class="keyword">end</span>
0241        
0242        QQ(:,i) = src;
0243        n_meas = n_meas + size(stim(i).meas_pattern,1);
0244 
0245        vlt= zeros(size(N2E,2),1);
0246        <span class="keyword">try</span>;  vlt =      N2E0' * stim(i).volt_pattern; <span class="keyword">end</span>
0247        VV(:,i) = vlt;
0248    <span class="keyword">end</span>
0249 
0250 <a name="_sub7" href="#_subfunctions" class="code">function [QQ, VV, n_meas] = calc_QQ_fast(N2E, stim, p)</a>
0251    <span class="keyword">try</span>
0252       ncols = arrayfun(@(x) size(x.stim_pattern,2), stim);
0253    <span class="keyword">catch</span>
0254       error(<span class="string">'EIDORS:fwd_model_parameters stim_pattern not specified'</span>);
0255    <span class="keyword">end</span>
0256    <span class="keyword">if</span> any(ncols&gt;1);
0257       str = <span class="string">'multiple columns in stim_pattern for patterns: '</span>;
0258       error(<span class="string">'EIDORS:fwd_model_parameters:stim_pattern'</span>, <span class="keyword">...</span>
0259             [str, sprintf(<span class="string">'#%d '</span>,find(ncols&gt;1))]);
0260    <span class="keyword">end</span>
0261    idx = 1:p; idx(ncols==0)= [];
0262 
0263    QQ = <a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(size(N2E,2),p);
0264    <span class="keyword">try</span>
0265    QQ(:,idx) = N2E' * horzcat( stim(:).stim_pattern );
0266    <span class="keyword">end</span>
0267    VV = <a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(size(N2E,2),p);
0268    <span class="comment">% For voltages, we just need to know which N2E, not the size</span>
0269 
0270 
0271 
0272    <span class="keyword">try</span>
0273    ncols = arrayfun(@(x) size(x.volt_pattern,2), stim);
0274    <span class="keyword">end</span>
0275    <span class="keyword">if</span> any(ncols&gt;1);
0276       str = <span class="string">'multiple columns in volt_pattern for patterns: '</span>;
0277       error(<span class="string">'EIDORS:fwd_model_parameters:volt_pattern'</span>, <span class="keyword">...</span>
0278             [str, sprintf(<span class="string">'#%d '</span>,find(ncols&gt;1))]);
0279    <span class="keyword">end</span>
0280    idx = 1:p; idx(ncols==0)= [];
0281 
0282    <span class="keyword">try</span>
0283    VV(:,idx) = (N2E&gt;0)' * horzcat( stim(:).volt_pattern );
0284    <span class="keyword">end</span>
0285 
0286    n_meas = size(vertcat(stim(:).meas_pattern),1);
0287 
0288 
0289 
0290 <a name="_sub8" href="#_subfunctions" class="code">function do_unit_test</a>
0291    imdl = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'a2c2'</span>,16); fmdl = imdl.fwd_model;
0292    pp = <a href="fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>(fmdl);
0293    [QQ1, VV1, n1m] = <a href="#_sub6" class="code" title="subfunction [QQ, VV, n_meas] = calc_QQ_slow(N2E, stim, p)">calc_QQ_slow</a>(pp.N2E, fmdl.stimulation, pp.n_stim);
0294    [QQ2, VV2, n2m] = <a href="#_sub7" class="code" title="subfunction [QQ, VV, n_meas] = calc_QQ_fast(N2E, stim, p)">calc_QQ_fast</a>(pp.N2E, fmdl.stimulation, pp.n_stim);
0295    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'calc_QQ'</span>, norm(QQ1-QQ2,<span class="string">'fro'</span>) + norm(n1m-n2m), 0, 1e-15);
0296    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'calc_VV1'</span>, norm(VV1,<span class="string">'fro'</span>), 0, 1e-15);
0297    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'calc_VV2'</span>, norm(VV2,<span class="string">'fro'</span>), 0, 1e-15);
0298 
0299    <span class="keyword">for</span> i=1:6;
0300       imdl = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'a2C0'</span>,4); fmdl = imdl.fwd_model;
0301       <span class="keyword">switch</span> i
0302          <span class="keyword">case</span> 1; fmdl.stimulation(3).stim_pattern = fmdl.stimulation(3).stim_pattern*[1,2]; 
0303                  expected_err = <span class="string">'EIDORS:fwd_model_parameters:stim_pattern'</span>;
0304          <span class="keyword">case</span> 2; fmdl.stimulation(1).stim_pattern = [];
0305                  expected_err = <span class="string">''</span>; expected = zeros(45,4);
0306                  expected(42:45,2:4) = [0,0,1;-1,0,0;1,-1,0;0,1,-1]*10;
0307                  param = <span class="string">'QQ'</span>;
0308          <span class="keyword">case</span> 3; fmdl.electrode(1).nodes = [];
0309                  expected_err = <span class="string">'EIDORS:fwd_model_parameters:electrode'</span>;
0310          <span class="keyword">case</span> 4; fmdl.stimulation(1).volt_pattern = [zeros(3,1);6];
0311                  expected_err = <span class="string">''</span>; expected = zeros(45,4); expected(45,1) = 6;
0312                  param = <span class="string">'VV'</span>;
0313          <span class="keyword">case</span> 5; fmdl.stimulation(3).volt_pattern = [ones(4,2)];
0314                  expected_err = <span class="string">'EIDORS:fwd_model_parameters:volt_pattern'</span>;
0315          <span class="keyword">case</span> 6; fmdl.electrode(3).faces = [1,2;2,3;3,1];
0316                  fmdl.electrode(3).nodes = [];
0317                  expected_err = <span class="string">''</span>; expected = zeros(4,45);
0318                  expected(:,42:45) = eye(4);
0319                  param = <span class="string">'N2E'</span>;
0320       <span class="keyword">end</span>
0321       err= <span class="string">''</span>;
0322       <span class="keyword">try</span>;  pp = <a href="fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>(fmdl);
0323       <span class="keyword">catch</span> e
0324          err= e.identifier;
0325       <span class="keyword">end</span>
0326       <span class="keyword">if</span> length(expected_err)&gt;0;
0327          <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>([<span class="string">'expected error:'</span>,num2str(i)], err, expected_err);
0328       <span class="keyword">else</span>
0329          <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>([<span class="string">'case:'</span>,num2str(i)], full(pp.(param)), expected);
0330       <span class="keyword">end</span>
0331    <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 30-Dec-2022 20:46:51 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>
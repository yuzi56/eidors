<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of simulate_3d_movement</title>
  <meta name="keywords" content="simulate_3d_movement">
  <meta name="description" content="SIMULATE_3D_MOVEMENT simulate rotational movement in 3D">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">eidors</a> &gt; <a href="index.html">models</a> &gt; simulate_3d_movement.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/models&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>simulate_3d_movement
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>SIMULATE_3D_MOVEMENT simulate rotational movement in 3D</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [vh,vi,xyzr_pt]= simulate_3d_movement( n_sims, fmdl, rad_pr,movefcn ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> SIMULATE_3D_MOVEMENT simulate rotational movement in 3D
 [vh,vi,xyzr_pt]= simulate_3d_movement( n_points, model, rad_pr, movefcn )

   rad_pr = [path_radius, target_radius, zmin, zmax]
      values are the fraction of the extent in each dimension
      DEFAULT: [2/3, .05, .1, .9 ]
 
   n_points = number of points to simulate (default = 200)

   model = fwd_model to simulate 
         (default use internal, or if model= []);

   movefcn = 1 (Default)  helical motion where the target starts
     at (rad_pr(1),0) and rotates clockwise moving bottom to top.
   movefcn = 2            radial movement in the vertical plane

   movefcn = FUCN NAME or FUNC HANDLE
      the function must accept the following parameters
      [xp,yp,zp] = movefcn(f_frac, radius, z_bottom,z_top);

 OUTPUT:
   vh - homogeneous measurements            M x 1
   vi - target simulations                  M x n_points
   xyzr_pt - x,y,z and radius of each point 3 x n_points

 For small targets it is more accurate and much faster to
  use the function: simulate_movement.m</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG eidors progress and status messages</li><li><a href="../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>	EIDORS_OBJ: maintains EIDORS internals</li><li><a href="../../eidors/graphics/matlab/show_slices.html" class="code" title="function out_img= show_slices( img, levels, vh )">show_slices</a>	out_img = show_slices (img, levels ) show slices at levels of an</li><li><a href="interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>	INTERP_MESH: calculate interpolation points onto mdl elements</li><li><a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="mk_library_model.html" class="code" title="function out = mk_library_model(shape,elec_pos,elec_shape,maxsz,nfft,scale)">mk_library_model</a>	MK_LIBRARY_MODEL - FEM models based on library shapes</li><li><a href="mk_stim_patterns.html" class="code" title="function [stim, meas_sel]= mk_stim_patterns(n_elec, n_rings, inj, meas, options, amplitude)">mk_stim_patterns</a>	MK_STIM_PATTERNS: create an EIDORS stimulation pattern structure</li><li><a href="simulate_3d_movement.html" class="code" title="function [vh,vi,xyzr_pt]= simulate_3d_movement( n_sims, fmdl, rad_pr,movefcn )">simulate_3d_movement</a>	SIMULATE_3D_MOVEMENT simulate rotational movement in 3D</li><li><a href="../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>	FWD_SOLVE: calculate data from a fwd_model object and an image</li><li><a href="../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>	INV_SOLVE: calculate imag from an inv_model and data</li><li><a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>	EIDORS_CACHE Control eidors caching</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="simulate_3d_movement.html" class="code" title="function [vh,vi,xyzr_pt]= simulate_3d_movement( n_sims, fmdl, rad_pr,movefcn )">simulate_3d_movement</a>	SIMULATE_3D_MOVEMENT simulate rotational movement in 3D</li><li><a href="../../eidors/solvers/inverse/inv_solve_time_prior.html" class="code" title="function img= inv_solve_time_prior( inv_model, data1, data2)">inv_solve_time_prior</a>	INV_SOLVE_TIME_PRIOR inverse solver to account for time differences</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [vh,vi,xyzr_pt]= do_simulate_3d_movement( n_sims, mdl_3d, rad_pr, movefcn )</a></li><li><a href="#_sub2" class="code">function [xp,yp,zp]= helical_path(f_frac, radius, z0,zt);</a></li><li><a href="#_sub3" class="code">function [xp,yp,zp]= radial_path(f_frac, radius, z0,zt);</a></li><li><a href="#_sub4" class="code">function [EPTR, VOL] = img_mapper3a(NODE, ELEM, x,y,z );</a></li><li><a href="#_sub5" class="code">function [radius, rp, zmin, zmax,x,y,z] =</a></li><li><a href="#_sub6" class="code">function do_unit_test</a></li><li><a href="#_sub7" class="code">function [xp,yp,zp] = test_movefcn(f_frac, radius,z0,zt);</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [vh,vi,xyzr_pt]= simulate_3d_movement( n_sims, fmdl, rad_pr,movefcn )</a>
0002 <span class="comment">% SIMULATE_3D_MOVEMENT simulate rotational movement in 3D</span>
0003 <span class="comment">% [vh,vi,xyzr_pt]= simulate_3d_movement( n_points, model, rad_pr, movefcn )</span>
0004 <span class="comment">%</span>
0005 <span class="comment">%   rad_pr = [path_radius, target_radius, zmin, zmax]</span>
0006 <span class="comment">%      values are the fraction of the extent in each dimension</span>
0007 <span class="comment">%      DEFAULT: [2/3, .05, .1, .9 ]</span>
0008 <span class="comment">%</span>
0009 <span class="comment">%   n_points = number of points to simulate (default = 200)</span>
0010 <span class="comment">%</span>
0011 <span class="comment">%   model = fwd_model to simulate</span>
0012 <span class="comment">%         (default use internal, or if model= []);</span>
0013 <span class="comment">%</span>
0014 <span class="comment">%   movefcn = 1 (Default)  helical motion where the target starts</span>
0015 <span class="comment">%     at (rad_pr(1),0) and rotates clockwise moving bottom to top.</span>
0016 <span class="comment">%   movefcn = 2            radial movement in the vertical plane</span>
0017 <span class="comment">%</span>
0018 <span class="comment">%   movefcn = FUCN NAME or FUNC HANDLE</span>
0019 <span class="comment">%      the function must accept the following parameters</span>
0020 <span class="comment">%      [xp,yp,zp] = movefcn(f_frac, radius, z_bottom,z_top);</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% OUTPUT:</span>
0023 <span class="comment">%   vh - homogeneous measurements            M x 1</span>
0024 <span class="comment">%   vi - target simulations                  M x n_points</span>
0025 <span class="comment">%   xyzr_pt - x,y,z and radius of each point 3 x n_points</span>
0026 <span class="comment">%</span>
0027 <span class="comment">% For small targets it is more accurate and much faster to</span>
0028 <span class="comment">%  use the function: simulate_movement.m</span>
0029 
0030 <span class="comment">% (C) 2005-2009 Andy Adler. Licensed under GPL v2 or v3</span>
0031 <span class="comment">% $Id: simulate_3d_movement.m 5112 2015-06-14 13:00:41Z aadler $</span>
0032 
0033 <span class="keyword">if</span> nargin &lt;1; n_sims = 200; <span class="keyword">end</span>
0034 
0035 <span class="keyword">if</span> nargin&gt;=1 &amp;&amp; ischar(n_sims) &amp;&amp; strcmp(n_sims,<span class="string">'UNIT_TEST'</span>); <a href="#_sub6" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0036 
0037 <span class="keyword">if</span> nargin&lt;2 || isempty(fmdl) <span class="comment">% create our own fmdl</span>
0038    fmdl= <a href="mk_library_model.html" class="code" title="function out = mk_library_model(shape,elec_pos,elec_shape,maxsz,nfft,scale)">mk_library_model</a>(<span class="string">'cylinder_16x2el_fine'</span>);
0039    fmdl.normalize_measurements = 0;
0040    fmdl.electrode = fmdl.electrode(1:16);
0041    fmdl.stimulation = <a href="mk_stim_patterns.html" class="code" title="function [stim, meas_sel]= mk_stim_patterns(n_elec, n_rings, inj, meas, options, amplitude)">mk_stim_patterns</a>(16,1,[0,1],[0,1],{},1);
0042    fmdl.normalize_measurements = 0;
0043 <span class="keyword">end</span>
0044 
0045 <span class="keyword">if</span> nargin&lt;3 || isempty(rad_pr);
0046    rad_pr= [2/3, 0.05, 0.1, 0.9];
0047 <span class="keyword">end</span>
0048 
0049 <span class="keyword">if</span> nargin&lt;4; movefcn= 1; <span class="keyword">end</span>
0050 
0051 copt.cache_obj = {n_sims,fmdl, rad_pr, movefcn};
0052 copt.fstr = <span class="string">'simulate_3d_movement'</span>;
0053 
0054 [vh,vi,xyzr_pt]= <a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub1" class="code" title="subfunction [vh,vi,xyzr_pt]= do_simulate_3d_movement( n_sims, mdl_3d, rad_pr, movefcn )">do_simulate_3d_movement</a>, <span class="keyword">...</span>
0055                               { n_sims, fmdl, rad_pr, movefcn}, copt );
0056                            
0057 
0058 <a name="_sub1" href="#_subfunctions" class="code">function [vh,vi,xyzr_pt]= do_simulate_3d_movement( n_sims, mdl_3d, rad_pr, movefcn )</a>
0059 
0060     mv_start = 0;
0061     mv_end   = 1;
0062 <span class="keyword">if</span> isnumeric(movefcn)
0063    <span class="keyword">if</span> length(movefcn)&gt;=2; mv_start = movefcn(2); <span class="keyword">end</span>
0064    <span class="keyword">if</span> length(movefcn)&gt;=3; mv_end   = movefcn(3); <span class="keyword">end</span>
0065    <span class="keyword">if</span>     movefcn(1)==1
0066       movefcn = @<a href="#_sub2" class="code" title="subfunction [xp,yp,zp]= helical_path(f_frac, radius, z0,zt);">helical_path</a>;
0067    <span class="keyword">elseif</span> movefcn(1)==2
0068       movefcn = @<a href="#_sub3" class="code" title="subfunction [xp,yp,zp]= radial_path(f_frac, radius, z0,zt);">radial_path</a>;
0069    <span class="keyword">else</span>
0070       error(<span class="string">'value of movefcn not understood'</span>);
0071    <span class="keyword">end</span>
0072 <span class="keyword">else</span>
0073    <span class="comment">% assume movefcn is a function</span>
0074 <span class="keyword">end</span>
0075 
0076 <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'simulate_3d_movement: step #1: homogeneous simulation'</span>,2);
0077 <span class="comment">% create homogeneous image + simulate data</span>
0078 sigma= ones( size(mdl_3d.elems,1) ,1);
0079 img= <a href="../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>(<span class="string">'image'</span>, <span class="string">'homogeneous image'</span>, <span class="keyword">...</span>
0080     <span class="string">'elem_data'</span>, sigma, <span class="keyword">...</span>
0081     <span class="string">'fwd_model'</span>, mdl_3d );
0082 vh = <a href="../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>( img);
0083 
0084 <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'simulate_3d_movement: step #2: find points'</span>,2);
0085 
0086     mdl_pts = <a href="interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>( mdl_3d, 2); <span class="comment">% 10 per elem</span>
0087     x= mdl_pts(:,1,:);
0088     y= mdl_pts(:,2,:);
0089     z= mdl_pts(:,3,:);
0090    [radius,rp,z0,zt] = calc_point_grid(mdl_3d.nodes', rad_pr);
0091 
0092 target_conductivity= .1;
0093 
0094 <span class="keyword">for</span> i=1:n_sims
0095    <span class="keyword">if</span> rem(i, max( floor(i/10), 10))==1;
0096        <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>( <span class="keyword">...</span>
0097        <span class="string">'simulate_3d_movement: step #3 (%d of %d): target simulations'</span>, <span class="keyword">...</span>
0098        i, n_sims, 2); 
0099    <span class="keyword">end</span>
0100 
0101    f_frac= mv_start + ( (i-1)/n_sims ) * (mv_end - mv_start);
0102    [xp,yp,zp]= feval(movefcn, f_frac, radius, z0,zt);
0103    ff=  (x-xp).^2 + (y-yp).^2 + (z-zp).^2 &lt;= rp^2;
0104    img.elem_data= 1 + target_conductivity * mean(ff,3);
0105 
0106    xyzr_pt(:,i)= [xp;-yp;zp;rp]; <span class="comment">% -y because images and axes are reversed</span>
0107    vi(i)= <a href="../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>( img );<span class="comment">% measurement</span>
0108 <span class="keyword">end</span>
0109 
0110 vi= [vi(:).meas];
0111 vh= [vh(:).meas];
0112 
0113 <span class="comment">%   movefcn = 1 (Default)  helical motion where the target starts</span>
0114 <span class="comment">%     at (rad_pr(1),0) and rotates clockwise moving bottom to top.</span>
0115 <span class="comment">% calculate x,y,z position of point, given f_frac of path</span>
0116 <a name="_sub2" href="#_subfunctions" class="code">function [xp,yp,zp]= helical_path(f_frac, radius, z0,zt);</a>
0117    xp= radius * cos(f_frac*2*pi);
0118    yp= radius * sin(f_frac*2*pi);
0119    <span class="comment">% object moves from bottow to top</span>
0120    zp = z0 + (zt - z0) * f_frac;
0121 
0122 <span class="comment">%   movefcn = 2            radial movement in the vertical plane</span>
0123 <a name="_sub3" href="#_subfunctions" class="code">function [xp,yp,zp]= radial_path(f_frac, radius, z0,zt);</a>
0124    rp= f_frac*radius; 
0125    cv= 2*pi*f_frac;
0126    xp= rp * cos(cv);
0127    yp= rp * sin(cv);
0128    zp = mean([zt,z0]);
0129 
0130 <span class="comment">% modified img_mapper3 from calc_slices.m</span>
0131 <span class="comment">% this is like tsearch, but doesn't require</span>
0132 <span class="comment">% delaunay triangularization. I also wrote it, so I like it :-)</span>
0133 <a name="_sub4" href="#_subfunctions" class="code">function [EPTR, VOL] = img_mapper3a(NODE, ELEM, x,y,z );</a>
0134    <span class="comment">% calc and see if one point is in one element</span>
0135    elems = size(ELEM,2);
0136 
0137    EPTR= zeros(prod(size(x)),1);
0138    VOL= zeros(elems,1);
0139 
0140    <span class="keyword">for</span> j= 1: elems
0141        <span class="keyword">if</span> rem(j,5000)==0; fprintf(<span class="string">'mapping %d / %d \n'</span>,j,elems); <span class="keyword">end</span>
0142        xyz= NODE(:,ELEM(:,j))';
0143        min_x= min(xyz(:,1)); max_x= max(xyz(:,1));
0144        min_y= min(xyz(:,2)); max_y= max(xyz(:,2));
0145        min_z= min(xyz(:,3)); max_z= max(xyz(:,3));
0146 
0147        <span class="comment">% Simplex relative volume is det([v2-v1,v3-v1, ...])</span>
0148        VOL(j)= abs(det(xyz'*[-1,1,0,0;-1,0,1,0;-1,0,0,1]'));
0149 
0150        xlmax= x&lt;=max_x; <span class="keyword">if</span> ~any(xlmax); <span class="keyword">continue</span>; <span class="keyword">end</span>
0151        xgmin= x&gt;=min_x; <span class="keyword">if</span> ~any(xgmin); <span class="keyword">continue</span>; <span class="keyword">end</span>
0152        ylmax= y&lt;=max_y; <span class="keyword">if</span> ~any(ylmax); <span class="keyword">continue</span>; <span class="keyword">end</span>
0153        ygmin= y&gt;=min_y; <span class="keyword">if</span> ~any(ygmin); <span class="keyword">continue</span>; <span class="keyword">end</span>
0154        zlmax= z&lt;=max_z; <span class="keyword">if</span> ~any(zlmax); <span class="keyword">continue</span>; <span class="keyword">end</span>
0155        zgmin= z&gt;=min_z; <span class="keyword">if</span> ~any(zgmin); <span class="keyword">continue</span>; <span class="keyword">end</span>
0156        <span class="comment">% come up with a limited set of candidate points which</span>
0157        <span class="comment">% may be within the simplex</span>
0158        endr=find( xlmax &amp; xgmin &amp; ylmax &amp; ygmin &amp; zlmax &amp; zgmin);
0159        ll=  prod(size(endr));
0160        <span class="keyword">if</span> isempty(ll);
0161           <span class="keyword">continue</span>;
0162        <span class="keyword">end</span>
0163 
0164        nn=  size(ELEM,1); <span class="comment">%Simplex vertices</span>
0165        vol=zeros(ll,nn);
0166        <span class="keyword">for</span> i=1:nn
0167            i1= i; i2= rem(i,nn)+1; i3= rem(i+1,nn)+1;
0168            x1= xyz(i1,1)-x(endr); y1= xyz(i1,2)-y(endr); z1= xyz(i1,3)-z(endr);
0169            x2= xyz(i2,1)-x(endr); y2= xyz(i2,2)-y(endr); z2= xyz(i2,3)-z(endr);
0170            x3= xyz(i3,1)-x(endr); y3= xyz(i3,2)-y(endr); z3= xyz(i3,3)-z(endr);
0171            vol(:,i)= x1.*y2.*z3 - x1.*y3.*z2 - x2.*y1.*z3 + <span class="keyword">...</span>
0172                x3.*y1.*z2 + x2.*y3.*z1 - x3.*y2.*z1;
0173        <span class="keyword">end</span>
0174 
0175        endr( sum(abs(vol),2) - VOL(j) &gt;1e-8 )=[];
0176        EPTR(endr)= j;
0177    <span class="keyword">end</span> <span class="comment">%for j=1:ELEM</span>
0178 
0179 <a name="_sub5" href="#_subfunctions" class="code">function [radius, rp, zmin, zmax,x,y,z] = </a><span class="keyword">...</span>
0180          calc_point_grid(NODE, rad_pr, npx, npy, npz);
0181 
0182    xmin = min(NODE(1,:));    xmax = max(NODE(1,:));
0183    xmean= mean([xmin,xmax]); xrange= xmax-xmin;
0184 
0185    ymin = min(NODE(2,:));    ymax = max(NODE(2,:));
0186    ymean= mean([ymin,ymax]); yrange= ymax-ymin;
0187 
0188    zmin = min(NODE(3,:));    zmax = max(NODE(3,:));
0189    zmean= mean([zmin,zmax]); zrange= zmax-zmin;
0190 
0191    radius= rad_pr(1)*(xmax-xmin)/2;
0192    rp=     rad_pr(2)*(xmax-xmin)/2;
0193    zmin=   (rad_pr(3)-.5)*zrange + zmean;
0194    zmax=   (rad_pr(4)-.5)*zrange + zmean;
0195 
0196    <span class="keyword">if</span> nargout&lt;=4; <span class="keyword">return</span>; <span class="keyword">end</span>
0197    range= max([xrange, yrange,zrange]);
0198    [x y z]=ndgrid( <span class="keyword">...</span>
0199        linspace( xmean - range*0.5, xmean + range*0.5, npx ), <span class="keyword">...</span>
0200        linspace( ymean + range*0.5, ymean - range*0.5, npy ),<span class="keyword">...</span>
0201        linspace( zmean - zrange*0.5, zmean + zrange*0.5, npz ));
0202 
0203 <a name="_sub6" href="#_subfunctions" class="code">function do_unit_test</a>
0204    N_TEST = 5;
0205    imdl = <a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>( <span class="string">'c2c2'</span>, 16 );
0206 
0207    [vh,vi,xyzr_pt]=<a href="simulate_3d_movement.html" class="code" title="function [vh,vi,xyzr_pt]= simulate_3d_movement( n_sims, fmdl, rad_pr,movefcn )">simulate_3d_movement</a>(N_TEST);
0208    subplot(421);
0209    imgs = <a href="../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vh, vi);
0210    imgs.show_slices.img_cols = N_TEST; <a href="../../eidors/graphics/matlab/show_slices.html" class="code" title="function out_img= show_slices( img, levels, vh )">show_slices</a>(imgs);
0211 
0212    [vh,vi,xyzr_pt]=<a href="simulate_3d_movement.html" class="code" title="function [vh,vi,xyzr_pt]= simulate_3d_movement( n_sims, fmdl, rad_pr,movefcn )">simulate_3d_movement</a>(N_TEST, [], [0.3,0.01,.1,.9],1);
0213    subplot(422);
0214    imgs = <a href="../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vh, vi);
0215    imgs.show_slices.img_cols = N_TEST; <a href="../../eidors/graphics/matlab/show_slices.html" class="code" title="function out_img= show_slices( img, levels, vh )">show_slices</a>(imgs);
0216 
0217    [vh,vi,xyzr_pt]=<a href="simulate_3d_movement.html" class="code" title="function [vh,vi,xyzr_pt]= simulate_3d_movement( n_sims, fmdl, rad_pr,movefcn )">simulate_3d_movement</a>(N_TEST, [], [0.9,0.01,.1,.9],2);
0218    subplot(423);
0219    imgs = <a href="../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vh, vi);
0220    imgs.show_slices.img_cols = N_TEST; <a href="../../eidors/graphics/matlab/show_slices.html" class="code" title="function out_img= show_slices( img, levels, vh )">show_slices</a>(imgs);
0221    
0222    [vh,vi,xyzr_pt]=<a href="simulate_3d_movement.html" class="code" title="function [vh,vi,xyzr_pt]= simulate_3d_movement( n_sims, fmdl, rad_pr,movefcn )">simulate_3d_movement</a>(N_TEST, [], [],[1,0.5,0.4]);
0223    subplot(424);
0224    imgs = <a href="../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vh, vi);
0225    imgs.show_slices.img_cols = N_TEST; <a href="../../eidors/graphics/matlab/show_slices.html" class="code" title="function out_img= show_slices( img, levels, vh )">show_slices</a>(imgs);
0226 
0227    [vh,vi,xyzr_pt]=<a href="simulate_3d_movement.html" class="code" title="function [vh,vi,xyzr_pt]= simulate_3d_movement( n_sims, fmdl, rad_pr,movefcn )">simulate_3d_movement</a>(N_TEST, [], [],@<a href="#_sub7" class="code" title="subfunction [xp,yp,zp] = test_movefcn(f_frac, radius,z0,zt);">test_movefcn</a>);
0228    subplot(425);
0229    imgs = <a href="../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vh, vi);
0230    imgs.show_slices.img_cols = N_TEST; <a href="../../eidors/graphics/matlab/show_slices.html" class="code" title="function out_img= show_slices( img, levels, vh )">show_slices</a>(imgs);
0231 
0232    fmdl = <a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'n3r2'</span>,[16,2]); fmdl= fmdl.fwd_model;
0233    fmdl.electrode = fmdl.electrode(1:16);
0234    fmdl.stimulation = <a href="mk_stim_patterns.html" class="code" title="function [stim, meas_sel]= mk_stim_patterns(n_elec, n_rings, inj, meas, options, amplitude)">mk_stim_patterns</a>(16,1,[0,1],[0,1],{},1);
0235    fmdl.nodes = fmdl.nodes*1.5;
0236    [vh,vi,xyzr_pt]=<a href="simulate_3d_movement.html" class="code" title="function [vh,vi,xyzr_pt]= simulate_3d_movement( n_sims, fmdl, rad_pr,movefcn )">simulate_3d_movement</a>(N_TEST, fmdl, [],@<a href="#_sub7" class="code" title="subfunction [xp,yp,zp] = test_movefcn(f_frac, radius,z0,zt);">test_movefcn</a>);
0237    subplot(426);
0238    imgs = <a href="../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vh, vi);
0239    imgs.show_slices.img_cols = N_TEST; <a href="../../eidors/graphics/matlab/show_slices.html" class="code" title="function out_img= show_slices( img, levels, vh )">show_slices</a>(imgs);
0240 
0241 <a name="_sub7" href="#_subfunctions" class="code">function [xp,yp,zp] = test_movefcn(f_frac, radius,z0,zt);</a>
0242   ff =  radius/sqrt(2);
0243   xp= ff*f_frac; yp= ff*f_frac; zp = mean([z0,zt]);</pre></div>
<hr><address>Generated on Fri 30-Dec-2022 20:46:51 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>
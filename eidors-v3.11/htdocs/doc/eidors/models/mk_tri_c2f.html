<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of mk_tri_c2f</title>
  <meta name="keywords" content="mk_tri_c2f">
  <meta name="description" content="MK_TRI_C2F - calculate a coarse2fine mapping for triangle-based models.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">eidors</a> &gt; <a href="index.html">models</a> &gt; mk_tri_c2f.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/models&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>mk_tri_c2f
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>MK_TRI_C2F - calculate a coarse2fine mapping for triangle-based models.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function c2f = mk_tri_c2f(fmdl,rmdl,opt) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">MK_TRI_C2F - calculate a coarse2fine mapping for triangle-based models.
 C2F = MK_TRI_C2F(FMDL,RMDL) returns in C2F the fraction of area of
 each element of the fine model FMDL contained in each element of
 the coarse model RMDL.
 Uses CONVHULLN to calculate the area defined by a set of intersection
 points between individual triangles.

 C2F = MK_TRI_C2F(FMDL,RMDL,OPT) allows specifying options.
 
 Inputs:
   FMDL - a (fine) EIDORS (tet-based) forward model
   RMDL - a (course) EIDORS (tet-based) forward model
   OPT  - an option structure with the following fields and defaults:
      .do_not_scale  - set to true to prevent scaling the models to unit
                       square before any calculations, including 
                       thresholds. Default: false
      .tol_node2tri  - minimum value of a barycentric coordinate to 
                       decide a point is lying inside a triangle and not
                       on its edge. Default: eps

 NOTE that for grid-based models, such as returned by MK_GRID_MODEL or
 MK_VOXEL_VOLUME, MK_GRID_C2F is much faster.

 Set eidors_msg 'log level' &lt; 2 to supress output to command line.

 Examples:
     fmdl = ng_mk_cyl_models([0,2,.2],[],[]);
     rmdl = ng_mk_cyl_models([0,2],[],[]);
     c2f  = mk_tri_c2f(fmdl,rmdl);
     h = show_fem(fmdl); set(h,'LineWidth',0.1,'FaceColor','none')
     hold on
     h = show_fem(rmdl); set(h,'EdgeColor','b','LineWidth',2,...
        'FaceColor','none');
     hold off

 See also <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">MK_GRID_C2F</a>, <a href="find_edge2edge_intersections.html" class="code" title="function [pts,FE2CE,FE2pts,CE2pts] = find_edge2edge_intersections(FE,FN,CE,CN, epsilon)">FIND_EDGE2EDGE_INTERSECTIONS</a>, CONVHULLN
          <a href="mk_approx_c2f.html" class="code" title="function [mapping, outside] = mk_approx_c2f( f_mdl, c_mdl );">MK_APPROX_C2F</a>, <a href="point_in_triangle.html" class="code" title="function out = point_in_triangle(P,E,V,epsilon, str)">POINT_IN_TRIANGLE</a>, EIDORS_MSG</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG eidors progress and status messages</li><li><a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>	SHOW_FEM: show the EIDORS3D finite element model</li><li><a href="find_edge2edge_intersections.html" class="code" title="function [pts,FE2CE,FE2pts,CE2pts] = find_edge2edge_intersections(FE,FN,CE,CN, epsilon)">find_edge2edge_intersections</a>	FIND_EDGE2EDGE_INTERSECTIONS intersections between edges of two models</li><li><a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>	FIX_MODEL: Add useful fields to a model</li><li><a href="get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>	GET_ELEM_VOLUME: VOL = get_elem_volume(fwd_model, map_node )</li><li><a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>	MK_IMAGE: create eidors image object</li><li><a href="mk_tri_c2f.html" class="code" title="function c2f = mk_tri_c2f(fmdl,rmdl,opt)">mk_tri_c2f</a>	MK_TRI_C2F - calculate a coarse2fine mapping for triangle-based models.</li><li><a href="point_in_triangle.html" class="code" title="function out = point_in_triangle(P,E,V,epsilon, str)">point_in_triangle</a>	POINT_IN_TRIANGLE tests points for membership in triangles</li><li><a href="../../eidors/models/private/uniquetol.html" class="code" title="function out = uniquetol(in, tol, varargin)">uniquetol</a>	C = uniquetol(A,TOL):  unique values in A using tolerance TOL.</li><li><a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>	SPARSE Create sparse matrix (EIDORS overload).</li><li><a href="../../eidors/overloads/uniquetol.html" class="code" title="function out = uniquetol(in, tol, varargin)">uniquetol</a>	C = uniquetol(A,TOL):  unique values in A using tolerance TOL.</li><li><a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>	EIDORS_CACHE Control eidors caching</li><li><a href="../../eidors/tools/eidors_debug.html" class="code" title="function out = eidors_debug(command, fstr)">eidors_debug</a>	EIDORS_DEBUG Global managment of debug flags</li><li><a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>	PROGRESS_MSG Progress messages and timing.</li><li><a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>	UNIT_TEST_CMP: compare matrices in eidors output</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="mk_analytic_c2f.html" class="code" title="function [mapping, outside] = mk_analytic_c2f( f_mdl, c_mdl, opt)">mk_analytic_c2f</a>	MK_ANALYTIC_C2F: create a mapping matrix from coarse to fine FEM</li><li><a href="mk_tri_c2f.html" class="code" title="function c2f = mk_tri_c2f(fmdl,rmdl,opt)">mk_tri_c2f</a>	MK_TRI_C2F - calculate a coarse2fine mapping for triangle-based models.</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function c2f = do_mk_tri_c2f(fmdl,rmdl,opt)</a></li><li><a href="#_sub2" class="code">function [pts,FE2CE,FE2pts,CE2pts] = find_edge2edge_intersections(FE,FN,CE,CN)</a></li><li><a href="#_sub3" class="code">function fmdl = prepare_tri_mdl(fmdl)</a></li><li><a href="#_sub4" class="code">function [fmdl,rmdl,fmdl_idx,rmdl_idx] = crop_models(fmdl,rmdl)</a></li><li><a href="#_sub5" class="code">function[fmdl,rmdl] = center_scale_models(fmdl,rmdl, opt)</a></li><li><a href="#_sub6" class="code">function opt = parse_opts(fmdl,rmdl, opt)</a></li><li><a href="#_sub7" class="code">function do_unit_test</a></li><li><a href="#_sub8" class="code">function do_small_test</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function c2f = mk_tri_c2f(fmdl,rmdl,opt)</a>
0002 <span class="comment">%MK_TRI_C2F - calculate a coarse2fine mapping for triangle-based models.</span>
0003 <span class="comment">% C2F = MK_TRI_C2F(FMDL,RMDL) returns in C2F the fraction of area of</span>
0004 <span class="comment">% each element of the fine model FMDL contained in each element of</span>
0005 <span class="comment">% the coarse model RMDL.</span>
0006 <span class="comment">% Uses CONVHULLN to calculate the area defined by a set of intersection</span>
0007 <span class="comment">% points between individual triangles.</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% C2F = MK_TRI_C2F(FMDL,RMDL,OPT) allows specifying options.</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% Inputs:</span>
0012 <span class="comment">%   FMDL - a (fine) EIDORS (tet-based) forward model</span>
0013 <span class="comment">%   RMDL - a (course) EIDORS (tet-based) forward model</span>
0014 <span class="comment">%   OPT  - an option structure with the following fields and defaults:</span>
0015 <span class="comment">%      .do_not_scale  - set to true to prevent scaling the models to unit</span>
0016 <span class="comment">%                       square before any calculations, including</span>
0017 <span class="comment">%                       thresholds. Default: false</span>
0018 <span class="comment">%      .tol_node2tri  - minimum value of a barycentric coordinate to</span>
0019 <span class="comment">%                       decide a point is lying inside a triangle and not</span>
0020 <span class="comment">%                       on its edge. Default: eps</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% NOTE that for grid-based models, such as returned by MK_GRID_MODEL or</span>
0023 <span class="comment">% MK_VOXEL_VOLUME, MK_GRID_C2F is much faster.</span>
0024 <span class="comment">%</span>
0025 <span class="comment">% Set eidors_msg 'log level' &lt; 2 to supress output to command line.</span>
0026 <span class="comment">%</span>
0027 <span class="comment">% Examples:</span>
0028 <span class="comment">%     fmdl = ng_mk_cyl_models([0,2,.2],[],[]);</span>
0029 <span class="comment">%     rmdl = ng_mk_cyl_models([0,2],[],[]);</span>
0030 <span class="comment">%     c2f  = mk_tri_c2f(fmdl,rmdl);</span>
0031 <span class="comment">%     h = show_fem(fmdl); set(h,'LineWidth',0.1,'FaceColor','none')</span>
0032 <span class="comment">%     hold on</span>
0033 <span class="comment">%     h = show_fem(rmdl); set(h,'EdgeColor','b','LineWidth',2,...</span>
0034 <span class="comment">%        'FaceColor','none');</span>
0035 <span class="comment">%     hold off</span>
0036 <span class="comment">%</span>
0037 <span class="comment">% See also MK_GRID_C2F, FIND_EDGE2EDGE_INTERSECTIONS, CONVHULLN</span>
0038 <span class="comment">%          MK_APPROX_C2F, POINT_IN_TRIANGLE, EIDORS_MSG</span>
0039 
0040 <span class="comment">% (C) 2015 Bartlomiej Grychtol</span>
0041 <span class="comment">% License: GPL version 2 or 3</span>
0042 <span class="comment">% $Id: mk_tri_c2f.m 6152 2021-10-18 12:51:37Z aadler $</span>
0043 
0044 
0045 <span class="keyword">if</span> ischar(fmdl) &amp;&amp; strcmp(fmdl,<span class="string">'UNIT_TEST'</span>), <a href="#_sub7" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0046 <span class="keyword">if</span> nargin &lt; 3
0047    opt = struct();
0048 <span class="keyword">end</span>
0049 
0050 f_elems = size(fmdl.elems,1);
0051 r_elems = size(rmdl.elems,1);
0052 
0053 c2f = <a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(f_elems,r_elems);
0054 [fmdl,rmdl,fmdl_idx,rmdl_idx] = <a href="#_sub4" class="code" title="subfunction [fmdl,rmdl,fmdl_idx,rmdl_idx] = crop_models(fmdl,rmdl)">crop_models</a>(fmdl,rmdl);
0055 
0056 <span class="keyword">if</span> ~(any(fmdl_idx) &amp;&amp; any(rmdl_idx))
0057    <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@: models do not overlap, returning all-zeros'</span>);
0058    <span class="keyword">return</span>
0059 <span class="keyword">end</span>
0060 
0061 [fmdl,rmdl] = <a href="#_sub5" class="code" title="subfunction[fmdl,rmdl] = center_scale_models(fmdl,rmdl, opt)">center_scale_models</a>(fmdl,rmdl, opt);
0062 
0063 opt = <a href="#_sub6" class="code" title="subfunction opt = parse_opts(fmdl,rmdl, opt)">parse_opts</a>(fmdl,rmdl, opt);
0064 
0065 
0066 copt.fstr = <span class="string">'mk_tri_c2f'</span>;
0067 
0068 c2f(fmdl_idx,rmdl_idx) = <a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub1" class="code" title="subfunction c2f = do_mk_tri_c2f(fmdl,rmdl,opt)">do_mk_tri_c2f</a>,{fmdl,rmdl,opt},copt);
0069 <span class="keyword">end</span>
0070 
0071 <a name="_sub1" href="#_subfunctions" class="code">function c2f = do_mk_tri_c2f(fmdl,rmdl,opt)</a>
0072    DEBUG = <a href="../../eidors/tools/eidors_debug.html" class="code" title="function out = eidors_debug(command, fstr)">eidors_debug</a>(<span class="string">'query'</span>,<span class="string">'mk_tri_c2f'</span>);
0073    
0074    c2f = <a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(0,0);
0075    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Prepare fine model...'</span>);
0076    fmdl = <a href="#_sub3" class="code" title="subfunction fmdl = prepare_tri_mdl(fmdl)">prepare_tri_mdl</a>(fmdl);
0077    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(Inf);
0078    
0079    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Prepare course model...'</span>);
0080    rmdl = <a href="#_sub3" class="code" title="subfunction fmdl = prepare_tri_mdl(fmdl)">prepare_tri_mdl</a>(rmdl);
0081    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(Inf);
0082    
0083    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Find edge2edge intersections...'</span>);
0084    [intpts,fedge2redge,fedge2intpts,redge2intpts] = <span class="keyword">...</span>
0085       <a href="find_edge2edge_intersections.html" class="code" title="function [pts,FE2CE,FE2pts,CE2pts] = find_edge2edge_intersections(FE,FN,CE,CN, epsilon)">find_edge2edge_intersections</a>( fmdl.edges,fmdl.nodes,<span class="keyword">...</span>
0086                                     rmdl.edges,rmdl.nodes);
0087    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(sprintf(<span class="string">'Found %d'</span>,size(intpts,1)),Inf);
0088 
0089    
0090    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Find c_nodes in f_elems...'</span>);
0091    rnode2ftri = <a href="point_in_triangle.html" class="code" title="function out = point_in_triangle(P,E,V,epsilon, str)">point_in_triangle</a>(rmdl.nodes, fmdl.elems, fmdl.nodes, opt.tol_node2tri);
0092    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(sprintf(<span class="string">'Found %d'</span>, nnz(rnode2ftri)), Inf);
0093    
0094    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Find c_elems in f_elems...'</span>)
0095    rtri_in_ftri = (double(rmdl.node2elem') * rnode2ftri) == 3;
0096    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(sprintf(<span class="string">'Found %d'</span>,nnz(rtri_in_ftri)), Inf);
0097    
0098    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Find f_nodes in c_elems...'</span>);
0099    fnode2rtri = <a href="point_in_triangle.html" class="code" title="function out = point_in_triangle(P,E,V,epsilon, str)">point_in_triangle</a>(fmdl.nodes, rmdl.elems, rmdl.nodes, opt.tol_node2tri);
0100    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(sprintf(<span class="string">'Found %d'</span>, nnz(fnode2rtri)), Inf);
0101    
0102    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Find f_elems in c_elems...'</span>)
0103    ftri_in_rtri = (double(fmdl.node2elem') * fnode2rtri) == 3;
0104    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(sprintf(<span class="string">'Found %d'</span>,nnz(ftri_in_rtri)), Inf);
0105 
0106    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Find total intersections...'</span>);
0107    rtri2ftri = double(rmdl.edge2elem') * fedge2redge' * fmdl.edge2elem;
0108    <span class="comment">% exclude inclusion (dealt with separately)</span>
0109    rtri2ftri = rtri2ftri &amp; ~rtri_in_ftri &amp; ~ftri_in_rtri'; 
0110    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(sprintf(<span class="string">'Found %d'</span>,nnz(rtri2ftri)), Inf);
0111    
0112    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Calculate intersection volumes...'</span>);
0113    <span class="comment">% sparse logical multiplication doesn't exist</span>
0114    rtri2intpt = logical(rmdl.edge2elem'*redge2intpts)';
0115    ftri2intpt = logical(fmdl.edge2elem'*fedge2intpts)';
0116    
0117    rtri_todo = find(sum(rtri2ftri,2)&gt;0);
0118    C = []; F = []; V = [];
0119 
0120    id = 0; N = length(rtri_todo);
0121    mint = ceil(N/100);
0122    <span class="keyword">for</span> v = rtri_todo'
0123       id = id+1;
0124       <span class="keyword">if</span> mod(id,mint)==0, <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(id/N); <span class="keyword">end</span>
0125       tri_todo = find(rtri2ftri(v,:));
0126 
0127       common_intpts = bsxfun(@and,rtri2intpt(:,v), ftri2intpt(:,tri_todo));
0128       
0129       f_nodes     = bsxfun(@and,fnode2rtri(:,v), fmdl.node2elem(:,tri_todo));
0130       r_nodes     = bsxfun(@and,rnode2ftri(:,tri_todo), rmdl.node2elem(:,v));
0131       
0132       C = [C; v*ones(numel(tri_todo),1)];
0133       F = [F; tri_todo'];
0134       last_v = numel(V);
0135       V = [V; zeros(numel(tri_todo),1)]; <span class="comment">% pre-allocate</span>
0136       
0137       <span class="keyword">for</span> t = 1:numel(tri_todo)
0138          pts = [ intpts(common_intpts(:,t),:);
0139                   fmdl.nodes(f_nodes(:,t),:);
0140                   rmdl.nodes(r_nodes(:,t),:)];
0141          last_v = last_v + 1;
0142          <span class="keyword">if</span> size(pts,1) &lt; 3, <span class="keyword">continue</span>, <span class="keyword">end</span> 
0143             <span class="comment">% move points to origin (helps for small elements at</span>
0144             <span class="comment">% large coordinates</span>
0145             ctr = mean(pts);
0146             pts = bsxfun(@minus,pts,ctr);
0147             scale = max(abs(pts(:)));
0148             <span class="keyword">if</span> scale == 0 <span class="comment">%happens when there's only one point</span>
0149                <span class="keyword">continue</span>
0150             <span class="keyword">end</span>
0151             <span class="comment">% scale largest coordinate to 1 (helps with precision)</span>
0152             pts = pts ./ scale;
0153             <span class="comment">% force thorough search for initinal simplex and</span>
0154             <span class="comment">% supress precision warnings</span>
0155 <span class="comment">%           if any(any(dist2(pts))); continue; end</span>
0156          pts= <a href="../../eidors/models/private/uniquetol.html" class="code" title="function out = uniquetol(in, tol, varargin)">uniquetol</a>(pts,1e-10,<span class="string">'ByRows'</span>,true,<span class="string">'DataScale'</span>,1);
0157          <span class="comment">% This won't catch all cases</span>
0158          <span class="keyword">if</span> size(pts,1)&lt;=size(pts,2); <span class="keyword">continue</span>; <span class="keyword">end</span>
0159          <span class="keyword">if</span> any(std(pts)&lt;1e-14); <span class="keyword">continue</span>; <span class="keyword">end</span>
0160          <span class="keyword">try</span>
0161             [K, V(last_v)] = convhulln(pts,{<span class="string">'Qt Pp Qs'</span>});
0162 
0163             V(last_v) = max(V(last_v),0); <span class="comment">% numerical issues may produce tiny negative volume</span>
0164             V(last_v) = V(last_v) * scale^2; <span class="comment">% undo scaling</span>
0165          <span class="keyword">catch</span> err
0166 <span class="comment">%    Save cases were errors called</span>
0167 <span class="comment">%           if ~exist('ok'); ptsi={}; end</span>
0168 <span class="comment">%           ptsi{end+1} = pts;</span>
0169 <span class="comment">%           save -mat CHP.mat ptsi;</span>
0170             ok = false;
0171             <span class="keyword">if</span> exist(<span class="string">'OCTAVE_VERSION'</span>)
0172                <span class="keyword">if</span> strcmp(err.message,<span class="string">'convhulln: qhull failed'</span>)
0173                   err.identifier =  <span class="string">'MATLAB:qhullmx:DegenerateData'</span>;
0174                <span class="keyword">end</span>
0175                   
0176             <span class="keyword">end</span>
0177             <span class="keyword">switch</span> err.identifier
0178                <span class="keyword">case</span> {<span class="string">'MATLAB:qhullmx:DegenerateData'</span>, <span class="string">'MATLAB:qhullmx:UndefinedError'</span>}
0179                   <span class="comment">% border case point may be included multiple times.</span>
0180                   <span class="comment">% this is OK... though we may miss cases where more</span>
0181                   <span class="comment">% points should have been found but were not</span>
0182                   u = <a href="../../eidors/models/private/uniquetol.html" class="code" title="function out = uniquetol(in, tol, varargin)">uniquetol</a>(pts*scale,1e-14,<span class="string">'ByRows'</span>,true,<span class="string">'DataScale'</span>, 1);
0183                   ok = ok | (size(u,1) &lt; 3);
0184                   <span class="keyword">if</span> ~ok
0185                      <span class="comment">% test for colinearity</span>
0186                      cp = bsxfun(@minus, u(2:<span class="keyword">end</span>,:), u(1,:));
0187                      l = sqrt(sum(cp.^2,2));
0188                      cp = bsxfun(@rdivide, cp, l);
0189                      u = <a href="../../eidors/models/private/uniquetol.html" class="code" title="function out = uniquetol(in, tol, varargin)">uniquetol</a>(cp,1e-14,<span class="string">'ByRows'</span>,true,<span class="string">'DataScale'</span>,1);
0190                      ok = ok | size(u,1) == 1; <span class="comment">% co-linear points</span>
0191                   <span class="keyword">end</span>
0192             <span class="keyword">end</span>
0193             <span class="keyword">if</span> ~ok
0194                <span class="keyword">if</span> DEBUG || <a href="../../eidors/tools/eidors_debug.html" class="code" title="function out = eidors_debug(command, fstr)">eidors_debug</a>(<span class="string">'query'</span>,<span class="string">'mk_tet_c2f:convhulln'</span>);
0195                   tri.nodes = fmdl.nodes;
0196                   vox.nodes = rmdl.nodes;
0197                   tri.type = <span class="string">'fwd_model'</span>;
0198                   vox.type = <span class="string">'fwd_model'</span>;
0199                   vox.elems = rmdl.elems(v,:);
0200                   vox.boundary = vox.elems;
0201                   tri.elems = fmdl.elems(tri_todo(t),:);
0202                   clf
0203                   <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(vox)
0204                   hold on
0205                   h = <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(tri);
0206                   set(h,<span class="string">'EdgeColor'</span>,<span class="string">'b'</span>)
0207                   pts = bsxfun(@plus,pts*scale,ctr);
0208                   plot(pts(:,1),pts(:,2),<span class="string">'o'</span>);
0209                   hold off
0210                   axis auto
0211                   keyboard
0212                <span class="keyword">else</span>
0213                   fprintf(<span class="string">'\n'</span>);
0214                   <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>([<span class="string">'convhulln has thrown an error. ('</span>,e.message,<span class="string">')'</span>, <span class="keyword">...</span>
0215                      <span class="string">'Enable eidors_debug on mk_tri_c2f and re-run to see a debug plot'</span>],0);
0216                   rethrow(err);
0217                <span class="keyword">end</span>
0218             <span class="keyword">end</span>
0219          <span class="keyword">end</span>
0220          
0221       <span class="keyword">end</span>
0222    <span class="keyword">end</span>
0223    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(Inf);
0224    
0225    c2f = <a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(F,C,V,size(fmdl.elems,1),size(rmdl.elems,1));
0226    
0227    <span class="comment">% add rtri contained in ftri</span>
0228    <span class="keyword">try</span> rmdl = rmfield(rmdl,<span class="string">'coarse2fine'</span>); <span class="keyword">end</span> <span class="comment">% messes with volume</span>
0229    c2f = c2f + bsxfun(@times, <a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(rtri_in_ftri), <a href="get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>(rmdl))';
0230    
0231    <span class="comment">% normalize to fine volume</span>
0232    vol = <a href="get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>(fmdl,-inf);
0233    c2f = bsxfun(@rdivide,c2f,vol);
0234    
0235    <span class="comment">% count identical triangles just once</span>
0236    ftri_in_rtri(rtri_in_ftri') = 0;
0237    
0238    <span class="comment">% add fine elems contained in coarse elems</span>
0239    c2f = c2f + ftri_in_rtri;
0240 
0241 <span class="keyword">end</span>
0242 
0243 
0244 <a name="_sub2" href="#_subfunctions" class="code">function [pts,FE2CE,FE2pts,CE2pts] = find_edge2edge_intersections(FE,FN,CE,CN)</a>
0245    P1 = FN(FE(:,1),:);
0246    P2 = FN(FE(:,2),:);
0247    P3 = CN(CE(:,1),:);
0248    P4 = CN(CE(:,2),:);
0249    
0250    P21 = P2 - P1;
0251    P43 = P4 - P3;
0252    
0253    invden = ( bsxfun(@times, P21(:,1), P43(:,2)') - <span class="keyword">...</span>
0254               bsxfun(@times, P21(:,2), P43(:,1)')       ).^-1;
0255    P13_x = bsxfun(@minus,P1(:,1),P3(:,1)');
0256    P13_y = bsxfun(@minus,P1(:,2),P3(:,2)');
0257    s = ( bsxfun(@times,-P21(:,2), P13_x) + <span class="keyword">...</span>
0258          bsxfun(@times, P21(:,1), P13_y)) .* invden;
0259    t = ( bsxfun(@times,-P43(:,2)',P13_x) + <span class="keyword">...</span>
0260          bsxfun(@times, P43(:,1)',P13_y)) .* invden;
0261 
0262    FE2CE= s &gt;= 0 &amp; s &lt;= 1 &amp; t &gt;= 0 &amp; t &lt;= 1;
0263    
0264    [fe, ce] = find(FE2CE);
0265    N_pts = size(fe,1);
0266    pts = zeros(N_pts,2);
0267    <span class="keyword">for</span> i = 1:N_pts
0268       pts(i,:) = P1(fe(i),:) + t(fe(i),ce(i)) * P21(fe(i),:);
0269    <span class="keyword">end</span>
0270    FE2CE = <a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(FE2CE);
0271    N_ce = size(CE,1);
0272    N_fe = size(FE,1);
0273    FE2pts = <a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(fe, 1:N_pts, ones(N_pts,1), N_fe, N_pts);
0274    CE2pts = <a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(ce, 1:N_pts, ones(N_pts,1), N_ce, N_pts);
0275 
0276 
0277 <span class="keyword">end</span>
0278 
0279 <span class="comment">%-------------------------------------------------------------------------%</span>
0280 <span class="comment">% Prepare model</span>
0281 <a name="_sub3" href="#_subfunctions" class="code">function fmdl = prepare_tri_mdl(fmdl)</a>
0282    fmopt.elem2edge = true;
0283    fmopt.edge2elem = true;
0284 <span class="comment">%    fmopt.face2elem = true;</span>
0285    fmopt.node2elem = true;
0286 <span class="comment">%    fmopt.normals   = true;</span>
0287    fmopt.linear_reorder = false; <span class="comment">% this is slow and not needed</span>
0288    ll = <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>,1);
0289    fmdl = <a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>(fmdl,fmopt);
0290    <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>,ll);
0291    fmdl.node2elem = logical(fmdl.node2elem);
0292 
0293 <span class="keyword">end</span>
0294 
0295 <span class="comment">%-------------------------------------------------------------------------%</span>
0296 <span class="comment">% Remove obviously non-overlapping parts of the models</span>
0297 <a name="_sub4" href="#_subfunctions" class="code">function [fmdl,rmdl,fmdl_idx,rmdl_idx] = crop_models(fmdl,rmdl)</a>
0298 
0299 <span class="comment">% instead of the usual approach, we could calculate the convex hull and</span>
0300 <span class="comment">% then use inpolygon... but that would require trusting inpolygon</span>
0301 
0302    f_min = min(fmdl.nodes);
0303    f_max = max(fmdl.nodes);
0304    r_min = min(rmdl.nodes);
0305    r_max = max(rmdl.nodes);
0306    
0307    <span class="comment">% nodes outside the bounding box of the other model</span>
0308    f_gt  = bsxfun(@gt, fmdl.nodes, r_max);
0309    f_lt  = bsxfun(@lt, fmdl.nodes, r_min);
0310    r_gt  = bsxfun(@gt, rmdl.nodes, f_max);
0311    r_lt  = bsxfun(@lt, rmdl.nodes, f_min);
0312 
0313    <span class="comment">% elems outside the bounding box of the other model</span>
0314    re_gt = any(reshape(all(reshape(r_gt(rmdl.elems',:),3,[])),[],2),2);
0315    re_lt = any(reshape(all(reshape(r_lt(rmdl.elems',:),3,[])),[],2),2);
0316    fe_gt = any(reshape(all(reshape(f_gt(fmdl.elems',:),3,[])),[],2),2);
0317    fe_lt = any(reshape(all(reshape(f_lt(fmdl.elems',:),3,[])),[],2),2);
0318    
0319    <span class="comment">% elems to keep</span>
0320    rmdl_idx = ~(re_gt | re_lt);
0321    fmdl_idx = ~(fe_gt | fe_lt);
0322    
0323    <span class="comment">% remove non-overlapping elems</span>
0324    rmdl.elems = rmdl.elems(rmdl_idx,:);
0325    fmdl.elems = fmdl.elems(fmdl_idx,:);
0326    
0327    <span class="comment">% remove unused nodes</span>
0328    [r_used_nodes,jnk,r_n] = unique(rmdl.elems(:));
0329    [f_used_nodes,jnk,f_n] = unique(fmdl.elems(:));
0330    
0331    r_idx = 1:numel(r_used_nodes);
0332    f_idx = 1:numel(f_used_nodes);
0333    
0334    rmdl.elems = reshape(r_idx(r_n),[],3);
0335    fmdl.elems = reshape(f_idx(f_n),[],3);
0336    
0337    rmdl.nodes = rmdl.nodes(r_used_nodes,:);
0338    fmdl.nodes = fmdl.nodes(f_used_nodes,:);
0339    
0340    <span class="comment">% for the benefit of any (debug) plots later on</span>
0341    <span class="keyword">try</span>, rmdl = rmfield(rmdl,<span class="string">'boundary'</span>); <span class="keyword">end</span>
0342    <span class="keyword">try</span>, fmdl = rmfield(fmdl,<span class="string">'boundary'</span>); <span class="keyword">end</span>
0343     
0344 <span class="keyword">end</span>
0345 
0346 <span class="comment">%-------------------------------------------------------------------------%</span>
0347 <span class="comment">% Center scale models</span>
0348 <a name="_sub5" href="#_subfunctions" class="code">function[fmdl,rmdl] = center_scale_models(fmdl,rmdl, opt)</a>
0349    ctr = mean([min(rmdl.nodes);max(rmdl.nodes)]);
0350    rmdl.nodes = bsxfun(@minus,rmdl.nodes,ctr);
0351    fmdl.nodes = bsxfun(@minus,fmdl.nodes,ctr);
0352    <span class="keyword">if</span> isfield(opt,<span class="string">'do_not_scale'</span>) &amp;&amp; opt.do_not_scale
0353       <span class="keyword">return</span>
0354    <span class="keyword">end</span>
0355    maxnode = min( max(abs(rmdl.nodes(:))), max(abs(fmdl.nodes(:))));
0356    scale = 1/maxnode;
0357    rmdl.nodes = scale*rmdl.nodes;
0358    fmdl.nodes = scale*fmdl.nodes;
0359    <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@ models scaled by %g'</span>, scale,2);
0360 <span class="keyword">end</span>
0361 
0362 <span class="comment">%-------------------------------------------------------------------------%</span>
0363 <span class="comment">% Parse option struct</span>
0364  <a name="_sub6" href="#_subfunctions" class="code">function opt = parse_opts(fmdl,rmdl, opt)</a>
0365   
0366     <span class="keyword">if</span> ~isfield(opt, <span class="string">'tol_node2tri'</span>);
0367         opt.tol_node2tri = eps; <span class="comment">% * max(rmdl_rng,fmdl_rng)^3;</span>
0368     <span class="keyword">end</span>
0369 
0370     <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@ node2tri  tolerance = %g'</span>, opt.tol_node2tri,2);
0371 
0372  <span class="keyword">end</span>   
0373 
0374 <a name="_sub7" href="#_subfunctions" class="code">function do_unit_test</a>
0375    <a href="#_sub8" class="code" title="subfunction do_small_test">do_small_test</a>
0376 <span class="keyword">end</span>
0377 
0378 <a name="_sub8" href="#_subfunctions" class="code">function do_small_test</a>
0379    imdl = <a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'a2c'</span>,16);
0380    rmdl = imdl.fwd_model;
0381 <span class="comment">%    rmdl = ng_mk_cyl_models([0 .5],[],[]);</span>
0382 <span class="comment">%    rmdl.nodes(:,1) = rmdl.nodes(:,1) + .5;</span>
0383 <span class="comment">%    show_fem(rmdl,[0 0 1])</span>
0384 <span class="comment">%    hold all</span>
0385    imdl = <a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'d2c'</span>,16);
0386    fmdl = imdl.fwd_model;
0387 <span class="comment">%    fmdl = ng_mk_cyl_models([0 .5 .1],[],[]);</span>
0388 <span class="comment">%    h = show_fem(fmdl);</span>
0389 <span class="comment">%    set(h,'edgecolor','b','facecolor','none');</span>
0390 <span class="comment">%    hold off</span>
0391 <span class="comment">%    axis auto</span>
0392    c2f = <a href="mk_tri_c2f.html" class="code" title="function c2f = mk_tri_c2f(fmdl,rmdl,opt)">mk_tri_c2f</a>(fmdl,rmdl);
0393    
0394    
0395    clf
0396    img1 = <a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(fmdl,0);
0397    img1.elem_data = sum(c2f,2);
0398    img1.calc_colous.ref_level = .5;
0399    img1.calc_colours.clim = .5;
0400    
0401    subplot(121)
0402    <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img1);
0403    img2 = <a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(rmdl,0);
0404    img2.elem_data = (c2f' * <a href="get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>(fmdl)) ./ <a href="get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>(rmdl);
0405    img2.calc_colous.ref_level = .5;
0406    img2.calc_colours.clim = .55;
0407    subplot(122)
0408    <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img2);
0409    
0410    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Check C2F size'</span>, size(c2f),[length(fmdl.elems), length(rmdl.elems)]);
0411    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Check C2F max==1'</span>, max(c2f(:)), 1);
0412    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Check C2F min==0'</span>, min(c2f(:)), 0);
0413    
0414    f2c = bsxfun(@rdivide, bsxfun(@times, c2f, <a href="get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>(fmdl))', <a href="get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>(rmdl));
0415    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Check F2C max==1'</span>, max(sum(f2c,2)), 1, 1e-15);
0416    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Check F2C min==0'</span>, min(f2c(:)), 0);
0417 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 30-Dec-2022 20:46:51 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>
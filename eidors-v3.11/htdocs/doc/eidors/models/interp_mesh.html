<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of interp_mesh</title>
  <meta name="keywords" content="interp_mesh">
  <meta name="description" content="INTERP_MESH: calculate interpolation points onto mdl elements">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">eidors</a> &gt; <a href="index.html">models</a> &gt; interp_mesh.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/models&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>interp_mesh
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>INTERP_MESH: calculate interpolation points onto mdl elements</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function mdl_pts = interp_mesh( mdl, n_interp) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> INTERP_MESH: calculate interpolation points onto mdl elements
    mdl_pts = interp_mesh( fwd_model, n_interp)
 INPUT:
    fwd_model: fwd_model structure
    n_interp:  order of interpolation
      n_interp = 0 - output elem centres (default)
      n_interp &gt;=1 - output multiple points per elem
           in 2D: (n_int+1)*(n_int+2)/2 points per elem
           in 3D: (n_int+1)*(n_int+2)*(n_int+3)/6 points per elem
   n_interp may be specified as:
      fwd_model.interp_mesh.n_interp (This overrides the above)

 OUTPUT:
    mdl_pts = N_elems x N_dims x N_points
   example: for mdl_pts= interp_mesh( mdl, 0);
           mdl_pts(i,:) is centre of element #i      
   example: for mdl_pts= interp_mesh( mdl, 2);
           mdl_pts(i,:,:) is 1 x [x,y,{z}] x n_points to interpolate
 
 EXAMPLE:
   mdl.nodes= [4,6,8,4,6,8;2,2,2,5,5,5]';
   mdl.elems=[1,2,4;2,4,5;2,3,5;3,5,6];
   mdl.type='fwd_model';mdl.name='jnk';
   pp=interp_mesh(mdl,4);
   show_fem(mdl); hold on ;
      for i=1:size(pp,3); plot(pp(:,1,i),pp(:,2,i),'*'); end ;
   hold off</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="elem_dim.html" class="code" title="function num = elem_dim( mdl );">elem_dim</a>	ELEM_DIM: dimension of elements in space (are elements in 2D or 3D space)</li><li><a href="interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>	INTERP_MESH: calculate interpolation points onto mdl elements</li><li><a href="mdl_dim.html" class="code" title="function num = mdl_dim( mdl );">mdl_dim</a>	MDL_DIM: dimension of model space (are nodes in 2D or 3D space)</li><li><a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="num_elems.html" class="code" title="function num = num_elems( mdl );">num_elems</a>	NUM_ELEMS: number of elemnts in a (fwd or inv model or image)</li><li><a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>	EIDORS_CACHE Control eidors caching</li><li><a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>	UNIT_TEST_CMP: compare matrices in eidors output</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../eidors/graphics/matlab/show_current.html" class="code" title="function quiv = show_current( img, vv )">show_current</a>	SHOW_CURRENT: show current or other quantity defined</li><li><a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>	SHOW_FEM: show the EIDORS3D finite element model</li><li><a href="../../eidors/graphics/matlab/show_fem_enhanced.html" class="code" title="function hh = show_fem_enhanced(mdl, options)">show_fem_enhanced</a>	SHOW_FEM_ENHANCED: show the EIDORS3D finite element model</li><li><a href="../../eidors/meshing/netgen/ng_mk_cyl_models.html" class="code" title="function [fmdl,mat_idx] = ng_mk_cyl_models(cyl_shape, elec_pos,elec_shape, extra_ng_code);">ng_mk_cyl_models</a>	NG_MAKE_CYL_MODELS: create cylindrical models using netgen</li><li><a href="calc_model_reduction.html" class="code" title="function mr = calc_model_reduction(fmdl)">calc_model_reduction</a>	calc_model_reduction: calculate the fields for a reduced model</li><li><a href="elem_select.html" class="code" title="function memb_frac = elem_select( fmdl, select_fcn )">elem_select</a>	ELEM_SELECT: select element fractions inside a function</li><li><a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>	FIX_MODEL: Add useful fields to a model</li><li><a href="interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>	INTERP_MESH: calculate interpolation points onto mdl elements</li><li><a href="mk_GREIT_model.html" class="code" title="function [imdl, weight]= mk_GREIT_model( fmdl, radius, weight, options )">mk_GREIT_model</a>	MK_GREIT_MODEL: make EIDORS inverse models using the GREIT approach</li><li><a href="mk_approx_c2f.html" class="code" title="function [mapping, outside] = mk_approx_c2f( f_mdl, c_mdl );">mk_approx_c2f</a>	MK_APPROX_C2F: create a mapping matrix from coarse to fine FEM</li><li><a href="mk_c2f_circ_mapping.html" class="code" title="function [mapping failed] = mk_c2f_circ_mapping( mdl, xyzr );">mk_c2f_circ_mapping</a>	MK_C2F_CIRC_MAPPING: create a mapping matrix from circles/spheres to FEM</li><li><a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>	MK_GRID_C2F - calculate a coarse2fine mapping for grid coarse models.</li><li><a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>	MK_GRID_MODEL: Create reconstruction model on pixelated grid</li><li><a href="select_imdl.html" class="code" title="function inv_mdl= select_imdl( mdl, options )">select_imdl</a>	SELECT_IMDL: select pre-packaged inverse model features</li><li><a href="simulate_2d_movement.html" class="code" title="function [vh,vi,xyr_pt]= simulate_2d_movement( n_sims, fmdl, rad_pr, movefcn )">simulate_2d_movement</a>	SIMULATE_2D_MOVEMENT simulate rotational movement in 2D</li><li><a href="simulate_3d_movement.html" class="code" title="function [vh,vi,xyzr_pt]= simulate_3d_movement( n_sims, fmdl, rad_pr,movefcn )">simulate_3d_movement</a>	SIMULATE_3D_MOVEMENT simulate rotational movement in 3D</li><li><a href="solve_RM_2Dslice.html" class="code" title="function imdl = solve_RM_2Dslice(imdl, sel_fcn)">solve_RM_2Dslice</a>	SOLVE_RM_2DSLICE: cut slices out of a 3D model</li><li><a href="../../eidors/solvers/forward/jacobian_movement_2p5d_1st_order.html" class="code" title="function J = jacobian_movement_2p5d_1st_order( fwd_model, img)">jacobian_movement_2p5d_1st_order</a>	JACOBIAN_MOVEMENT_2P5D: J = jacobian_movement_2p5d_1st_order( img )</li><li><a href="../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>	INV_SOLVE: calculate imag from an inv_model and data</li><li><a href="../../eidors/solvers/inverse/GREIT_desired_img_FEMmesh.html" class="code" title="function PSF= GREIT_desired_img_FEMmesh(xyc, radius, opt)">GREIT_desired_img_FEMmesh</a>	GREIT_DESIRED_IMG_FEMmesh  GREIT onto a FEM mesh</li><li><a href="../../eidors/solvers/inverse/inv_solve_abs_annealingMetropolis_params.html" class="code" title="function [img]= inv_solve_abs_annealingMetropolis_params(inv_model, data)">inv_solve_abs_annealingMetropolis_params</a>	INV_SOLVE_ABS_ANNEALINGSIMPLEX_PARAMS absolute solver using the simplex annealing method.</li><li><a href="../../eidors/solvers/inverse/inv_solve_abs_annealingSimplex_params.html" class="code" title="function [img]= inv_solve_abs_annealingSimplex_params(inv_model, data)">inv_solve_abs_annealingSimplex_params</a>	INV_SOLVE_ABS_ANNEALINGSIMPLEX_PARAMS absolute solver using the simplex annealing method.</li><li><a href="../../eidors/solvers/inverse/inv_solve_core.html" class="code" title="function img= inv_solve_core( inv_model, data0, data1);">inv_solve_core</a>	INV_SOLVE_CORE Solver using a generic iterative algorithm</li><li><a href="../../eidors/solvers/inverse/inv_solve_gn.html" class="code" title="function img= inv_solve_gn( inv_model, data1, data2);">inv_solve_gn</a>	function img= inv_solve_gn( inv_model, data1);</li><li><a href="../../eidors/solvers/inverse/mk_GN_model.html" class="code" title="function imdl = mk_GN_model(img, opt, lambda)">mk_GN_model</a>	MK_GN_MODEL: make EIDORS inverse models using the GREIT approach</li><li><a href="../../eidors/solvers/inverse/prior_gaussian_HPF.html" class="code" title="function Reg= prior_gaussian_HPF( fwd_model );">prior_gaussian_HPF</a>	PRIOR_GAUSSIAN_HPF calculate image prior</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function mdl_pts = do_interpolation(mdl, n_interp)</a></li><li><a href="#_sub2" class="code">function interp= triangle_interpolation(n_interp, el_dim)</a></li><li><a href="#_sub3" class="code">function do_unit_test</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function mdl_pts = interp_mesh( mdl, n_interp)</a>
0002 <span class="comment">% INTERP_MESH: calculate interpolation points onto mdl elements</span>
0003 <span class="comment">%    mdl_pts = interp_mesh( fwd_model, n_interp)</span>
0004 <span class="comment">% INPUT:</span>
0005 <span class="comment">%    fwd_model: fwd_model structure</span>
0006 <span class="comment">%    n_interp:  order of interpolation</span>
0007 <span class="comment">%      n_interp = 0 - output elem centres (default)</span>
0008 <span class="comment">%      n_interp &gt;=1 - output multiple points per elem</span>
0009 <span class="comment">%           in 2D: (n_int+1)*(n_int+2)/2 points per elem</span>
0010 <span class="comment">%           in 3D: (n_int+1)*(n_int+2)*(n_int+3)/6 points per elem</span>
0011 <span class="comment">%   n_interp may be specified as:</span>
0012 <span class="comment">%      fwd_model.interp_mesh.n_interp (This overrides the above)</span>
0013 <span class="comment">%</span>
0014 <span class="comment">% OUTPUT:</span>
0015 <span class="comment">%    mdl_pts = N_elems x N_dims x N_points</span>
0016 <span class="comment">%   example: for mdl_pts= interp_mesh( mdl, 0);</span>
0017 <span class="comment">%           mdl_pts(i,:) is centre of element #i</span>
0018 <span class="comment">%   example: for mdl_pts= interp_mesh( mdl, 2);</span>
0019 <span class="comment">%           mdl_pts(i,:,:) is 1 x [x,y,{z}] x n_points to interpolate</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% EXAMPLE:</span>
0022 <span class="comment">%   mdl.nodes= [4,6,8,4,6,8;2,2,2,5,5,5]';</span>
0023 <span class="comment">%   mdl.elems=[1,2,4;2,4,5;2,3,5;3,5,6];</span>
0024 <span class="comment">%   mdl.type='fwd_model';mdl.name='jnk';</span>
0025 <span class="comment">%   pp=interp_mesh(mdl,4);</span>
0026 <span class="comment">%   show_fem(mdl); hold on ;</span>
0027 <span class="comment">%      for i=1:size(pp,3); plot(pp(:,1,i),pp(:,2,i),'*'); end ;</span>
0028 <span class="comment">%   hold off</span>
0029 <span class="comment">%</span>
0030 
0031 <span class="comment">% (C) 2008 Andy Adler. License: GPL version 2 or version 3</span>
0032 <span class="comment">% $Id: interp_mesh.m 5866 2018-12-05 17:09:40Z aadler $</span>
0033 
0034 <span class="keyword">if</span> ischar(mdl) &amp;&amp; strcmp(mdl,<span class="string">'UNIT_TEST'</span>); <a href="#_sub3" class="code" title="subfunction do_unit_test">do_unit_test</a>;<span class="keyword">return</span>; <span class="keyword">end</span>
0035 
0036 <span class="keyword">if</span> nargin&lt;2; n_interp=0; <span class="keyword">end</span>
0037 <span class="keyword">if</span> strcmp(mdl.type,<span class="string">'image'</span>) || strcmp(mdl.type,<span class="string">'inv_model'</span>)
0038    mdl = mdl.fwd_model;
0039 <span class="keyword">end</span>
0040 
0041 
0042 <span class="keyword">try</span> n_interp = mdl.interp_mesh.n_interp; <span class="keyword">end</span> <span class="comment">% Override if provided</span>
0043 
0044 
0045 copt.cache_obj = {mdl.elems, mdl.nodes, n_interp};
0046 copt.fstr = <span class="string">'interp_mesh'</span>;
0047 copt.boost_priority = -2;
0048 
0049 mdl_pts = <a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub1" class="code" title="subfunction mdl_pts = do_interpolation(mdl, n_interp)">do_interpolation</a>,{mdl, n_interp},copt);
0050 
0051 
0052 <a name="_sub1" href="#_subfunctions" class="code">function mdl_pts = do_interpolation(mdl, n_interp)</a>
0053    <span class="comment">% Get element nodes, and reshape</span>
0054    <span class="comment">% need to be of size n_dims_1 x (n_elems*n_dims) for reshape</span>
0055    el_nodes= mdl.nodes(mdl.elems',:);
0056    el_nodes= reshape(el_nodes, <a href="elem_dim.html" class="code" title="function num = elem_dim( mdl );">elem_dim</a>(mdl)+1, []);
0057 
0058    <span class="comment">% Get interpolation matrix</span>
0059    interp= <a href="#_sub2" class="code" title="subfunction interp= triangle_interpolation(n_interp, el_dim)">triangle_interpolation</a>( n_interp, <a href="elem_dim.html" class="code" title="function num = elem_dim( mdl );">elem_dim</a>(mdl) );
0060    l_interp = size(interp,1);
0061 
0062    mdl_pts = interp*el_nodes;
0063    mdl_pts = reshape(mdl_pts, l_interp, <a href="num_elems.html" class="code" title="function num = num_elems( mdl );">num_elems</a>(mdl), <a href="mdl_dim.html" class="code" title="function num = mdl_dim( mdl );">mdl_dim</a>(mdl));
0064 
0065    mdl_pts = permute(mdl_pts, [2,3,1]);
0066    
0067    
0068    
0069 <span class="comment">% interpolate over a triangle with n_interp points</span>
0070 <span class="comment">% generate a set of points to fairly cover the triangle</span>
0071 <span class="comment">% dim_coarse is dimensions + 1 of coarse model</span>
0072 <a name="_sub2" href="#_subfunctions" class="code">function interp= triangle_interpolation(n_interp, el_dim)</a>
0073     interp= zeros(0,el_dim+1);
0074 
0075     <span class="keyword">switch</span> el_dim
0076      <span class="keyword">case</span> 1;
0077        <span class="keyword">for</span> i=0:n_interp
0078              interp= [interp;i,n_interp-i];
0079        <span class="keyword">end</span>
0080      <span class="keyword">case</span> 2;
0081        <span class="keyword">for</span> i=0:n_interp
0082           <span class="keyword">for</span> j=0:n_interp-i
0083              interp= [interp;i,j,n_interp-i-j];
0084           <span class="keyword">end</span>
0085        <span class="keyword">end</span>
0086      <span class="keyword">case</span> 3;
0087        <span class="keyword">for</span> i=0:n_interp
0088           <span class="keyword">for</span> j=0:n_interp-i
0089              <span class="keyword">for</span> k=0:n_interp-i-j
0090                 interp= [interp;i,j,k,n_interp-i-j-k];
0091              <span class="keyword">end</span>
0092           <span class="keyword">end</span>
0093        <span class="keyword">end</span>
0094      <span class="keyword">otherwise</span>;
0095        error(<span class="string">'Element is not 1D (line), 2D (triangle) or 3D (tetrahedron)'</span>);
0096     <span class="keyword">end</span>
0097 
0098     interp= (interp + 1/(el_dim+1) )/(n_interp+1);
0099 
0100 
0101 <a name="_sub3" href="#_subfunctions" class="code">function do_unit_test</a>
0102     mdl.type=<span class="string">'fwd_model'</span>;mdl.name=<span class="string">'jnk'</span>;
0103     mdl.nodes= [4,6,8,4]';
0104     mdl.elems=[1,2;2,4;2,3;4,4];
0105     pp=<a href="interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>(mdl,0);
0106     <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'1D/1D (#1): '</span>,pp,[5;5;7;4]);
0107 
0108     mdl.nodes= [4,6,8,4;2,2,2,6]';
0109     pp=<a href="interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>(mdl,0);
0110     <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'1D/2D (#1): '</span>,pp,[5 2;5 4;7 2;4 6]);
0111 
0112     mdl.nodes= 3*[4,6,8,4,6,8;2,2,2,5,5,5]';
0113     mdl.elems=[1,2,4;2,4,5;2,3,5;3,5,6];
0114     pp=<a href="interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>(mdl,0);
0115     <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'2D/2D (#1): '</span>,pp,[14 9;16 12; 20 9;22 12]);
0116 
0117     pp=<a href="interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>(mdl,3);
0118     <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'2D/2D (#2): '</span>,pp(:,:,6),[14 9;16 12; 20 9;22 12]);
0119 
0120     mdl.nodes = [mdl.nodes, 0*mdl.nodes(:,1)+3];
0121     pp=<a href="interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>(mdl,0);
0122     <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'2D/3D (#1): '</span>,pp,[14 9 3;16 12 3; 20 9 3;22 12 3]);
0123 
0124     mdl = <a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'n3r2'</span>,[16,2]); mdl= mdl.fwd_model;
0125     pp=<a href="interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>(mdl,0);
0126     <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'3D/3D (#1): '</span>,pp(1,:),[0.920196320100808   0.048772580504032   0.5],1e-14);
0127 
0128     pp=<a href="interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>(mdl,4);
0129     <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'3D/3D (#2a):'</span>,pp(1,:,21),[0.920196320100808   0.048772580504032   0.5],1e-14);
0130</pre></div>
<hr><address>Generated on Fri 30-Dec-2022 20:46:51 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>
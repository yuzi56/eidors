<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of mk_geophysics_model</title>
  <meta name="keywords" content="mk_geophysics_model">
  <meta name="description" content="imdl = mk_geophysics_model(str, ne, [option])">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">eidors</a> &gt; <a href="index.html">models</a> &gt; mk_geophysics_model.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/models&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>mk_geophysics_model
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>imdl = mk_geophysics_model(str, ne, [option])</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function imdl = mk_geophysics_model(str, ne, opt); </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> imdl = mk_geophysics_model(str, ne, [option])

 ne  - number of electrodes, 5 metre spacing (+5,+10,...)
       and 0.1 metre diameter
         OR
       a list of electrode locations in the x-dimension or a 2- or
       3-dimensional array, one electrode per row, missing columns
       will be set to zero
       ne = 16
       ne = [4 6 10 20] % 1d: (x)
       ne = [0 1; 2 1.5; 3 1.2; 7 2.5] % 2d: (x,y)
       ne = [0 0.1 1; 2 -0.1 1.5; 3 -0.15 1.2; 7 0 2.5] % 3d: (x,y,z)
 str - model, x = see hmax_rec
       h2x -   2D half-space, linear CEM array (2d fwd)
       h2p5x - 2.5D half-space, linear CEM array (2d fwd + Fourier y-dimension)
       h3x   - 3D half-space, linear CEM array (3d fwd)
       h22x  - 2D half-space, linear CEM array (2d fwd, 2d rec)
       h32x  - 2D half-space, linear CEM array (3d fwd, 2d rec)
       h33x  - 2D half-space, linear CEM array (3d fwd, 3d rec)
       H2x -   2D half-space, linear PEM array (2d fwd)
       H2p5x - 2.5D half-space, linear PEM array (2d fwd + Fourier y-dimension)
       H3x   - 3D half-space, linear PEM array (3d fwd)
       H22x  - 2D half-space, linear PEM array (2d fwd, 2d rec)
       H32x  - 2D half-space, linear PEM array (3d fwd, 2d rec)
       H33x  - 2D half-space, linear PEM array (3d fwd, 3d rec)
 opt - override default configuration options (optional cell array)
       'hmax_fwd' - fine reconstruction mesh density, given an
                    array width xw, and electrode spacing es
                    Note that for ne=16, 'A' and 'a' are equivalent.
                ['a' : hmax_fwd=xw/1;    ['A' : hmax_fwd=es*16;
                 'b' : hmax_fwd=xw/2;     'B' : hmax_fwd=es*8;
                 'c' : hmax_fwd=xw/4;     'C' : hmax_fwd=es*4;
                 ...                       ...
                 'z' : hmax_fwd=xw/2^25]  'Z' : hmax_fwd=es*2^-21]
       'hmax_fwd_inner'
                  - reconstruction model mesh density for the inner region
                    [default: 1/2 of the outer region density hmax_fwd]
       'hmax_rec' - reconstruction model mesh density [hmax_fwd*2]
       'elec_width' - electrode width [0.1 m]
                    width = 0 requests a PEM, rather than CEM
       'z_contact' - electrode contact impedance [0.01 \Ohm.m]
       'elec_spacing' - distance between electrode centers [5 m]
       'extend_x' - extra mesh in the principle axis of the
                    electrode array, multiple of array width [1]
       'extend_y' - extra mesh in the minor axis of the
                    electrode array, multiple of array width
                    (3D models only) [1]
       'extend_z' - extra depth of model, multiple of array width [1]
       'extend_inner_x'
                  - inner (denser) mesh, multiple of array width [3/5]
       'extend_inner_y'
                  - inner (denser) mesh, multiple of array width [3/5]
                    (3D models only)
       'extend_inner_z'
                  - inner (denser) mesh, multiple of array width [2/5]
       'skip_c2f' - skip building the rec_model to fwd_model mapping [0]
       'threshold' - threshold for electrode placement errors [1e-12]
                    if error exceeds threshold, mash nodes by cubic interp
                    maintaining the side and lower boundaries of the
                    model... the nodes will be mashed until the electrodes
                    conform to the requested electrode positions,
                    correcting for Netgen inaccuracies and lack of
                    vertical profile (Inf = disable node mashing)
       'build_stim' - use stim_pattern_geophys to build a standard geophysics
                      stim/meas sequence and add it to the model, based on the
                      number of electrodes, and assuming a co-linear array;
                      set to 'none' to skip this step
                      [default: 'Wenner']
       'extra_ng_code' - pass extra netgen code, any 'tlo' are subtracted from
                      the inner region, units are scaled, so left to right-most
                      electrodes are -1 to +1
                      [default: {}]

 The linear electrode array runs in the +X direction at Z=0. For
 the 3D model, the Y-axis is perpendicular to the electrode array.

 (C) 2015--2017 A. Boyle
 License: GPL version 2 or version 3</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG eidors progress and status messages</li><li><a href="../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>	EIDORS_OBJ: maintains EIDORS internals</li><li><a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>	SHOW_FEM: show the EIDORS3D finite element model</li><li><a href="../../eidors/meshing/netgen/ng_mk_gen_models.html" class="code" title="function [fmdl,mat_idx] = ng_mk_gen_models(shape_str, elec_pos,  elec_shape, elec_obj, extra_ng_code, mszpoints);">ng_mk_gen_models</a>	NG_MK_GEN_MODELS: create generic models using netgen</li><li><a href="mk_approx_c2f.html" class="code" title="function [mapping, outside] = mk_approx_c2f( f_mdl, c_mdl );">mk_approx_c2f</a>	MK_APPROX_C2F: create a mapping matrix from coarse to fine FEM</li><li><a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="mk_fmdl_from_nodes.html" class="code" title="function mdl= mk_fmdl_from_nodes( vtx, elec_nodes, z_contact, name)">mk_fmdl_from_nodes</a>	MK_FMDL_FROM_NODES: create fmdl from nodes</li><li><a href="mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>	imdl = mk_geophysics_model(str, ne, [option])</li><li><a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>	MK_IMAGE: create eidors image object</li><li><a href="stim_pattern_geophys.html" class="code" title="function [stim,S]= stim_pattern_geophys( n_elec, pat_type,  options )">stim_pattern_geophys</a>	STIM_PATTERN_GEOPHYS: Create Geophysical Stimulation Patterns</li><li><a href="../../eidors/solvers/forward/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>	[srf, idx] = find_boundary(simp);</li><li><a href="../../eidors/solvers/forward/fwd_solve_2p5d_1st_order.html" class="code" title="function data =fwd_solve_2p5d_1st_order(fwd_model, img)">fwd_solve_2p5d_1st_order</a>	FWD_SOLVE_2P5D_1ST_ORDER: data= fwd_solve_2p5d_1st_order( img)</li><li><a href="../../eidors/solvers/forward/fwd_solve_halfspace.html" class="code" title="function data = fwd_solve_halfspace(fwd_model, img)">fwd_solve_halfspace</a>	FWD_SOLVE_HALFSPACE: data = fwd_solve_halfspace(img)</li><li><a href="../../eidors/solvers/forward/jacobian_adjoint_2p5d_1st_order.html" class="code" title="function J= jacobian_adjoint_2p5d_1st_order( fwd_model, img)">jacobian_adjoint_2p5d_1st_order</a>	JACOBIAN_ADJOINT_2P5D: J= jacobian_adjoint_2p5d_1st_order( img )</li><li><a href="../../eidors/solvers/forward/system_mat_2p5d_1st_order.html" class="code" title="function s_mat= system_mat_2p5d_1st_order( fwd_model, img)">system_mat_2p5d_1st_order</a>	SYSTEM_MAT_2P5D_1ST_ORDER: 2.5D system matrix</li><li><a href="../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>	FWD_SOLVE: calculate data from a fwd_model object and an image</li><li><a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>	EIDORS_CACHE Control eidors caching</li><li><a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>	UNIT_TEST_CMP: compare matrices in eidors output</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>	imdl = mk_geophysics_model(str, ne, [option])</li><li><a href="../../eidors/solvers/forward/fwd_solve_2p5d_1st_order.html" class="code" title="function data =fwd_solve_2p5d_1st_order(fwd_model, img)">fwd_solve_2p5d_1st_order</a>	FWD_SOLVE_2P5D_1ST_ORDER: data= fwd_solve_2p5d_1st_order( img)</li><li><a href="../../eidors/solvers/forward/fwd_solve_halfspace.html" class="code" title="function data = fwd_solve_halfspace(fwd_model, img)">fwd_solve_halfspace</a>	FWD_SOLVE_HALFSPACE: data = fwd_solve_halfspace(img)</li><li><a href="../../eidors/solvers/forward/jacobian_adjoint_2p5d_1st_order.html" class="code" title="function J= jacobian_adjoint_2p5d_1st_order( fwd_model, img)">jacobian_adjoint_2p5d_1st_order</a>	JACOBIAN_ADJOINT_2P5D: J= jacobian_adjoint_2p5d_1st_order( img )</li><li><a href="../../eidors/solvers/forward/jacobian_movement_2p5d_1st_order.html" class="code" title="function J = jacobian_movement_2p5d_1st_order( fwd_model, img)">jacobian_movement_2p5d_1st_order</a>	JACOBIAN_MOVEMENT_2P5D: J = jacobian_movement_2p5d_1st_order( img )</li><li><a href="../../eidors/solvers/forward/system_mat_2p5d_1st_order.html" class="code" title="function s_mat= system_mat_2p5d_1st_order( fwd_model, img)">system_mat_2p5d_1st_order</a>	SYSTEM_MAT_2P5D_1ST_ORDER: 2.5D system matrix</li><li><a href="../../eidors/solvers/forward/system_mat_2p5d_fields.html" class="code" title="function FT= system_mat_2p5d_fields( fwd_model )">system_mat_2p5d_fields</a>	SYSTEM_MAT_2P5D_FIELDS: fields (elem to nodes) fraction of system mat</li><li><a href="../../eidors/solvers/forward/update_system_mat_fields.html" class="code" title="function FC1 = update_system_mat_fields( fwd_model0, fwd_model1 )">update_system_mat_fields</a>	UPDATE_SYSTEM_MAT_FIELDS: fields (elem to nodes) fraction of system mat</li><li><a href="../../eidors/solvers/inverse/inv_solve_core.html" class="code" title="function img= inv_solve_core( inv_model, data0, data1);">inv_solve_core</a>	INV_SOLVE_CORE Solver using a generic iterative algorithm</li><li><a href="../../eidors/solvers/inverse/inv_solve_gn.html" class="code" title="function img= inv_solve_gn( inv_model, data1, data2);">inv_solve_gn</a>	function img= inv_solve_gn( inv_model, data1);</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function imdl=mk_model(str,ne,opt,SALT);</a></li><li><a href="#_sub2" class="code">function s = a2s(a)</a></li><li><a href="#_sub3" class="code">function [R,X,var] = rot_line_to_xaxis(xyz)</a></li><li><a href="#_sub4" class="code">function r = range(a)</a></li><li><a href="#_sub5" class="code">function [mdl2,idx2] = copy_mdl2d_from3d(mdl3,idx3,sel);</a></li><li><a href="#_sub6" class="code">function mdl = convert_cem2pem(mdl, xyzc)</a></li><li><a href="#_sub7" class="code">function D2 = pdist(X)</a></li><li><a href="#_sub8" class="code">function [mdl, c] = shift_electrode_positions(mdl, dx)</a></li><li><a href="#_sub9" class="code">function [mdl, c] = correct_electrode_positions(mdl, xyzc)</a></li><li><a href="#_sub10" class="code">function   mdl = mash_nodes(mdl, method, idm, dim, elec_true)</a></li><li><a href="#_sub11" class="code">function err = mdl_elec_err(mdl, xyzc)</a></li><li><a href="#_sub12" class="code">function test_fwd_rec_match(imdl,idx,str)</a></li><li><a href="#_sub13" class="code">function do_unit_test</a></li><li><a href="#_sub14" class="code">function xyz = unit_test_elec_pos(imdl, R, X)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function imdl = mk_geophysics_model(str, ne, opt);</a>
0002 <span class="comment">% imdl = mk_geophysics_model(str, ne, [option])</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% ne  - number of electrodes, 5 metre spacing (+5,+10,...)</span>
0005 <span class="comment">%       and 0.1 metre diameter</span>
0006 <span class="comment">%         OR</span>
0007 <span class="comment">%       a list of electrode locations in the x-dimension or a 2- or</span>
0008 <span class="comment">%       3-dimensional array, one electrode per row, missing columns</span>
0009 <span class="comment">%       will be set to zero</span>
0010 <span class="comment">%       ne = 16</span>
0011 <span class="comment">%       ne = [4 6 10 20] % 1d: (x)</span>
0012 <span class="comment">%       ne = [0 1; 2 1.5; 3 1.2; 7 2.5] % 2d: (x,y)</span>
0013 <span class="comment">%       ne = [0 0.1 1; 2 -0.1 1.5; 3 -0.15 1.2; 7 0 2.5] % 3d: (x,y,z)</span>
0014 <span class="comment">% str - model, x = see hmax_rec</span>
0015 <span class="comment">%       h2x -   2D half-space, linear CEM array (2d fwd)</span>
0016 <span class="comment">%       h2p5x - 2.5D half-space, linear CEM array (2d fwd + Fourier y-dimension)</span>
0017 <span class="comment">%       h3x   - 3D half-space, linear CEM array (3d fwd)</span>
0018 <span class="comment">%       h22x  - 2D half-space, linear CEM array (2d fwd, 2d rec)</span>
0019 <span class="comment">%       h32x  - 2D half-space, linear CEM array (3d fwd, 2d rec)</span>
0020 <span class="comment">%       h33x  - 2D half-space, linear CEM array (3d fwd, 3d rec)</span>
0021 <span class="comment">%       H2x -   2D half-space, linear PEM array (2d fwd)</span>
0022 <span class="comment">%       H2p5x - 2.5D half-space, linear PEM array (2d fwd + Fourier y-dimension)</span>
0023 <span class="comment">%       H3x   - 3D half-space, linear PEM array (3d fwd)</span>
0024 <span class="comment">%       H22x  - 2D half-space, linear PEM array (2d fwd, 2d rec)</span>
0025 <span class="comment">%       H32x  - 2D half-space, linear PEM array (3d fwd, 2d rec)</span>
0026 <span class="comment">%       H33x  - 2D half-space, linear PEM array (3d fwd, 3d rec)</span>
0027 <span class="comment">% opt - override default configuration options (optional cell array)</span>
0028 <span class="comment">%       'hmax_fwd' - fine reconstruction mesh density, given an</span>
0029 <span class="comment">%                    array width xw, and electrode spacing es</span>
0030 <span class="comment">%                    Note that for ne=16, 'A' and 'a' are equivalent.</span>
0031 <span class="comment">%                ['a' : hmax_fwd=xw/1;    ['A' : hmax_fwd=es*16;</span>
0032 <span class="comment">%                 'b' : hmax_fwd=xw/2;     'B' : hmax_fwd=es*8;</span>
0033 <span class="comment">%                 'c' : hmax_fwd=xw/4;     'C' : hmax_fwd=es*4;</span>
0034 <span class="comment">%                 ...                       ...</span>
0035 <span class="comment">%                 'z' : hmax_fwd=xw/2^25]  'Z' : hmax_fwd=es*2^-21]</span>
0036 <span class="comment">%       'hmax_fwd_inner'</span>
0037 <span class="comment">%                  - reconstruction model mesh density for the inner region</span>
0038 <span class="comment">%                    [default: 1/2 of the outer region density hmax_fwd]</span>
0039 <span class="comment">%       'hmax_rec' - reconstruction model mesh density [hmax_fwd*2]</span>
0040 <span class="comment">%       'elec_width' - electrode width [0.1 m]</span>
0041 <span class="comment">%                    width = 0 requests a PEM, rather than CEM</span>
0042 <span class="comment">%       'z_contact' - electrode contact impedance [0.01 \Ohm.m]</span>
0043 <span class="comment">%       'elec_spacing' - distance between electrode centers [5 m]</span>
0044 <span class="comment">%       'extend_x' - extra mesh in the principle axis of the</span>
0045 <span class="comment">%                    electrode array, multiple of array width [1]</span>
0046 <span class="comment">%       'extend_y' - extra mesh in the minor axis of the</span>
0047 <span class="comment">%                    electrode array, multiple of array width</span>
0048 <span class="comment">%                    (3D models only) [1]</span>
0049 <span class="comment">%       'extend_z' - extra depth of model, multiple of array width [1]</span>
0050 <span class="comment">%       'extend_inner_x'</span>
0051 <span class="comment">%                  - inner (denser) mesh, multiple of array width [3/5]</span>
0052 <span class="comment">%       'extend_inner_y'</span>
0053 <span class="comment">%                  - inner (denser) mesh, multiple of array width [3/5]</span>
0054 <span class="comment">%                    (3D models only)</span>
0055 <span class="comment">%       'extend_inner_z'</span>
0056 <span class="comment">%                  - inner (denser) mesh, multiple of array width [2/5]</span>
0057 <span class="comment">%       'skip_c2f' - skip building the rec_model to fwd_model mapping [0]</span>
0058 <span class="comment">%       'threshold' - threshold for electrode placement errors [1e-12]</span>
0059 <span class="comment">%                    if error exceeds threshold, mash nodes by cubic interp</span>
0060 <span class="comment">%                    maintaining the side and lower boundaries of the</span>
0061 <span class="comment">%                    model... the nodes will be mashed until the electrodes</span>
0062 <span class="comment">%                    conform to the requested electrode positions,</span>
0063 <span class="comment">%                    correcting for Netgen inaccuracies and lack of</span>
0064 <span class="comment">%                    vertical profile (Inf = disable node mashing)</span>
0065 <span class="comment">%       'build_stim' - use stim_pattern_geophys to build a standard geophysics</span>
0066 <span class="comment">%                      stim/meas sequence and add it to the model, based on the</span>
0067 <span class="comment">%                      number of electrodes, and assuming a co-linear array;</span>
0068 <span class="comment">%                      set to 'none' to skip this step</span>
0069 <span class="comment">%                      [default: 'Wenner']</span>
0070 <span class="comment">%       'extra_ng_code' - pass extra netgen code, any 'tlo' are subtracted from</span>
0071 <span class="comment">%                      the inner region, units are scaled, so left to right-most</span>
0072 <span class="comment">%                      electrodes are -1 to +1</span>
0073 <span class="comment">%                      [default: {}]</span>
0074 <span class="comment">%</span>
0075 <span class="comment">% The linear electrode array runs in the +X direction at Z=0. For</span>
0076 <span class="comment">% the 3D model, the Y-axis is perpendicular to the electrode array.</span>
0077 <span class="comment">%</span>
0078 <span class="comment">% (C) 2015--2017 A. Boyle</span>
0079 <span class="comment">% License: GPL version 2 or version 3</span>
0080 
0081 <span class="comment">% model: 64 electrode, 2d half-space</span>
0082 <span class="comment">% Once upon a time, this code started out from the following tutorial.</span>
0083 <span class="comment">% model from http://eidors3d.sourceforge.net/tutorial/other_models/square_mesh.shtml</span>
0084 
0085 <span class="keyword">if</span> ischar(str) &amp;&amp; strcmp(str,<span class="string">'UNIT_TEST'</span>); <a href="#_sub13" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0086 copt.fstr = <span class="string">'mk_geophysics_model'</span>;
0087 <span class="keyword">if</span> nargin &lt; 3
0088    opt = {};
0089 <span class="keyword">end</span>
0090 SALT=<span class="string">'z$Id: mk_geophysics_model.m 6521 2022-12-30 21:33:17Z bgrychtol $'</span>; <span class="comment">% stick a key in the model 'save' file, so we can expire them when the model definitions age</span>
0091 imdl = <a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub1" class="code" title="subfunction imdl=mk_model(str,ne,opt,SALT);">mk_model</a>,{str, ne, opt, SALT}, copt);
0092 
0093 <a name="_sub1" href="#_subfunctions" class="code">function imdl=mk_model(str,ne,opt,SALT);</a>
0094 <span class="keyword">if</span> str(1) ~= <span class="string">'h'</span> &amp;&amp; str(1) ~= <span class="string">'H'</span>
0095    error([str <span class="string">': I only know how to build linear half-space models: h***'</span>]);
0096 <span class="keyword">end</span>
0097 
0098 MDL_2p5D_CONFIG = 0;
0099 <span class="keyword">switch</span> str(2:end-1)
0100    <span class="keyword">case</span> {<span class="string">'2'</span>, <span class="string">'3'</span>} <span class="comment">% simple meshes</span>
0101       FMDL_DIM = str(2) - <span class="string">'0'</span>;
0102       CMDL_DIM = 0; <span class="comment">% no cmdl</span>
0103    <span class="keyword">case</span> <span class="string">'2p5'</span> <span class="comment">% 2.5D Fourier transformed</span>
0104       FMDL_DIM = 2;
0105       CMDL_DIM = 0; <span class="comment">% no cmdl</span>
0106       MDL_2p5D_CONFIG = 1;
0107    <span class="keyword">case</span> {<span class="string">'22'</span>, <span class="string">'33'</span>, <span class="string">'32'</span>} <span class="comment">% dual meshes</span>
0108       FMDL_DIM = str(2) - <span class="string">'0'</span>;
0109       CMDL_DIM = str(3) - <span class="string">'0'</span>;
0110    <span class="keyword">otherwise</span>
0111       error([str <span class="string">': unrecognized model type'</span>]);
0112 <span class="keyword">end</span>
0113 assert(CMDL_DIM ~= 3, <span class="string">'3d rec_model not yet tested'</span>);
0114 
0115 skip_c2f = 0;
0116 <span class="keyword">if</span> str(1) == <span class="string">'h'</span>
0117    elec_width = 0.1;
0118 <span class="keyword">else</span> <span class="comment">% str(1) == 'H'</span>
0119    elec_width = 0;
0120 <span class="keyword">end</span>
0121 z_contact= 0.01;
0122 nodes_per_elec= 3; <span class="comment">%floor(elec_width/hmax_rec*10);</span>
0123 elec_spacing= 5.0;
0124 threshold = 1e-12;
0125 save_model_to_disk = (length(ne) == 1) &amp;&amp; (length(opt) == 0);
0126 
0127 extend_x = 1;
0128 extend_y = 1;
0129 extend_z = 1;
0130 extend_inner_x = 3/5;
0131 extend_inner_y = 3/5;
0132 extend_inner_z = 2/5;
0133 build_stim = <span class="string">'Wenner'</span>;
0134 extra_ng_code = <span class="string">''</span>;
0135 <span class="keyword">if</span> length(opt) &gt; 0 <span class="comment">% allow overriding the default values</span>
0136    assert(round(length(opt)/2)*2 == length(opt),<span class="string">'option missing value?'</span>);
0137    expect = {<span class="string">'hmax_rec'</span>,<span class="string">'hmax_fwd'</span>, <span class="string">'hmax_fwd_inner'</span>, <span class="keyword">...</span>
0138              <span class="string">'elec_width'</span>,<span class="string">'z_contact'</span>,<span class="string">'elec_spacing'</span>,<span class="keyword">...</span>
0139              <span class="string">'extend_x'</span>, <span class="string">'extend_y'</span>, <span class="string">'extend_z'</span>, <span class="keyword">...</span>
0140              <span class="string">'extend_inner_x'</span>, <span class="string">'extend_inner_y'</span>, <span class="string">'extend_inner_z'</span>, <span class="keyword">...</span>
0141              <span class="string">'skip_c2f'</span>, <span class="string">'threshold'</span>, <span class="string">'build_stim'</span>, <span class="string">'extra_ng_code'</span>};
0142    opts = struct(opt{:})
0143    <span class="keyword">for</span> i = fieldnames(opts)'
0144       assert(any(strcmp(i,expect)), [<span class="string">'unexpected option: '</span>,i{:}]);
0145       eval([i{:} <span class="string">' = opts.(i{:});'</span>]);
0146    <span class="keyword">end</span>
0147    <span class="keyword">if</span> (str(1) == <span class="string">'H'</span>) &amp;&amp; isfield(opts, <span class="string">'elec_width'</span>)
0148       error(<span class="string">'requested &quot;H&quot; PEM model but configured &quot;elec_width&quot; option'</span>);
0149    <span class="keyword">end</span>
0150 <span class="keyword">end</span>
0151 <span class="keyword">if</span> length(ne) == 1 <span class="comment">% ne: number of electrodes</span>
0152    xw=(ne-1)*elec_spacing; <span class="comment">% array width</span>
0153    <span class="comment">%xs=-(ne-1)*elec_spacing/2; % array centered</span>
0154    xs=+5; <span class="comment">% array at left-most at +5</span>
0155    xyz = xs+([1:ne]'-1)*elec_spacing;
0156 <span class="keyword">else</span>
0157    xyz = ne; <span class="comment">% must be a set of coordinates for the electrodes...</span>
0158 <span class="keyword">end</span>
0159 <span class="keyword">if</span> size(xyz,1) == 1
0160    xyz = xyz'; <span class="comment">% flip to column</span>
0161 <span class="keyword">end</span>
0162 xyz = [xyz zeros(size(xyz,1),3-size(xyz,2))]; <span class="comment">% [x 0 0] or [ x y 0 ] or [ x y z ]</span>
0163 ne=size(xyz,1);
0164 [R, X] = <a href="#_sub3" class="code" title="subfunction [R,X,var] = rot_line_to_xaxis(xyz)">rot_line_to_xaxis</a>(xyz);
0165 <span class="comment">% % rescale, centre electrodes so NetGen can be happy</span>
0166 xyzc = (xyz - X)*R; <span class="comment">% centre and scale electrodes: -1 to +1 y-axis</span>
0167 <span class="comment">% xyzc = xyz; % centre and scale electrodes: -1 to +1 y-axis</span>
0168 xw=max(xyzc(:,1))-min(xyzc(:,1));
0169 xs=min(xyzc(:,1));
0170 elec_spacing = min(min(<a href="#_sub7" class="code" title="subfunction D2 = pdist(X) ">pdist</a>(xyzc) + diag(inf*(1:size(xyzc,1))))); <span class="comment">% min spacing btw elec</span>
0171 
0172 <span class="keyword">if</span> ~exist(<span class="string">'hmax_fwd'</span>,<span class="string">'var'</span>)
0173    <span class="keyword">if</span> str(end)-<span class="string">'a'</span> &gt;= 0
0174       hmax_fwd = xw*2^-(str(end)-<span class="string">'a'</span>);
0175    <span class="keyword">else</span>
0176       hmax_fwd = elec_spacing*2^-(str(end)-<span class="string">'A'</span>-4);
0177    <span class="keyword">end</span>
0178 <span class="keyword">end</span>
0179 <span class="keyword">if</span> ~exist(<span class="string">'hmax_rec'</span>,<span class="string">'var'</span>) <span class="comment">% allow hmax_rec to depend on configured hmax_fwd</span>
0180    hmax_rec=hmax_fwd*2.01; <span class="comment">% avoid parametrization aliasing</span>
0181 <span class="keyword">end</span>
0182 <span class="keyword">if</span> ~exist(<span class="string">'hmax_fwd_inner'</span>,<span class="string">'var'</span>) <span class="comment">% allow hmax_rec to depend on configured hmax_fwd</span>
0183    hmax_fwd_inner=hmax_fwd/2.0;
0184 <span class="keyword">end</span>
0185 
0186 <span class="keyword">if</span> save_model_to_disk
0187    isOctave = exist(<span class="string">'OCTAVE_VERSION'</span>);
0188    <span class="keyword">if</span> isOctave
0189       octavestr=<span class="string">'-octave-'</span>;
0190    <span class="keyword">else</span>
0191       octavestr=<span class="string">'-'</span>;
0192    <span class="keyword">end</span>
0193    <span class="comment">% NOTE models are stored in the directory specified by eidors_cache('cache_path')</span>
0194    filename=fullfile(<a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(<span class="string">'cache_path'</span>),sprintf(<span class="string">'mk_geophysics_model%simdl-%s-%03del.mat'</span>,octavestr,str,ne));
0195    <span class="keyword">if</span> exist(filename, <span class="string">'file'</span>) == 2
0196       tmp = whos(<span class="string">'-file'</span>,filename,<span class="string">'SALT'</span>);
0197       <span class="keyword">if</span> length(tmp) &gt; 0
0198          tmp = load(filename,<span class="string">'SALT'</span>);
0199          fSALT = tmp.SALT;
0200       <span class="keyword">else</span>
0201          fSALT = <span class="string">'deadbeef'</span>;
0202       <span class="keyword">end</span>
0203       <span class="keyword">if</span> strcmp(fSALT, SALT)
0204          tmp=load(filename,<span class="string">'imdl'</span>);
0205          imdl = tmp.imdl;
0206          <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(sprintf(<span class="string">'%s: %s, %d electrode model loaded from file'</span>,filename,str,ne));
0207          <span class="keyword">return</span>
0208       <span class="keyword">end</span> <span class="comment">% hmm, the SALT doesn't match so we go back to generating a new model from scratch</span>
0209    <span class="keyword">end</span>
0210 <span class="keyword">end</span>
0211 
0212 assert(extend_x&gt;0,<span class="string">'extend_x must be &gt; 0'</span>);
0213 assert(extend_y&gt;0,<span class="string">'extend_y must be &gt; 0'</span>);
0214 assert(extend_z&gt;-1,<span class="string">'extend_z must be &gt; -1'</span>);
0215 
0216 <span class="comment">% Calculate cmdl, fmdl and inner fmdl (fmdlin) min/max coordinates.</span>
0217 <span class="comment">% After rescaling (normalizing), electrode major axis is along the x-axis, and</span>
0218 <span class="comment">% the electrode array will be 2 units long (-1,+1).</span>
0219 fmdlbox =   [-(1+2*extend_x)        +(1+2*extend_x);
0220              -(1+2*extend_y)        +(1+2*extend_y);
0221              -(2+2*extend_z)        +3];
0222 fmdlinbox = [-(1+2*extend_inner_x)  +(1+2*extend_inner_x);
0223              -(1+2*extend_inner_y)  +(1+2*extend_inner_y);
0224              -(2+2*extend_inner_z)  +2];
0225 cmdlbox = fmdlbox;
0226 
0227 assert(all(fmdlbox(:,1) &lt;= fmdlinbox(:,1)), <span class="string">'oops, inner mesh must be smaller than outer mesh'</span>);
0228 assert(all(fmdlbox(:,2) &gt;= fmdlinbox(:,2)), <span class="string">'oops, inner mesh must be smaller than outer mesh'</span>);
0229 assert(all(fmdlbox(:,1) &lt;= cmdlbox(:,1)), <span class="string">'oops, reconstruction mesh must be smaller than forward mesh'</span>);
0230 assert(all(fmdlbox(:,2) &gt;= cmdlbox(:,2)), <span class="string">'oops, reconstruction mesh must be smaller than forward mesh'</span>);
0231 
0232 <span class="comment">% build shape string for NetGen</span>
0233 <span class="keyword">if</span> elec_width ~= 0
0234    elec_shape = [elec_width*norm(R)/2, 0, elec_width*norm(R)/2/(nodes_per_elec-1)]; <span class="comment">% CEM, circular, maxh</span>
0235    elec_pos   = [ xyzc(:,1:FMDL_DIM), repmat([zeros(1,3-FMDL_DIM+2) 1],ne,1) ]; <span class="comment">% p(x,y,z=0), n(0,0,1)</span>
0236    cem2pem = 0;
0237 <span class="keyword">else</span>
0238    <span class="keyword">if</span> FMDL_DIM == 3
0239       elec_width = elec_spacing/2;
0240       elec_shape = [elec_width, elec_width, hmax_fwd_inner]; <span class="comment">% PEM, sz, maxh</span>
0241       elec_pos   = [ xyzc, repmat([0 0 1],ne,1) ]; <span class="comment">% p(x,y,z=0), n(0,0,1)</span>
0242       elec_pos(:,1) = elec_pos(:,1) + elec_width/2;
0243       elec_pos(:,2) = elec_pos(:,2) + elec_width/2;
0244       cem2pem = 1;
0245    <span class="keyword">else</span> <span class="comment">% FMDL_DIM == 2</span>
0246       elec_width = elec_spacing/2;
0247       elec_shape = [elec_width, elec_width, hmax_fwd_inner]; <span class="comment">% rectangular CEM-&gt;PEM, maxh</span>
0248       elec_pos   = [ xyzc(:,1:2), repmat([0 0 0 1],ne,1) ]; <span class="comment">% p(x,y,z=0), n(0,0,1)</span>
0249       elec_pos(:,1) = elec_pos(:,1) + elec_width/2;
0250       cem2pem = 1;
0251    <span class="keyword">end</span>
0252 <span class="keyword">end</span>
0253 skip_tlo = <span class="string">''</span>;
0254 <span class="keyword">for</span> idx = strfind(extra_ng_code, <span class="string">'tlo '</span>)
0255    sc = strfind(extra_ng_code, <span class="string">';'</span>); <span class="comment">% semicolons</span>
0256    sc = min(sc + (sc&lt;idx)*1e10);
0257    tlo = extra_ng_code(idx+4:sc-1);
0258    skip_tlo = [skip_tlo <span class="string">' and (not '</span> tlo <span class="string">')'</span>];
0259 <span class="keyword">end</span>
0260 elec_pos(:,FMDL_DIM) = 0; <span class="comment">% flatten electrode positions onto the &quot;ps&quot; plane</span>
0261 <span class="keyword">if</span> FMDL_DIM == 3
0262    shape_str = [<span class="keyword">...</span>
0263                 sprintf(<span class="string">'solid ps = plane(%s);\n'</span>, <a href="#_sub2" class="code" title="subfunction s = a2s(a)">a2s</a>([0 0 0; 0 0 1])), <span class="keyword">...</span>
0264                 sprintf(<span class="string">'solid bi = orthobrick(%s);\n'</span>, <a href="#_sub2" class="code" title="subfunction s = a2s(a)">a2s</a>(fmdlinbox')), <span class="keyword">...</span>
0265                 sprintf(<span class="string">'solid bo = orthobrick(%s);\n'</span>, <a href="#_sub2" class="code" title="subfunction s = a2s(a)">a2s</a>(fmdlbox')), <span class="keyword">...</span>
0266                 extra_ng_code, <span class="keyword">...</span>
0267                 sprintf(<span class="string">'solid ri = bi and ps%s -maxh=%f;\n'</span>, skip_tlo, hmax_fwd_inner), <span class="keyword">...</span>
0268                 sprintf(<span class="string">'solid ro = bo and ps and (not bi) -maxh=%f;\n'</span>, hmax_fwd), <span class="keyword">...</span>
0269                 sprintf(<span class="string">'solid mainobj = ri;\n'</span>)];
0270    <span class="comment">% Note that ri must be the 'mainobj' so that it can intersect with the electrodes</span>
0271    <span class="comment">% additional top level objects for netgen</span>
0272 <span class="keyword">else</span> <span class="comment">% netgen 2d model</span>
0273    <span class="comment">% to create the 2D slice we need to give NetGen something to work with</span>
0274    <span class="comment">%Need some width to let netgen work, but not too much so</span>
0275    <span class="comment">% that it meshes the entire region</span>
0276    sw = <a href="#_sub4" class="code" title="subfunction r = range(a)">range</a>(fmdlinbox(1,:)) / 5; <span class="comment">% initial estimate</span>
0277    sw = min(sw,2*hmax_fwd); <span class="comment">% coarse model slice width</span>
0278    ri2d = fmdlinbox'; ri2d(:,2) = [-sw 0 ];
0279    ro2d = fmdlbox'; ro2d(:,2) = [-sw 0 ];
0280    shape_str = [<span class="keyword">...</span>
0281                 sprintf(<span class="string">'solid ps = plane(%s);\n'</span>, <a href="#_sub2" class="code" title="subfunction s = a2s(a)">a2s</a>([0 0 0; 0 0 1])), <span class="keyword">...</span>
0282                 sprintf(<span class="string">'solid bi = orthobrick(%s);\n'</span>, <a href="#_sub2" class="code" title="subfunction s = a2s(a)">a2s</a>(ri2d)), <span class="keyword">...</span>
0283                 sprintf(<span class="string">'solid bo = orthobrick(%s);\n'</span>, <a href="#_sub2" class="code" title="subfunction s = a2s(a)">a2s</a>(ro2d)), <span class="keyword">...</span>
0284                 extra_ng_code, <span class="keyword">...</span>
0285                 sprintf(<span class="string">'solid ri = bi and ps%s -maxh=%f;\n'</span>, skip_tlo, hmax_fwd_inner), <span class="keyword">...</span>
0286                 sprintf(<span class="string">'solid ro = bo and ps and (not bi) -maxh=%f;\n'</span>, hmax_fwd), <span class="keyword">...</span>
0287                 sprintf(<span class="string">'solid mainobj = ri;\n'</span>)];
0288 <span class="keyword">end</span>
0289 <span class="comment">% fprintf('SHAPE_STR: %s', shape_str); elec_pos</span>
0290 elec_obj = <span class="string">'ps'</span>;
0291 [fmdl, mat_idx] = <a href="../../eidors/meshing/netgen/ng_mk_gen_models.html" class="code" title="function [fmdl,mat_idx] = ng_mk_gen_models(shape_str, elec_pos,  elec_shape, elec_obj, extra_ng_code, mszpoints);">ng_mk_gen_models</a>(shape_str, elec_pos, elec_shape, elec_obj, <span class="string">'tlo ro'</span>);
0292 <span class="keyword">if</span> FMDL_DIM == 2 <span class="comment">% 2D</span>
0293    <span class="comment">% now convert the roughly 2D slice into a true 2D plane</span>
0294    [fmdl, mat_idx] = <a href="#_sub5" class="code" title="subfunction [mdl2,idx2] = copy_mdl2d_from3d(mdl3,idx3,sel);">copy_mdl2d_from3d</a>(fmdl, mat_idx, <span class="string">'y'</span>);
0295 <span class="keyword">else</span> <span class="comment">% 3D</span>
0296    <span class="keyword">if</span> CMDL_DIM ~= 0
0297       <span class="comment">% c2f</span>
0298       cmdl.mk_coarse_fine_mapping.f2c_offset  = [0 0 0];
0299       cmdl.mk_coarse_fine_mapping.f2c_project = [1 0 0; 0 0 1; 0 1 0];
0300    <span class="keyword">end</span>
0301 <span class="keyword">end</span>
0302 
0303 <span class="keyword">if</span> cem2pem
0304    fmdl = <a href="#_sub6" class="code" title="subfunction mdl = convert_cem2pem(mdl, xyzc)">convert_cem2pem</a>(fmdl, xyzc);
0305 <span class="keyword">end</span>
0306 
0307 <span class="comment">% 2d cmdl</span>
0308 xllim = fmdlbox(1,1);
0309 xrlim = fmdlbox(1,2);
0310 zdepth = fmdlbox(3,1);
0311 <span class="comment">% AA - 2022-05 Updated from hmax_rec/2</span>
0312 xr=max(floor((xrlim-xllim)/hmax_rec),1)*2+1; <span class="comment">% odd number</span>
0313 yr=max(floor(-zdepth/hmax_rec),1)*2+1; <span class="comment">% odd number</span>
0314 [x,y] = meshgrid( linspace(xllim,xrlim,xr), linspace(zdepth,0,yr));
0315 vtx= [x(:),y(:)];
0316 <span class="keyword">if</span> CMDL_DIM ~= 0
0317    cmdl= <a href="mk_fmdl_from_nodes.html" class="code" title="function mdl= mk_fmdl_from_nodes( vtx, elec_nodes, z_contact, name)">mk_fmdl_from_nodes</a>( vtx,{vtx(1,:)}, z_contact, <span class="string">'sq_m2'</span>);
0318 <span class="keyword">end</span>
0319 
0320 <span class="comment">% stick electrode nodes into cmdl so that show_fem will plot them</span>
0321 <span class="keyword">for</span> i=1:ne
0322    n=fmdl.electrode(i).nodes;
0323    nn=length(n);
0324    nx=fmdl.nodes(n,:);
0325 
0326    fmdl.electrode(i).z_contact = z_contact;
0327    <span class="keyword">if</span> CMDL_DIM ~= 0
0328       nnc = length(cmdl.nodes);
0329       cmdl.nodes = [cmdl.nodes; nx(:,[1 FMDL_DIM])];
0330       cmdl.electrode(i).nodes = (nnc+1):(nnc+nn);
0331       cmdl.electrode(i).z_contact = z_contact;
0332    <span class="keyword">end</span>
0333 <span class="keyword">end</span>
0334 
0335 <span class="comment">% fix electrode locations if necessary</span>
0336 elec_err = sqrt(sum(<a href="#_sub11" class="code" title="subfunction err = mdl_elec_err(mdl, xyzc)">mdl_elec_err</a>(fmdl, xyzc).^2,2));
0337 <span class="keyword">if</span> max(elec_err) &gt; threshold <span class="comment">% put electrodes in the right place</span>
0338    [fmdl, cf] = <a href="#_sub9" class="code" title="subfunction [mdl, c] = correct_electrode_positions(mdl, xyzc)">correct_electrode_positions</a>(fmdl, xyzc);
0339 
0340    <span class="keyword">if</span> CMDL_DIM ~= 0
0341       [cmdl, cc] = <a href="#_sub9" class="code" title="subfunction [mdl, c] = correct_electrode_positions(mdl, xyzc)">correct_electrode_positions</a>(cmdl, xyzc);
0342    <span class="keyword">end</span>
0343 <span class="keyword">end</span>
0344 <span class="comment">% save functions for later use</span>
0345 fmdl.mv_elec = @<a href="#_sub8" class="code" title="subfunction [mdl, c] = shift_electrode_positions(mdl, dx)">shift_electrode_positions</a>;
0346 
0347 <span class="comment">% reverse the centre and scaling</span>
0348 nn = size(fmdl.nodes,1);
0349 Xn = repmat(X(1,:), nn, 1);
0350 fmdl.nodes = ([fmdl.nodes zeros(nn,3-FMDL_DIM)]/ R) + Xn;
0351 fmdl.nodes = fmdl.nodes(:,1:FMDL_DIM);
0352 
0353 <span class="keyword">if</span> CMDL_DIM ~= 0
0354    nn = size(cmdl.nodes,1);
0355    Xn = repmat(X(1,:), nn, 1);
0356    <span class="keyword">if</span> CMDL_DIM ~= FMDL_DIM <span class="comment">% 2D</span>
0357       cmdl.nodes = ([cmdl.nodes(:,1) zeros(nn,1) cmdl.nodes(:,2:end)]/ R) + Xn;
0358       cmdl.nodes = cmdl.nodes(:,[1 3]);
0359 <span class="comment">%     cmdl.nodes = cmdl.nodes(:,[1 3])/R([1 3],[1 3]); % ONLY DIVIDE ONCE</span>
0360    <span class="keyword">else</span> <span class="comment">% CMDL_DIM == FMDL_DIM</span>
0361       cmdl.nodes = ([cmdl.nodes zeros(nn,3-CMDL_DIM)]/ R) + Xn;
0362       cmdl.nodes = cmdl.nodes(:,1:CMDL_DIM);
0363    <span class="keyword">end</span>
0364 <span class="keyword">end</span>
0365 
0366 <span class="comment">% check that all electrodes were found</span>
0367 <span class="keyword">for</span> i = 1:length(fmdl.electrode)
0368    nn = fmdl.electrode(i).nodes;
0369    assert(length(nn(:)) &gt; 0, sprintf(<span class="string">'electrode#%d: failed to find nodes'</span>,i));
0370 <span class="keyword">end</span>
0371 
0372 <span class="comment">% show_fem(fmdl); xlabel('x'); ylabel('y'); zlabel('z');</span>
0373 
0374 <span class="comment">% TODO ... Actually we want a node in the middle: the boundary is bad too...</span>
0375 [~, gn] = min(fmdl.nodes(:,end));
0376 fmdl.gnd_node = gn; <span class="comment">% make sure the ground node is away from surface electrodes</span>
0377 <span class="keyword">if</span> CMDL_DIM ~= 0
0378    [~, gn] = min(cmdl.nodes(:,end));
0379    cmdl.gnd_node = gn; <span class="comment">% make sure the ground node is away from surface electrodes</span>
0380 <span class="keyword">end</span>
0381 
0382 
0383 imdl= <a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'a2d0c'</span>,4); <span class="comment">% 2d model</span>
0384 imdl.fwd_model = fmdl;
0385 imdl.name = [<span class="string">'EIDORS mk_geophysics_model '</span> str];
0386 imdl.fwd_model.name = [<span class="string">'EIDORS mk_geophysics_model fwd model '</span> str];
0387 <span class="keyword">if</span> CMDL_DIM ~= 0
0388    imdl.rec_model.name = [<span class="string">'EIDORS mk_geophysics_model rec model '</span> str];
0389    imdl.rec_model = cmdl;
0390    <span class="comment">% EIDORS &quot;analytic_c2f&quot; gets stuck, do an approximate one</span>
0391    <span class="comment">%eidors_default('set','mk_coarse_fine_mapping','mk_analytic_c2f');</span>
0392    <span class="comment">%eidors_default('set','mk_coarse_fine_mapping','mk_approx_c2f');</span>
0393    <span class="comment">%[c2f,out] = mk_coarse_fine_mapping(fmdl,cmdl);</span>
0394    <span class="keyword">if</span> ~skip_c2f
0395       [c2f,out] = <a href="mk_approx_c2f.html" class="code" title="function [mapping, outside] = mk_approx_c2f( f_mdl, c_mdl );">mk_approx_c2f</a>(fmdl,cmdl);
0396       imdl.fwd_model.coarse2fine = c2f;
0397       imdl.fwd_model.background = out;
0398    <span class="keyword">end</span>
0399 <span class="keyword">end</span>
0400 
0401 <span class="keyword">if</span> MDL_2p5D_CONFIG
0402    imdl.fwd_model.jacobian   = @<a href="../../eidors/solvers/forward/jacobian_adjoint_2p5d_1st_order.html" class="code" title="function J= jacobian_adjoint_2p5d_1st_order( fwd_model, img)">jacobian_adjoint_2p5d_1st_order</a>;
0403    imdl.fwd_model.solve      = @<a href="../../eidors/solvers/forward/fwd_solve_2p5d_1st_order.html" class="code" title="function data =fwd_solve_2p5d_1st_order(fwd_model, img)">fwd_solve_2p5d_1st_order</a>;
0404    imdl.fwd_model.system_mat = @<a href="../../eidors/solvers/forward/system_mat_2p5d_1st_order.html" class="code" title="function s_mat= system_mat_2p5d_1st_order( fwd_model, img)">system_mat_2p5d_1st_order</a>;
0405    imdl.fwd_model.jacobian_adjoint_2p5d_1st_order.k = [0 3];
0406    imdl.fwd_model.fwd_solve_2p5d_1st_order.k = [0 3];
0407 <span class="keyword">end</span>
0408 
0409 <span class="keyword">if</span> ~strcmp(build_stim,<span class="string">'none'</span>)
0410    imdl.fwd_model.stimulation = <a href="stim_pattern_geophys.html" class="code" title="function [stim,S]= stim_pattern_geophys( n_elec, pat_type,  options )">stim_pattern_geophys</a>(length(imdl.fwd_model.electrode), build_stim);
0411 <span class="keyword">end</span>
0412 
0413 <span class="keyword">if</span> save_model_to_disk
0414    save(filename,<span class="string">'imdl'</span>,<span class="string">'SALT'</span>);
0415 <span class="keyword">end</span>
0416 
0417 <span class="comment">% convert 2x3 array to &quot;x1,y1,z1;x2,y2,z2&quot; string</span>
0418 <span class="comment">% convert 1x3 array to &quot;x1,y1,z1&quot; string</span>
0419 <span class="comment">% if 1x1 array, then use xy_ctr=x1,y1 and [0 0 1]=x2,y2,z2 (z+)</span>
0420 <a name="_sub2" href="#_subfunctions" class="code">function s = a2s(a)</a>
0421 <span class="keyword">if</span> length(a(:)) == 3
0422    s = sprintf(<span class="string">'%f,%f,%f'</span>, <span class="keyword">...</span>
0423                a(1), a(2), a(3));
0424 <span class="keyword">else</span>
0425    s = sprintf(<span class="string">'%f,%f,%f;%f,%f,%f'</span>, <span class="keyword">...</span>
0426                 a(1,1), a(1,2), a(1,3), <span class="keyword">...</span>
0427                a(2,1), a(2,2), a(2,3));
0428 <span class="keyword">end</span>
0429 
0430 <span class="comment">% returns R rotation/scaling and X0 offset</span>
0431 <span class="comment">% xyz1 = R * xyz + X; % rotate and scale to +/- 1</span>
0432 <a name="_sub3" href="#_subfunctions" class="code">function [R,X,var] = rot_line_to_xaxis(xyz)</a>
0433 x = xyz(:,1); y=xyz(:,2); z=xyz(:,3);
0434 
0435 <span class="comment">% fit line to points</span>
0436 <span class="comment">% http://www.mathworks.com/matlabcentral/newsreader/view_thread/32502</span>
0437 p = mean(xyz);
0438 [U,S,V] = svd([x-p(1), y-p(2), z-p(3)]);
0439 <span class="keyword">if</span> V(<span class="keyword">end</span>,1) ~= 0
0440    N=1/V(<span class="keyword">end</span>,1)*V(:,1);
0441 <span class="keyword">else</span>
0442    N=V(:,1);
0443 <span class="keyword">end</span>
0444 A=p' + dot( xyz(1,  :) - p, N ) * N/norm(N)^2;
0445 B=p' + dot( xyz(<span class="keyword">end</span>,:) - p, N ) * N/norm(N)^2;
0446 
0447 <span class="comment">% rotate line to +y-axis</span>
0448 a = N/norm(N);
0449 b = [ 1 0 0 ]'; <span class="comment">% +x</span>
0450 <span class="comment">% http://math.stackexchange.com/questions/180418/calculate-rotation-matrix-to-align-vector-a-to-vector-b-in-3d</span>
0451 v = cross(a, b);
0452 s = norm(v); c = dot(a, b); <span class="comment">% sin, cos</span>
0453 xt = @(v) [   0  -v(3)  v(2); <span class="keyword">...</span><span class="comment"> % skew symmetric cross-product of v</span>
0454             v(3)    0  -v(1); <span class="keyword">...</span><span class="comment"> % diagnoal is the scaling identity matrix</span>
0455            -v(2)  v(1)    0];
0456 <span class="keyword">if</span> abs(s) &lt; eps*1e3
0457    R = eye(3);
0458 <span class="keyword">else</span>
0459    R = (eye(3) + xt(v) + xt(v)^2 * (1-c)/s^2);
0460    R=R'; <span class="comment">% for right multiply: xyz*R</span>
0461 <span class="keyword">end</span>
0462 
0463 X = repmat(p, size(xyz,1), 1);
0464 R = R / max(<a href="#_sub4" class="code" title="subfunction r = range(a)">range</a>((xyz-X)*R)) * 2;
0465 
0466 DEBUG=0;
0467 <span class="keyword">if</span> DEBUG
0468    clf;
0469    subplot(211);
0470    plot3(x,y,z,<span class="string">'bo'</span>);
0471    hold on;
0472    plot3(x(1),y(1),z(1),<span class="string">'go'</span>);
0473    plot3(p(1),p(2),p(3),<span class="string">'ro'</span>);
0474    plot3([A(1),B(1)],[A(2),B(2)],[A(3),B(3)]);
0475    grid; axis equal; hold off;
0476    xlabel(<span class="string">'x'</span>); ylabel(<span class="string">'y'</span>); zlabel(<span class="string">'z'</span>);
0477    title(<span class="string">'pre-rotation'</span>);
0478    subplot(212);
0479    xx = (xyz-X)*R;
0480    plot3(xx(:,1), xx(:,2), xx(:,3),<span class="string">'bo'</span>);
0481    hold on;
0482    plot3(xx(1,1), xx(1,2), xx(1,3),<span class="string">'go'</span>);
0483    plot3(0,0,0,<span class="string">'ro'</span>);
0484    grid; axis equal; hold off;
0485    xlabel(<span class="string">'x'</span>); ylabel(<span class="string">'y'</span>); zlabel(<span class="string">'z'</span>);
0486    title(<span class="string">'post-rotation'</span>);
0487 <span class="keyword">end</span>
0488 
0489 <span class="comment">% the (max-min) range of a variable's values</span>
0490 <a name="_sub4" href="#_subfunctions" class="code">function r = range(a)</a>
0491 r = max(a(:))-min(a(:));
0492 
0493 <a name="_sub5" href="#_subfunctions" class="code">function [mdl2,idx2] = copy_mdl2d_from3d(mdl3,idx3,sel);</a>
0494 <span class="comment">% AB: taken from EIDORS function ng_mk_gen_models() subfunction of the same name</span>
0495 <span class="comment">% AB: NEW: sel = 'x', 'y' or 'z' -- default was Z, we want X</span>
0496    <span class="keyword">if</span> sel == <span class="string">'x'</span>
0497       <span class="comment">% swap Z and X</span>
0498       T = [ 0 0 1; 0 1 0; 1 0 0 ];
0499    <span class="keyword">elseif</span> sel == <span class="string">'y'</span>
0500       <span class="comment">% swap Z and Y</span>
0501       T = [ 1 0 0; 0 0 1; 0 1 0 ];
0502    <span class="keyword">elseif</span> sel == <span class="string">'z'</span>
0503       T = eye(3);
0504    <span class="keyword">else</span>
0505       error(<span class="string">'sel must be &quot;x&quot;, &quot;y&quot; or &quot;z&quot;'</span>);
0506    <span class="keyword">end</span>
0507    mdl3.nodes = mdl3.nodes * T; <span class="comment">% AB: SWAP axes</span>
0508 
0509    <span class="comment">% set name</span>
0510    mdl2 = <a href="../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>(<span class="string">'fwd_model'</span>,sprintf(<span class="string">'%s 2D'</span>,mdl3.name));
0511 
0512    <span class="comment">% set nodes</span>
0513    [bdy,idx] = <a href="../../eidors/solvers/forward/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>(mdl3.elems);
0514    vtx = mdl3.nodes;
0515    z_vtx = reshape(vtx(bdy,3), size(bdy) );
0516    z_vtx_thres = max(z_vtx(:))-10*eps*<a href="#_sub4" class="code" title="subfunction r = range(a)">range</a>(z_vtx(:));
0517    lay0  = find( all(z_vtx &gt;= z_vtx_thres, 2) );
0518    bdy0  = bdy( lay0, :);
0519 
0520    vtx0  = unique(bdy0(:));
0521    mdl2.nodes = vtx(vtx0,1:2);
0522 
0523    <span class="comment">% set elems</span>
0524    nmap  = zeros(size(vtx,1),1); nmap(vtx0) = 1:length(vtx0);
0525    bdy0  = reshape(nmap(bdy0), size(bdy0) ); <span class="comment">% renumber to new scheme</span>
0526    mdl2.elems = bdy0;
0527 
0528    <span class="comment">% set boundary</span>
0529    mdl2.boundary = <a href="../../eidors/solvers/forward/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>( mdl2.elems);
0530 
0531    <span class="comment">% set gnd_node</span>
0532    mdl2.gnd_node = nmap(mdl3.gnd_node);
0533 
0534    <span class="comment">% set material indices</span>
0535    <span class="comment">% TODO: vectorize code</span>
0536    idx2 = {};
0537    idx0  = idx( lay0, :);
0538    <span class="keyword">for</span> i=1:size(idx3,2)
0539       idx2{i} = [];
0540       ii = 1;
0541       <span class="keyword">for</span> j=1:size(idx3{i},1)
0542          idx_tmp = find( idx0==idx3{i}(j) );
0543          <span class="keyword">if</span> not(isempty(idx_tmp))
0544             idx2{i}(ii,1) = idx_tmp(1,1);
0545             ii = ii + 1;
0546          <span class="keyword">end</span>
0547       <span class="keyword">end</span>
0548    <span class="keyword">end</span>
0549 
0550    <span class="comment">% set electrode</span>
0551    <span class="keyword">if</span> isfield(mdl3,<span class="string">'electrode'</span>)
0552       mdl2.electrode = mdl3.electrode;
0553       <span class="keyword">for</span> i=1:length(mdl2.electrode);
0554          nn = mdl3.nodes(mdl3.electrode(i).nodes,:);
0555          enodes = nmap( mdl2.electrode(i).nodes );
0556          enodes(enodes==0) = []; <span class="comment">% Remove 3D layers</span>
0557          mdl2.electrode(i).nodes = enodes(:)';
0558       <span class="keyword">end</span>
0559    <span class="keyword">end</span>
0560 
0561    ignore = {<span class="string">'electrode'</span>, <span class="string">'nodes'</span>, <span class="string">'boundary'</span>, <span class="string">'elems'</span>, <span class="string">'gnd_node'</span>, <span class="string">'boundary_numbers'</span>, <span class="string">'mat_idx'</span>};
0562    <span class="keyword">for</span> n=fieldnames(mdl3)'
0563       <span class="keyword">if</span> ~any(strcmp(n,ignore))
0564          mdl2.(n{:}) = mdl3.(n{:});
0565       <span class="keyword">end</span>
0566    <span class="keyword">end</span>
0567 
0568 <a name="_sub6" href="#_subfunctions" class="code">function mdl = convert_cem2pem(mdl, xyzc)</a>
0569    <span class="keyword">if</span> ~isfield(mdl, <span class="string">'electrode'</span>)
0570       <span class="keyword">return</span>;
0571    <span class="keyword">end</span>
0572    nd = size(mdl.nodes,2); <span class="comment">% number of dimensions</span>
0573    <span class="keyword">for</span> i=1:length(mdl.electrode)
0574       en = mdl.electrode(i).nodes;
0575       nn = mdl.nodes(en,:); <span class="comment">% all nodes for this electrode</span>
0576       <span class="keyword">if</span> nd == 2
0577          np = xyzc(i,[1 3]); <span class="comment">% true elec location (2d)</span>
0578       <span class="keyword">else</span>
0579          np = xyzc(i,:); <span class="comment">% true elec location (3d)</span>
0580       <span class="keyword">end</span>
0581       D = <a href="#_sub7" class="code" title="subfunction D2 = pdist(X) ">pdist</a>([np; nn]);
0582       [~,idx] = min(D(1,2:end)); <span class="comment">% closest CEM node to ideal PEM location</span>
0583       mdl.electrode(i).nodes = en(idx);
0584       <span class="comment">% NOTE: used to bump node's location but now we place a corner of the</span>
0585       <span class="comment">% square electrode at precisely the correct location</span>
0586       <span class="comment">%mdl.nodes(en,:) = np; % shift PEM node to true location</span>
0587    <span class="keyword">end</span>
0588 
0589 <a name="_sub7" href="#_subfunctions" class="code">function D2 = pdist(X) </a><span class="comment">% row vectors</span>
0590    <span class="keyword">if</span> nargin == 2; error(<span class="string">'only supports Euclidean distances'</span>); <span class="keyword">end</span>
0591    <span class="comment">%D2 = bsxfun(@plus, dot(X, X, 1)', dot(Y, Y, 1)) - 2*(X'*Y) % 1d</span>
0592    D2 = bsxfun(@minus, X, permute(X,[3 2 1]));
0593    D2 = squeeze(sqrt(sum(D2.^2,2)));
0594 
0595 <a name="_sub8" href="#_subfunctions" class="code">function [mdl, c] = shift_electrode_positions(mdl, dx)</a>
0596    <span class="keyword">for</span> i = 1:length(mdl.electrode)
0597       en = mdl.electrode(i).nodes;
0598       ex = mdl.nodes(en,:);
0599       ep(i,:) = (max(ex,[],1) + min(ex,[],1))/2; <span class="comment">% mid-point</span>
0600    <span class="keyword">end</span>
0601    [mdl, c] = <a href="#_sub9" class="code" title="subfunction [mdl, c] = correct_electrode_positions(mdl, xyzc)">correct_electrode_positions</a>(mdl, ep + dx);
0602 
0603 <a name="_sub9" href="#_subfunctions" class="code">function [mdl, c] = correct_electrode_positions(mdl, xyzc)</a>
0604    <span class="comment">%eidors_msg('correct_electrode_positions');</span>
0605    nd = size(mdl.nodes,2);
0606    c = 0; err = 1;
0607    <span class="keyword">while</span> max(err) &gt; eps
0608       <span class="keyword">for</span> n = 1:nd
0609          <span class="keyword">switch</span>(n)
0610             <span class="keyword">case</span> 1
0611                mdl = <a href="#_sub10" class="code" title="subfunction   mdl = mash_nodes(mdl, method, idm, dim, elec_true)">mash_nodes</a>(mdl, <span class="string">'shift_all'</span>,     1, 1, xyzc); <span class="comment">% X (downslope)</span>
0612             <span class="keyword">case</span> 2 <span class="comment">% 2d: Y, 3d: Z</span>
0613                mdl = <a href="#_sub10" class="code" title="subfunction   mdl = mash_nodes(mdl, method, idm, dim, elec_true)">mash_nodes</a>(mdl, <span class="string">'shift_surface'</span>, 1, nd, xyzc); <span class="comment">% Y or Z (vertical)</span>
0614             <span class="keyword">case</span> 3 <span class="comment">% note: we only do this for 3d</span>
0615                mdl = <a href="#_sub10" class="code" title="subfunction   mdl = mash_nodes(mdl, method, idm, dim, elec_true)">mash_nodes</a>(mdl, <span class="string">'shift_middle'</span>,  1, 2, xyzc); <span class="comment">% Y (cross-slope)</span>
0616             <span class="keyword">otherwise</span>
0617                error(<span class="string">'duh!'</span>);
0618          <span class="keyword">end</span>
0619       <span class="keyword">end</span>
0620       err = sqrt(sum(<a href="#_sub11" class="code" title="subfunction err = mdl_elec_err(mdl, xyzc)">mdl_elec_err</a>(mdl, xyzc).^2,2));
0621       c=c+1;
0622       <span class="keyword">if</span> c &gt;= 100
0623          <span class="keyword">break</span>;
0624       <span class="keyword">end</span>
0625    <span class="keyword">end</span>
0626 
0627 <a name="_sub10" href="#_subfunctions" class="code">function   mdl = mash_nodes(mdl, method, idm, dim, elec_true)</a>
0628    elec_err = <a href="#_sub11" class="code" title="subfunction err = mdl_elec_err(mdl, xyzc)">mdl_elec_err</a>(mdl, elec_true);
0629    err = elec_err(:,dim);
0630 
0631    <span class="comment">% add borders for electrode positions at</span>
0632    <span class="comment">% the volume boundary and 50% of the edge to electrode distance</span>
0633    xq = mdl.nodes(:,idm);
0634    x = [min(xq); <span class="keyword">...</span>
0635         mean([min(xq) min(elec_true(:,idm))]); <span class="keyword">...</span>
0636         elec_true(:,idm);
0637         mean([max(xq) max(elec_true(:,idm))]); <span class="keyword">...</span>
0638         max(xq)];
0639    v = [0; 0; err; 0; 0];
0640 
0641    <span class="comment">% scale error to match the electrode locations</span>
0642    interp_method = <span class="string">'linear'</span>;
0643    <span class="keyword">if</span> strcmp(method, <span class="string">'shift_surface'</span>)
0644          interp_method = <span class="string">'pchip'</span>;
0645    <span class="keyword">end</span>
0646    vq = interp1(x, v, xq, interp_method, <span class="string">'extrap'</span>);
0647 
0648    <span class="keyword">switch</span> method
0649       <span class="keyword">case</span> <span class="string">'shift_all'</span>
0650          vqs = 1;
0651       <span class="keyword">case</span> <span class="string">'shift_middle'</span>
0652          yq = mdl.nodes(:,dim);
0653          yqr = max(yq)-min(yq); <span class="comment">% range</span>
0654          yqm = (max(yq) + min(yq))/2; <span class="comment">% middle = (max + min)/2</span>
0655          vqs = 1-abs(yq-yqm)./(yqr/2); <span class="comment">% scale the shift depending on x's distance from midline</span>
0656       <span class="keyword">case</span> <span class="string">'shift_surface'</span> <span class="comment">% assumes positive surface</span>
0657          yq = mdl.nodes(:,dim);
0658          yqr = max(yq) - min(yq);
0659          yqm = min(yq); <span class="comment">% min</span>
0660          vqs = abs(yq - yqm)./yqr; <span class="comment">% scale by distance from surface</span>
0661       <span class="keyword">otherwise</span>
0662          error([<span class="string">'unrecognized method: '</span>,method]);
0663    <span class="keyword">end</span>
0664    mdl.nodes(:,dim) = mdl.nodes(:,dim) + (vq .* vqs);
0665 
0666 <span class="comment">% calculate the error in electrode position for the fwd_model</span>
0667 <a name="_sub11" href="#_subfunctions" class="code">function err = mdl_elec_err(mdl, xyzc)</a>
0668    <span class="keyword">if</span> ~isfield(mdl, <span class="string">'electrode'</span>)
0669       error(<span class="string">'electrodes not available on this model, must supply positional error'</span>);
0670    <span class="keyword">end</span>
0671 
0672    nel=length(mdl.electrode); <span class="comment">% number of electrodes</span>
0673    nd=size(mdl.nodes,2); <span class="comment">% number of dimensions</span>
0674 
0675    eu = ones(nel,nd)*NaN; <span class="comment">% init</span>
0676    <span class="keyword">for</span> i=1:length(mdl.electrode)
0677       nn = mdl.nodes(mdl.electrode(i).nodes,:); <span class="comment">% nodes per electrode</span>
0678       eu(i,:) = (max(nn,[],1) + min(nn,[],1))./2; <span class="comment">% approx centre of each electrode</span>
0679    <span class="keyword">end</span>
0680    err = xyzc(:,1:nd) - eu;
0681 
0682 <a name="_sub12" href="#_subfunctions" class="code">function test_fwd_rec_match(imdl,idx,str)</a>
0683    fwd = imdl.fwd_model.nodes(:,idx);
0684    mxf = max(fwd); mnf = min(fwd);
0685    rec = imdl.rec_model.nodes;
0686    mxr = max(rec); mnr = min(fwd);
0687    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>([<span class="string">'fwd-rec match: '</span>,str],[mxf,mnf],[mxr,mnr],10*eps);
0688 
0689 <a name="_sub13" href="#_subfunctions" class="code">function do_unit_test</a>
0690    ne = 16;
0691    imdl = <a href="mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>(<span class="string">'h2p5a'</span>, ne);
0692    imdl.fwd_model.stimulation = <a href="stim_pattern_geophys.html" class="code" title="function [stim,S]= stim_pattern_geophys( n_elec, pat_type,  options )">stim_pattern_geophys</a>(ne, <span class="string">'Wenner'</span>);
0693    img = <a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(imdl.fwd_model, 1);
0694    img.fwd_solve.get_all_meas = 1;
0695    vh = <a href="../../eidors/solvers/forward/fwd_solve_halfspace.html" class="code" title="function data = fwd_solve_halfspace(fwd_model, img)">fwd_solve_halfspace</a>(img);
0696    vd = <a href="../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(img);
0697 clf; h=plot([vh.meas vd.meas],<span class="string">'o--'</span>); legend(<span class="string">'analytic'</span>,<span class="string">'FEM'</span>); set(gca,<span class="string">'box'</span>,<span class="string">'off'</span>); set(h,<span class="string">'LineWidth'</span>,2);
0698 
0699    imdl1 = <a href="mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>(<span class="string">'h2a'</span>,[1:6]);
0700    imdl2 = <a href="mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>(<span class="string">'h2a'</span>,[1:6]');
0701    imdl3 = <a href="mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>(<span class="string">'h2a'</span>,[1:6]'*[1 0]);
0702    imdl3Hnm2d = <a href="mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>(<span class="string">'H2a'</span>,[1:6],{<span class="string">'threshold'</span>,Inf}); <span class="comment">% try without mashing nodes, no veritcal geometry... electrodes should be precisely located if the electrodes were correctly placed</span>
0703    imdl3Hnm3d = <a href="mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>(<span class="string">'H3a'</span>,[1:6],{<span class="string">'threshold'</span>,Inf}); <span class="comment">% try without mashing nodes, no veritcal geometry... electrodes should be precisely located if the electrodes were correctly placed</span>
0704    imdl4 = <a href="mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>(<span class="string">'h2a'</span>,[1:6]'*[1 0] + ([1:6]*0+2)'*[0 1]);
0705    R = @(x) [cosd(x) -sind(x); sind(x) cosd(x)]; <span class="comment">% rotation matrix</span>
0706    X = [0 2];
0707    imdl5 = <a href="mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>(<span class="string">'h2a'</span>,([1:6]'*[1 0] + ([1:6]*0+1)'*X)*R(-135));
0708    elec_pos_2d = [1 1; 2 2; 3 1; 4 1.5];
0709    elec_pos_3d = [1 0 0; 2 0.5 1; 3 -0.5 2.5; 10 0 3];
0710    imdl2dc = <a href="mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>(<span class="string">'h2a'</span>, elec_pos_2d); <span class="comment">% 2D complete electrode model</span>
0711    imdl3dc = <a href="mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>(<span class="string">'h3a'</span>, elec_pos_3d); <span class="comment">% 3D complete electrode model</span>
0712    imdl2dp = <a href="mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>(<span class="string">'H2a'</span>, elec_pos_2d); <span class="comment">% 2D point electrode model</span>
0713    imdl3dp = <a href="mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>(<span class="string">'H3a'</span>, elec_pos_3d); <span class="comment">% 3D point electrode model</span>
0714    imdl2df = <a href="mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>(<span class="string">'H2a'</span>, elec_pos_2d, {<span class="string">'threshold'</span>, Inf}); <span class="comment">% 2D point electrode model... without mashing</span>
0715    imdl3df = <a href="mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>(<span class="string">'H3a'</span>, elec_pos_3d, {<span class="string">'threshold'</span>, Inf}); <span class="comment">% 3D point electrode model... without mashing</span>
0716 
0717    <span class="comment">% dual meshes</span>
0718    imdlh32 = <a href="mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>(<span class="string">'h32a'</span>, elec_pos_3d);
0719    imdlh22 = <a href="mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>(<span class="string">'h22a'</span>, elec_pos_2d);
0720    imdlH32 = <a href="mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>(<span class="string">'H32a'</span>, elec_pos_3d);
0721    imdlH22 = <a href="mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>(<span class="string">'H22a'</span>, elec_pos_2d);
0722 
0723    <span class="comment">% std dual meshes w/ 16 elec</span>
0724    imdlh32_16 = <a href="mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>(<span class="string">'h32a'</span>, 16);
0725    <a href="#_sub12" class="code" title="subfunction test_fwd_rec_match(imdl,idx,str)">test_fwd_rec_match</a>(imdlh32_16,[1,3],<span class="string">'h32a'</span>)
0726    imdlh22_16 = <a href="mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>(<span class="string">'h22a'</span>, 16);
0727    <a href="#_sub12" class="code" title="subfunction test_fwd_rec_match(imdl,idx,str)">test_fwd_rec_match</a>(imdlh22_16,[1,2],<span class="string">'h22a'</span>)
0728    imdlH32_16 = <a href="mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>(<span class="string">'H32a'</span>, 16);
0729    <a href="#_sub12" class="code" title="subfunction test_fwd_rec_match(imdl,idx,str)">test_fwd_rec_match</a>(imdlH32_16,[1,3],<span class="string">'h22a'</span>)
0730    imdlH22_16 = <a href="mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>(<span class="string">'H22a'</span>, 16);
0731    <a href="#_sub12" class="code" title="subfunction test_fwd_rec_match(imdl,idx,str)">test_fwd_rec_match</a>(imdlH22_16,[1,2],<span class="string">'h22a'</span>)
0732 
0733 <span class="keyword">if</span> 0
0734    <span class="comment">% Nolwenn's grid</span>
0735    [yy,xx] = meshgrid(0:3:24, [0 4:2:20*2 20*2+4]); <span class="comment">% 9 x 21 grid</span>
0736    xyz = [xx(:) yy(:) zeros(length(yy(:)),1)];
0737 
0738    <span class="comment">% test grid</span>
0739    <span class="comment">% 1. bad electrodes ... ? fixme?</span>
0740    <span class="comment">% 2. mash_nodes breaks for co-located nodes in any particular dimension... need 2d interp?</span>
0741    [yy,xx]=meshgrid(1:3,1:3); xyz = [xx(:) yy(:) zeros(length(yy(:)),1)]; <span class="comment">% 3 x 3 grid</span>
0742    imdl = <a href="mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>(<span class="string">'H3a'</span>,xyz);
0743    <span class="comment">% TODO add 'g3a' and 'G3a' types?</span>
0744 <span class="keyword">end</span>
0745 
0746    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'h2a halfspace vs default TEST'</span>, norm(vh.meas - vd.meas), 0, 4e-3);
0747    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'1d elec list equivalence (row/col)'</span>,<a href="#_sub14" class="code" title="subfunction xyz = unit_test_elec_pos(imdl, R, X)">unit_test_elec_pos</a>(imdl1), <a href="#_sub14" class="code" title="subfunction xyz = unit_test_elec_pos(imdl, R, X)">unit_test_elec_pos</a>(imdl2));
0748    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'1d vs. 2d elec list equivalence'</span>,<a href="#_sub14" class="code" title="subfunction xyz = unit_test_elec_pos(imdl, R, X)">unit_test_elec_pos</a>(imdl1), <a href="#_sub14" class="code" title="subfunction xyz = unit_test_elec_pos(imdl, R, X)">unit_test_elec_pos</a>(imdl3));
0749    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'2D PEM w/o node mashing, no vertical relief'</span>,[1:6]'*[1 0], <a href="#_sub14" class="code" title="subfunction xyz = unit_test_elec_pos(imdl, R, X)">unit_test_elec_pos</a>(imdl3Hnm2d), eps);
0750    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'2D PEM *is* PEM'</span>,length(imdl3Hnm2d.fwd_model.electrode(1).nodes),1)
0751    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'3D PEM w/o node mashing, no vertical relief'</span>,[1:6]'*[1 0 0], <a href="#_sub14" class="code" title="subfunction xyz = unit_test_elec_pos(imdl, R, X)">unit_test_elec_pos</a>(imdl3Hnm3d), eps);
0752    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'3D PEM *is* PEM'</span>,length(imdl3Hnm3d.fwd_model.electrode(1).nodes),1)
0753    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'1d vs. 2d + y=2 elec list equivalence'</span>,<a href="#_sub14" class="code" title="subfunction xyz = unit_test_elec_pos(imdl, R, X)">unit_test_elec_pos</a>(imdl1), <a href="#_sub14" class="code" title="subfunction xyz = unit_test_elec_pos(imdl, R, X)">unit_test_elec_pos</a>(imdl4)-([1:6]*0+2)'*[0 1]);
0754    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'1d vs. 2d + y=2 - 135 deg elec eq'</span>, <span class="keyword">...</span>
0755                  <a href="#_sub14" class="code" title="subfunction xyz = unit_test_elec_pos(imdl, R, X)">unit_test_elec_pos</a>(imdl1), <span class="keyword">...</span>
0756                  <a href="#_sub14" class="code" title="subfunction xyz = unit_test_elec_pos(imdl, R, X)">unit_test_elec_pos</a>(imdl5, R(135), -X), eps*10);
0757    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'2d with vertical geometry (mash nodes) CEM'</span>, <span class="keyword">...</span>
0758                  elec_pos_2d, <span class="keyword">...</span>
0759                  <a href="#_sub14" class="code" title="subfunction xyz = unit_test_elec_pos(imdl, R, X)">unit_test_elec_pos</a>(imdl2dc), 0.01);
0760    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'3d with vertical geometry (mash nodes) CEM'</span>, <span class="keyword">...</span>
0761                  elec_pos_3d, <span class="keyword">...</span>
0762                  <a href="#_sub14" class="code" title="subfunction xyz = unit_test_elec_pos(imdl, R, X)">unit_test_elec_pos</a>(imdl3dc), 0.001);
0763    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'2d with vertical geometry (mash nodes) PEM'</span>, <span class="keyword">...</span>
0764                  elec_pos_2d, <span class="keyword">...</span>
0765                  <a href="#_sub14" class="code" title="subfunction xyz = unit_test_elec_pos(imdl, R, X)">unit_test_elec_pos</a>(imdl2dp), 10*eps);
0766    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'3d with vertical geometry (mash nodes) PEM'</span>, <span class="keyword">...</span>
0767                  elec_pos_3d, <span class="keyword">...</span>
0768                  <a href="#_sub14" class="code" title="subfunction xyz = unit_test_elec_pos(imdl, R, X)">unit_test_elec_pos</a>(imdl3dp), 10*eps);
0769    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'2d with vertical geometry (w/o mash nodes) PEM'</span>, <span class="keyword">...</span>
0770                  elec_pos_2d, <span class="keyword">...</span>
0771                  <a href="#_sub14" class="code" title="subfunction xyz = unit_test_elec_pos(imdl, R, X)">unit_test_elec_pos</a>(imdl2df), -10*eps);
0772    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'3d with vertical geometry (w/o mash nodes) PEM'</span>, <span class="keyword">...</span>
0773                  elec_pos_3d, <span class="keyword">...</span>
0774                  <a href="#_sub14" class="code" title="subfunction xyz = unit_test_elec_pos(imdl, R, X)">unit_test_elec_pos</a>(imdl3df), -10*eps);
0775 
0776    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'h32a dual 3d/2d'</span>, <span class="keyword">...</span>
0777                  elec_pos_3d, <span class="keyword">...</span>
0778                  <a href="#_sub14" class="code" title="subfunction xyz = unit_test_elec_pos(imdl, R, X)">unit_test_elec_pos</a>(imdlh32), 0.001);
0779    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'H32a dual 3d/2d'</span>, <span class="keyword">...</span>
0780                  elec_pos_3d, <span class="keyword">...</span>
0781                  <a href="#_sub14" class="code" title="subfunction xyz = unit_test_elec_pos(imdl, R, X)">unit_test_elec_pos</a>(imdlH32), 10*eps);
0782    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'h22a dual 2d/2d'</span>, <span class="keyword">...</span>
0783                  elec_pos_2d, <span class="keyword">...</span>
0784                  <a href="#_sub14" class="code" title="subfunction xyz = unit_test_elec_pos(imdl, R, X)">unit_test_elec_pos</a>(imdlh22), 0.002);
0785    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'H22a dual 2d/2d'</span>, <span class="keyword">...</span>
0786                  elec_pos_2d, <span class="keyword">...</span>
0787                  <a href="#_sub14" class="code" title="subfunction xyz = unit_test_elec_pos(imdl, R, X)">unit_test_elec_pos</a>(imdlH22), 10*eps);
0788 
0789 clf; subplot(221); <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imdl1.fwd_model); title(<span class="string">'models match? A'</span>);
0790      subplot(222); <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imdl5.fwd_model); title(<span class="string">'models match? C'</span>);
0791      subplot(223); <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imdl2dc.fwd_model); title(<span class="string">'2d deformations'</span>);
0792      subplot(224); <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imdl3dc.fwd_model); title(<span class="string">'3d deformations'</span>); view([0 -1 0.01]);
0793 
0794 <span class="keyword">if</span> 1
0795    clf; subplot(221); <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imdlh22.fwd_model);
0796         subplot(222); <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imdlh32.fwd_model);
0797         subplot(223); <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imdlH22.fwd_model);
0798         subplot(224); <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imdlH32.fwd_model);
0799 <span class="keyword">end</span>
0800 
0801 <span class="keyword">if</span> 0
0802    clf; subplot(221); <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imdlh22.rec_model);
0803         subplot(222); <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imdlh32.rec_model);
0804         subplot(223); <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imdlH22.rec_model);
0805         subplot(224); <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imdlH32.rec_model);
0806 <span class="keyword">end</span>
0807 
0808    imdl = <a href="mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>(<span class="string">'h2p5a'</span>, ne, {<span class="string">'extra_ng_code'</span>, <span class="string">'solid tt = orthobrick(-1,-1,-1;-0.5,0,-0.5);\ntlo tt;\n'</span>});
0809    clf; <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imdl.fwd_model);
0810    <span class="comment">% Note: this just has to be swallowed safely...</span>
0811 
0812 <a name="_sub14" href="#_subfunctions" class="code">function xyz = unit_test_elec_pos(imdl, R, X)</a>
0813    <span class="keyword">if</span> nargin &lt; 2; R = 1; <span class="keyword">end</span>
0814    <span class="keyword">if</span> nargin &lt; 3; X = 0; <span class="keyword">end</span>
0815    fmdl = imdl.fwd_model;
0816    xyz = zeros(length(fmdl.electrode),size(fmdl.nodes,2))*NaN;
0817    <span class="keyword">for</span> i = 1:length(fmdl.electrode)
0818       nn = fmdl.nodes(fmdl.electrode(i).nodes,:);
0819       xyz(i,:) = (max(nn,[],1) + min(nn,[],1))/2;
0820       xyz(i,:) = xyz(i,:)*R + X;
0821    <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 30-Dec-2022 20:46:51 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>
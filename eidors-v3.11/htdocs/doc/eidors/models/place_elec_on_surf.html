<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of place_elec_on_surf</title>
  <meta name="keywords" content="place_elec_on_surf">
  <meta name="description" content="PLACE_ELEC_ON_SURF Place electrodes on the surface of a model">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">eidors</a> &gt; <a href="index.html">models</a> &gt; place_elec_on_surf.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/models&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>place_elec_on_surf
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>PLACE_ELEC_ON_SURF Place electrodes on the surface of a model</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function mdl2 = place_elec_on_surf(mdl,elec_pos, elec_spec,ng_opt_file, maxh) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">PLACE_ELEC_ON_SURF Place electrodes on the surface of a model
 mdl = place_elec_on_surf(mdl,elec_pos, elec_spec, ng_opt_file, maxh)
 INPUT:
  mdl         = an EIDORS fwd_model struct
  elec_pos    = an array specigying electrode positions
  elec_shape  = an array specifying electrode shape (can be different for
                each electrode)
  ng_opt_file = an alternative ng.opt file to use (OPTIONAL)
                specify [] to use dafault
  maxh        = maximum edge length (if ng_opt_file is specified, maxh 
                only applies to the volume and not the surface)
 ELECTRODE POSITIONS:
  elec_pos = [n_elecs_per_plane,z_planes] 
     OR
  elec_pos = [degrees,z] centres of each electrode (N_elecs x 2)
     OR
  elec_pos = [x y z] centres of each electrode (N_elecs x 3)

  Note: N_elecs &gt;= 2.

 ELECTRODE SHAPES::
  elec_shape = [width,height, maxsz]  % Rectangular elecs
     OR
  elec_shape = [radius, 0, maxsz ]    % Circular elecs

 NOTE that this function requires both Netgen and Gmsh.
 It will completely re-mesh your model.
 The code makes several assumptions about the output of Netgen, which it
 attempts to control through the ng.opt file, but there will be meshes 
 for which this appraoch will fail. In this case, you can supply your own 
 file with options for Netgen (with a filename different than ng.opt), or
 change your mesh and/or electrode locations. Most common problem is too 
 big electrode maxh value (must be significantly smaller than the smallest
 element on which the electrode will fall).

 CITATION_REQUEST:
 TITLE: FEM Electrode Refinement for Electrical Impedance Tomography 
 AUTHOR: B Grychtol and A Adler
 JOURNAL: Engineering in Medicine and Biology Society (EMBC), 2013 Annual 
 International Conference of the IEEE 
 YEAR: 2013

 See also <a href="gmsh_stl2tet.html" class="code" title="function mdl = gmsh_stl2tet(stlfile, maxh, extra)">gmsh_stl2tet</a>, ng_write_opt, <a href="merge_meshes.html" class="code" title="function out = merge_meshes(M1,varargin)">merge_meshes</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG eidors progress and status messages</li><li><a href="../../eidors/graphics/matlab/level_model_slice.html" class="code" title="function [out, out2, out3] = level_model_slice(varargin)">level_model_slice</a>	LEVEL_MODEL_SLICE - level 3D points for slicing at z=0</li><li><a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>	SHOW_FEM: show the EIDORS3D finite element model</li><li><a href="../../eidors/meshing/netgen/call_netgen.html" class="code" title="function status= call_netgen(geo_file, vol_file, msz_file, finelevel)">call_netgen</a>	CALL_NETGEN: call netgen to create a vol_file from a geo_file</li><li><a href="../../eidors/meshing/netgen/ng_mk_2d_model.html" class="code" title="function mdl = ng_mk_2d_model(varargin)">ng_mk_2d_model</a>	NG_MG_2D_MODELS create a 2D mesh with Netgen via the in2d interface</li><li><a href="../../eidors/meshing/netgen/ng_mk_extruded_model.html" class="code" title="function [fmdl,mat_idx] = ng_mk_extruded_model(shape, elec_pos, elec_shape,extra_ng_code)">ng_mk_extruded_model</a>	NG_MAKE_EXTRUDED_MODEL: create extruded models using netgen</li><li><a href="../../eidors/meshing/netgen/ng_mk_fwd_model.html" class="code" title="function [fwd_mdl]=ng_mk_fwd_model( ng_vol_filename, centres,name, stim_pattern, z_contact, postprocmesh)">ng_mk_fwd_model</a>	NG_MK_FWD_MODEL: create a fwd_model object from a netgen vol file</li><li><a href="../../eidors/meshing/netgen/ng_write_opt.html" class="code" title="function opt = ng_write_opt(varargin)">ng_write_opt</a>	NG_WRITE_OPT Write an ng.opt file in current directory</li><li><a href="../../eidors/meshing/stl/stl_write.html" class="code" title="function stl_write(fv, name)">stl_write</a>	STL_WRITE Create a text STL file from a patch struct</li><li><a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>	FIX_MODEL: Add useful fields to a model</li><li><a href="gmsh_stl2tet.html" class="code" title="function mdl = gmsh_stl2tet(stlfile, maxh, extra)">gmsh_stl2tet</a>	GMSH_STL2TET creates a tetrahedral mesh from an stl file</li><li><a href="merge_meshes.html" class="code" title="function out = merge_meshes(M1,varargin)">merge_meshes</a>	MERGE_MESHES - merges two meshes based on common nodes</li><li><a href="place_elec_on_surf.html" class="code" title="function mdl2 = place_elec_on_surf(mdl,elec_pos, elec_spec,ng_opt_file, maxh)">place_elec_on_surf</a>	PLACE_ELEC_ON_SURF Place electrodes on the surface of a model</li><li><a href="point_in_triangle.html" class="code" title="function out = point_in_triangle(P,E,V,epsilon, str)">point_in_triangle</a>	POINT_IN_TRIANGLE tests points for membership in triangles</li><li><a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>	SPARSE Create sparse matrix (EIDORS overload).</li><li><a href="../../eidors/overloads/vecnorm/vecnorm.html" class="code" title="function out = vecnorm(x, p, dim)">vecnorm</a>	Vectorwise norm: overload for matlab pre 2017b</li><li><a href="../../eidors/tools/citeme.html" class="code" title="function citeme(fname)">citeme</a>	CITEME Display citation requests</li><li><a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>	EIDORS_CACHE Control eidors caching</li><li><a href="../../eidors/tools/eidors_debug.html" class="code" title="function out = eidors_debug(command, fstr)">eidors_debug</a>	EIDORS_DEBUG Global managment of debug flags</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="mk_thorax_model.html" class="code" title="function out = mk_thorax_model(str, varargin)">mk_thorax_model</a>	MK_THORAX_MODEL FEM models of the thorax</li><li><a href="place_elec_on_surf.html" class="code" title="function mdl2 = place_elec_on_surf(mdl,elec_pos, elec_spec,ng_opt_file, maxh)">place_elec_on_surf</a>	PLACE_ELEC_ON_SURF Place electrodes on the surface of a model</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function mdl2 = do_place_elec_on_surf(mdl,elec_pos, elec_spec,ng_opt_file, maxh)</a></li><li><a href="#_sub2" class="code">function debugging = do_debug;</a></li><li><a href="#_sub3" class="code">function write_to_stl(mdl,stlfn)</a></li><li><a href="#_sub4" class="code">function write_ng_opt_file(ng_opt_file, maxh)</a></li><li><a href="#_sub5" class="code">function mdl = prepare_surf_model(mdl)</a></li><li><a href="#_sub6" class="code">function mdl = orient_boundary(mdl)</a></li><li><a href="#_sub7" class="code">function mdl = flatten_electrode(mdl,inner,outer, V)</a></li><li><a href="#_sub8" class="code">function match = find_matching_nodes(mdl, nodes,th)</a></li><li><a href="#_sub9" class="code">function [joint EL1 EL2 V] = add_electrodes(mdl,N,fc,elecs)</a></li><li><a href="#_sub10" class="code">function PN = project_nodes_on_elec(mdl,elecs,nodes)</a></li><li><a href="#_sub11" class="code">function [elecs] = parse_elecs(mdl, elec_pos, elec_shape )</a></li><li><a href="#_sub12" class="code">function [u v s] = get_face_basis(mdl, fc)</a></li><li><a href="#_sub13" class="code">function [fc pos] = find_elec_centre(mdl, el_th,el_z)</a></li><li><a href="#_sub14" class="code">function [out, fc] = grow_neighbourhood(mdl, varargin)</a></li><li><a href="#_sub15" class="code">function nn =  find_neighbours(fc, bb);</a></li><li><a href="#_sub16" class="code">function [e p] = find_face_under_elec(mdl, elec_pos)</a></li><li><a href="#_sub17" class="code">function do_unit_test</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function mdl2 = place_elec_on_surf(mdl,elec_pos, elec_spec,ng_opt_file, maxh)</a>
0002 <span class="comment">%PLACE_ELEC_ON_SURF Place electrodes on the surface of a model</span>
0003 <span class="comment">% mdl = place_elec_on_surf(mdl,elec_pos, elec_spec, ng_opt_file, maxh)</span>
0004 <span class="comment">% INPUT:</span>
0005 <span class="comment">%  mdl         = an EIDORS fwd_model struct</span>
0006 <span class="comment">%  elec_pos    = an array specigying electrode positions</span>
0007 <span class="comment">%  elec_shape  = an array specifying electrode shape (can be different for</span>
0008 <span class="comment">%                each electrode)</span>
0009 <span class="comment">%  ng_opt_file = an alternative ng.opt file to use (OPTIONAL)</span>
0010 <span class="comment">%                specify [] to use dafault</span>
0011 <span class="comment">%  maxh        = maximum edge length (if ng_opt_file is specified, maxh</span>
0012 <span class="comment">%                only applies to the volume and not the surface)</span>
0013 <span class="comment">% ELECTRODE POSITIONS:</span>
0014 <span class="comment">%  elec_pos = [n_elecs_per_plane,z_planes]</span>
0015 <span class="comment">%     OR</span>
0016 <span class="comment">%  elec_pos = [degrees,z] centres of each electrode (N_elecs x 2)</span>
0017 <span class="comment">%     OR</span>
0018 <span class="comment">%  elec_pos = [x y z] centres of each electrode (N_elecs x 3)</span>
0019 <span class="comment">%</span>
0020 <span class="comment">%  Note: N_elecs &gt;= 2.</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% ELECTRODE SHAPES::</span>
0023 <span class="comment">%  elec_shape = [width,height, maxsz]  % Rectangular elecs</span>
0024 <span class="comment">%     OR</span>
0025 <span class="comment">%  elec_shape = [radius, 0, maxsz ]    % Circular elecs</span>
0026 <span class="comment">%</span>
0027 <span class="comment">% NOTE that this function requires both Netgen and Gmsh.</span>
0028 <span class="comment">% It will completely re-mesh your model.</span>
0029 <span class="comment">% The code makes several assumptions about the output of Netgen, which it</span>
0030 <span class="comment">% attempts to control through the ng.opt file, but there will be meshes</span>
0031 <span class="comment">% for which this appraoch will fail. In this case, you can supply your own</span>
0032 <span class="comment">% file with options for Netgen (with a filename different than ng.opt), or</span>
0033 <span class="comment">% change your mesh and/or electrode locations. Most common problem is too</span>
0034 <span class="comment">% big electrode maxh value (must be significantly smaller than the smallest</span>
0035 <span class="comment">% element on which the electrode will fall).</span>
0036 <span class="comment">%</span>
0037 <span class="comment">% CITATION_REQUEST:</span>
0038 <span class="comment">% TITLE: FEM Electrode Refinement for Electrical Impedance Tomography</span>
0039 <span class="comment">% AUTHOR: B Grychtol and A Adler</span>
0040 <span class="comment">% JOURNAL: Engineering in Medicine and Biology Society (EMBC), 2013 Annual</span>
0041 <span class="comment">% International Conference of the IEEE</span>
0042 <span class="comment">% YEAR: 2013</span>
0043 <span class="comment">%</span>
0044 <span class="comment">% See also gmsh_stl2tet, ng_write_opt, merge_meshes</span>
0045 
0046 <span class="comment">% (C) Bartlomiej Grychtol and Andy Adler, 2012-2013. Licence: GPL v2 or v3</span>
0047 <span class="comment">% $Id: place_elec_on_surf.m 6352 2022-04-26 20:18:45Z bgrychtol $</span>
0048 
0049 <a href="../../eidors/tools/citeme.html" class="code" title="function citeme(fname)">citeme</a>(mfilename);
0050 
0051 <span class="keyword">if</span> ischar(mdl) &amp;&amp; strcmp(mdl, <span class="string">'UNIT_TEST'</span>) <a href="#_sub17" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>;
0052 <span class="keyword">if</span> nargin &lt; 4
0053    ng_opt_file = <span class="string">''</span>;
0054 <span class="keyword">end</span>
0055 <span class="keyword">if</span> nargin &lt; 5
0056    maxh = [];
0057 <span class="keyword">end</span>
0058 
0059 opt.fstr = <span class="string">'place_elec_on_surf'</span>;
0060 mdl2 = <a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub1" class="code" title="subfunction mdl2 = do_place_elec_on_surf(mdl,elec_pos, elec_spec,ng_opt_file, maxh)">do_place_elec_on_surf</a>,{mdl,elec_pos, elec_spec,ng_opt_file, maxh},opt);
0061 
0062 
0063 
0064 <a name="_sub1" href="#_subfunctions" class="code">function mdl2 = do_place_elec_on_surf(mdl,elec_pos, elec_spec,ng_opt_file, maxh)</a>
0065 
0066 
0067 <span class="comment">% filenames</span>
0068 <span class="keyword">if</span> do_debug; fnstem = <span class="string">'tmp1'</span>;
0069 <span class="keyword">else</span>;        fnstem = tempname;
0070 <span class="keyword">end</span>
0071 
0072 stlfn = [fnstem,<span class="string">'.stl'</span>];
0073 meshfn= [fnstem,<span class="string">'.vol'</span>];
0074 
0075 <span class="keyword">if</span> do_debug; fnstem = <span class="string">'tmp2'</span>;
0076 <span class="keyword">else</span>;        fnstem = tempname;
0077 <span class="keyword">end</span>
0078 
0079 stlfn2 = [fnstem,<span class="string">'.stl'</span>];
0080 
0081 <span class="comment">% 1. Get a surface model</span>
0082 mdl = <a href="#_sub5" class="code" title="subfunction mdl = prepare_surf_model(mdl)">prepare_surf_model</a>(mdl);
0083 <span class="keyword">if</span> isempty(maxh)
0084    maxh = max(mdl.edge_len);
0085 <span class="keyword">end</span>
0086 
0087 elecs = <a href="#_sub11" class="code" title="subfunction [elecs] = parse_elecs(mdl, elec_pos, elec_shape )">parse_elecs</a>(mdl,elec_pos,elec_spec);
0088 <span class="keyword">if</span> isempty(elecs)
0089    error(<span class="string">'EIDORS:WrongInput'</span>, <span class="string">'Failed to parse electrode positions. Exiting'</span>);
0090 <span class="keyword">end</span>
0091 
0092 
0093 <span class="comment">% 2. Add extruded electrodes</span>
0094 <span class="keyword">for</span> i = 1:length(elecs)
0095    <span class="keyword">try</span>
0096       [N, fc] = <a href="#_sub14" class="code" title="subfunction [out, fc] = grow_neighbourhood(mdl, varargin)">grow_neighbourhood</a>(mdl,elecs(i));
0097       [mdl E1{i} E2{i} V{i}] = <a href="#_sub9" class="code" title="subfunction [joint EL1 EL2 V] = add_electrodes(mdl,N,fc,elecs)">add_electrodes</a>(mdl,N,fc, elecs(i));
0098    <span class="keyword">catch</span> e
0099       <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'Failed to add electrode #%d'</span>,i,1);
0100       rethrow(e);
0101    <span class="keyword">end</span>
0102 <span class="keyword">end</span>
0103 
0104 <span class="comment">% 3. Save as STL and mesh with NETGEN</span>
0105 <a href="#_sub3" class="code" title="subfunction write_to_stl(mdl,stlfn)">write_to_stl</a>(mdl,stlfn);
0106 <a href="#_sub4" class="code" title="subfunction write_ng_opt_file(ng_opt_file, maxh)">write_ng_opt_file</a>(ng_opt_file, maxh)
0107 <a href="../../eidors/meshing/netgen/call_netgen.html" class="code" title="function status= call_netgen(geo_file, vol_file, msz_file, finelevel)">call_netgen</a>(stlfn,meshfn);
0108 delete(<span class="string">'ng.opt'</span>); <span class="comment">% clean up</span>
0109 
0110 <span class="comment">% 4. Extract surface</span>
0111 fmdl=<a href="../../eidors/meshing/netgen/ng_mk_fwd_model.html" class="code" title="function [fwd_mdl]=ng_mk_fwd_model( ng_vol_filename, centres,name, stim_pattern, z_contact, postprocmesh)">ng_mk_fwd_model</a>(meshfn,[],[],[],[]);
0112 mdl = <a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>(fmdl);
0113 mdl = <a href="#_sub6" class="code" title="subfunction mdl = orient_boundary(mdl)">orient_boundary</a>(mdl);
0114 mdl.elems = mdl.boundary;
0115 
0116 <span class="comment">% 5. One by one, flatten the electrodes</span>
0117 <span class="keyword">for</span> i = 1:length(elecs)
0118    <span class="keyword">try</span> 
0119       mdl = <a href="#_sub7" class="code" title="subfunction mdl = flatten_electrode(mdl,inner,outer, V)">flatten_electrode</a>(mdl,E1{i},E2{i}, V{i});
0120    <span class="keyword">catch</span> e
0121       <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'Failed to flatten electrode #%d'</span>,i,1);
0122       rethrow(e);
0123    <span class="keyword">end</span>
0124 <span class="keyword">end</span>
0125 
0126 <span class="comment">% 6. Keeping the surface intact, remesh the inside</span>
0127 <a href="#_sub3" class="code" title="subfunction write_to_stl(mdl,stlfn)">write_to_stl</a>(mdl,stlfn2);
0128 mdl2 = <a href="gmsh_stl2tet.html" class="code" title="function mdl = gmsh_stl2tet(stlfile, maxh, extra)">gmsh_stl2tet</a>(stlfn2, maxh);
0129 mdl2.electrode = mdl.electrode;
0130 
0131 <span class="comment">% 7. Find all electrode nodes</span>
0132 <span class="keyword">for</span> i = 1:length(elecs)
0133    enodes = mdl.nodes(mdl.electrode(i).nodes,:);
0134    mdl2.electrode(i).nodes = <a href="#_sub8" class="code" title="subfunction match = find_matching_nodes(mdl, nodes,th)">find_matching_nodes</a>(mdl2,enodes,1e-5);
0135 <span class="keyword">end</span>
0136 
0137 <a name="_sub2" href="#_subfunctions" class="code">function debugging = do_debug;</a>
0138   debugging = <a href="../../eidors/tools/eidors_debug.html" class="code" title="function out = eidors_debug(command, fstr)">eidors_debug</a>(<span class="string">'query'</span>,<span class="string">'place_elec_on_surf'</span>);
0139 
0140 <a name="_sub3" href="#_subfunctions" class="code">function write_to_stl(mdl,stlfn)</a>
0141 STL.vertices = mdl.nodes;
0142 STL.faces    = mdl.elems;
0143 <a href="../../eidors/meshing/stl/stl_write.html" class="code" title="function stl_write(fv, name)">stl_write</a>(STL,stlfn);
0144 
0145 <a name="_sub4" href="#_subfunctions" class="code">function write_ng_opt_file(ng_opt_file, maxh)</a>
0146 <span class="comment">% these options are meant to insure that the electrode sides don't get</span>
0147 <span class="comment">% modified, but there's no guarantee</span>
0148 <span class="keyword">if</span> ~isempty(ng_opt_file)
0149    <a href="../../eidors/meshing/netgen/ng_write_opt.html" class="code" title="function opt = ng_write_opt(varargin)">ng_write_opt</a>(ng_opt_file);
0150 <span class="keyword">else</span>
0151    opt.meshoptions.fineness = 6; <span class="comment">% some options have no effect without this</span>
0152    opt.options.curvaturesafety = 0.2;
0153    <span class="comment">% small yangle preserves the original mesh, large encourages smoother</span>
0154    <span class="comment">% surface with nicer spreading of refinement</span>
0155    opt.stloptions.yangle = 30; <span class="comment">% was 10</span>
0156  <span class="comment">%    opt.stloptions.contyangle = 20;</span>
0157    opt.stloptions.edgecornerangle = 0;
0158 <span class="comment">%    opt.stloptions.chartangle = 0;</span>
0159    opt.stloptions.outerchartangle = 120;
0160    opt.stloptions.resthchartdistenable = 1;
0161    opt.stloptions.resthchartdistfac = 2.0; <span class="comment">% encourages slower increase of element size</span>
0162    <span class="keyword">if</span> ~isempty(maxh)
0163       opt.options.meshsize = maxh;
0164    <span class="keyword">end</span>
0165    opt.meshoptions.laststep = <span class="string">'mv'</span>; <span class="comment">% don't need volume optimization</span>
0166    opt.options.optsteps2d =  5; <span class="comment">% but we can up surface optimization</span>
0167    opt.options.badellimit = 120; <span class="comment">% decrease the maximum allowed angle</span>
0168    <a href="../../eidors/meshing/netgen/ng_write_opt.html" class="code" title="function opt = ng_write_opt(varargin)">ng_write_opt</a>(opt);
0169 <span class="keyword">end</span>
0170 
0171 
0172 <span class="comment">% Extract a nice surface model from the one given</span>
0173 <a name="_sub5" href="#_subfunctions" class="code">function mdl = prepare_surf_model(mdl)</a>
0174 <span class="keyword">try</span> mdl = rmfield(mdl,<span class="string">'boundary'</span>);  <span class="keyword">end</span>
0175 mdl = <a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>(mdl);
0176 mdl = <a href="#_sub6" class="code" title="subfunction mdl = orient_boundary(mdl)">orient_boundary</a>(mdl);
0177 mdl.elems = mdl.boundary;
0178 mdl.faces = mdl.boundary;
0179 mdl.face_centre = mdl.face_centre(mdl.boundary_face,:);
0180 mdl.normals = mdl.normals(mdl.boundary_face,:);
0181 mdl = rmfield(mdl, <span class="string">'inner_normal'</span>);
0182 mdl = rmfield(mdl, <span class="string">'boundary_face'</span>);
0183 idx = nchoosek(1:3, 2);
0184 elem_sorted = sort(mdl.elems,2);
0185 [mdl.edges ib ia] = unique(reshape(elem_sorted(:,idx),[],2),<span class="string">'rows'</span>);
0186 D = mdl.nodes(mdl.edges(:,1),:) - mdl.nodes(mdl.edges(:,2),:);
0187 mdl.edge_len = sqrt(sum(D.^2,2)); 
0188 
0189 <a name="_sub6" href="#_subfunctions" class="code">function mdl = orient_boundary(mdl)</a>
0190 <span class="comment">% consistently orient boundary elements</span>
0191 flip = mdl.elem2face(logical(mdl.boundary_face(mdl.elem2face).*mdl.inner_normal));
0192 mdl.faces(flip,:) = mdl.faces(flip,[1 3 2]);
0193 mdl.normals(flip,:) = -mdl.normals(flip,:);
0194 mdl.boundary = mdl.faces(mdl.boundary_face,:);
0195 
0196 
0197 <a name="_sub7" href="#_subfunctions" class="code">function mdl = flatten_electrode(mdl,inner,outer, V)</a>
0198 n1 = <a href="#_sub8" class="code" title="subfunction match = find_matching_nodes(mdl, nodes,th)">find_matching_nodes</a>(mdl,inner, 1e-2);
0199 n2 = <a href="#_sub8" class="code" title="subfunction match = find_matching_nodes(mdl, nodes,th)">find_matching_nodes</a>(mdl,outer, 1e-5);
0200 <span class="comment">% remove the side nodes of the electrode</span>
0201 N1 = false(length(mdl.nodes),1);
0202 N1(n1) = true;
0203 N2 = false(length(mdl.nodes),1);
0204 N2(n2) = true;
0205 rm = sum(N1(mdl.elems),2)&gt;0 &amp; sum(N2(mdl.elems),2)&gt;0;
0206 
0207 f = find(sum(N2(mdl.elems),2)&gt;1 &amp; ~rm,1,<span class="string">'first'</span>);
0208 B = find(mdl.boundary_face);
0209 p = mdl.face_centre(B(f),:);
0210 r = Inf;
0211 mdl.elems(rm,:) = [];
0212 mdl.boundary = mdl.elems;
0213 mdl.boundary_face(B(rm)) = [];
0214 mdl.face_centre(B(rm),:) = [];
0215 mdl.normals(B(rm),:)     = [];
0216 mdl.faces(B(rm),:)       = [];
0217 f = f - nnz(rm(1:f));
0218 N = <a href="#_sub14" class="code" title="subfunction [out, fc] = grow_neighbourhood(mdl, varargin)">grow_neighbourhood</a>(mdl,f,p,r);
0219 
0220 <span class="comment">% WARNING: Here we assume the sides of the electrode are one element high!</span>
0221 
0222 <span class="comment">%nodes to move</span>
0223 ntm = unique(mdl.elems(N,:));
0224 mdl.nodes(ntm,:) = mdl.nodes(ntm,:) - repmat(V,length(ntm),1);
0225 e_nodes = ntm;
0226 
0227 <span class="comment">%remap outer nodes to inner ones</span>
0228 map = 1:length(mdl.nodes);
0229 map(n2) = n1;
0230 mdl.elems = map(mdl.elems);
0231 mdl.faces = map(mdl.faces);
0232 e_nodes = map(ntm);
0233 
0234 <span class="comment">% remove the outer nodes</span>
0235 m = true(length(mdl.nodes),1);
0236 m(n2) = false;
0237 map = zeros(size(m));
0238 map(m) = 1:nnz(m);
0239 
0240 mdl.nodes(n2,:) = [];
0241 mdl.elems = map(mdl.elems);
0242 mdl.faces = map(mdl.faces);
0243 e_nodes = map(e_nodes);
0244 
0245 mdl.boundary = mdl.elems;
0246 <span class="keyword">if</span> ~isfield(mdl,<span class="string">'electrode'</span>)
0247    mdl.electrode = struct();
0248    l = 1;
0249 <span class="keyword">else</span>
0250    l = length(mdl.electrode);
0251    <span class="comment">% because we are changing the number of nodes, we need to correct the</span>
0252    <span class="comment">% electrodes that are there already</span>
0253    <span class="keyword">for</span> i = 1:l
0254       mdl.electrode(i).nodes = map(mdl.electrode(i).nodes);
0255    <span class="keyword">end</span>
0256    l = l + 1;
0257 <span class="keyword">end</span>
0258 mdl.electrode(l).nodes = double(e_nodes);
0259 mdl.electrode(l).z_contact = 0.01;
0260 
0261 <span class="keyword">if</span> do_debug
0262    <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(mdl);
0263 <span class="keyword">end</span>
0264 
0265 
0266 <a name="_sub8" href="#_subfunctions" class="code">function match = find_matching_nodes(mdl, nodes,th)</a>
0267 l0 = length(mdl.nodes);
0268 match = 0 * (1:length(nodes));
0269 <span class="keyword">for</span> n = 1:length(nodes)
0270    D = mdl.nodes - repmat(nodes(n,:),l0,1);
0271    D = sqrt(sum(D.^2,2));
0272    [val p] = min(D);
0273    <span class="keyword">if</span> val &lt; th
0274       match(n) = p;
0275    <span class="keyword">end</span>
0276 <span class="keyword">end</span>
0277 
0278 <span class="comment">% Returns a joint surface mesh and the list of nodes on the side of the</span>
0279 <span class="comment">% electrode</span>
0280 <a name="_sub9" href="#_subfunctions" class="code">function [joint EL1 EL2 V] = add_electrodes(mdl,N,fc,elecs)</a>
0281 
0282 
0283 <span class="comment">% fc = find_face_under_elec(mdl,elecs.pos);</span>
0284 <span class="comment">% N indexes the boundary, need index into faces</span>
0285 <span class="comment">% fcs = find(mdl.boundary_face);</span>
0286 <span class="comment">% fcs = fcs(N);</span>
0287 fcs = N;
0288 used_nodes = unique(mdl.faces(fcs,:));
0289 node_map = zeros(1,size(mdl.nodes,1));
0290 node_map(used_nodes) = 1:numel(used_nodes);
0291 
0292 jnk.type = <span class="string">'fwd_model'</span>;
0293 jnk.elems = node_map(mdl.boundary(N,:));
0294 jnk.nodes = mdl.nodes(used_nodes,:);
0295 jnk.boundary = jnk.elems;
0296 <span class="keyword">if</span> do_debug
0297    <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(jnk);
0298    hold on
0299    plot3(elecs.points(:,1),elecs.points(:,2),elecs.points(:,3),<span class="string">'ro'</span>);
0300    <span class="comment">% plot3(mdl.nodes(nn(outer),1), mdl.nodes(nn(outer),2), mdl.nodes(nn(outer),3),'bs')</span>
0301    hold off
0302 <span class="keyword">end</span>
0303 
0304 flat = <a href="../../eidors/graphics/matlab/level_model_slice.html" class="code" title="function [out, out2, out3] = level_model_slice(varargin)">level_model_slice</a>(jnk,struct(<span class="string">'centre'</span>,mdl.face_centre(fc,:),<span class="string">'normal'</span>,mdl.normals(fc,:)));
0305 elec_pts = <a href="../../eidors/graphics/matlab/level_model_slice.html" class="code" title="function [out, out2, out3] = level_model_slice(varargin)">level_model_slice</a>(elecs.points,struct(<span class="string">'centre'</span>,mdl.face_centre(fc,:),<span class="string">'normal'</span>,mdl.normals(fc,:)));
0306 elec_nodes = <a href="../../eidors/graphics/matlab/level_model_slice.html" class="code" title="function [out, out2, out3] = level_model_slice(varargin)">level_model_slice</a>(elecs.nodes,struct(<span class="string">'centre'</span>,mdl.face_centre(fc,:),<span class="string">'normal'</span>,mdl.normals(fc,:)));
0307 <span class="comment">% now, the points are almost z = 0, so we can work in 2D</span>
0308 warning off <span class="string">'MATLAB:triangulation:PtsNotInTriWarnId'</span>
0309 TR = triangulation(double(flat.elems), flat.nodes(:,1:2));
0310 warning on <span class="string">'MATLAB:triangulation:PtsNotInTriWarnId'</span>
0311 
0312 edges = TR.freeBoundary;
0313 
0314 <span class="comment">% project all nodes of the faces in N onto the plane of the electrode</span>
0315 PN = flat.nodes(:,1:2);
0316 
0317 <span class="comment">% for every electrode point, find closest node</span>
0318 neighbour = TR.nearestNeighbor(elec_pts(:,1:2));
0319 D = sqrt(sum((flat.nodes(neighbour,1:2) - elec_pts(:,1:2)).^2,2));
0320 rm = unique(neighbour(D &lt; 2 * elecs.maxh));
0321 
0322 <span class="comment">% we can only delete if it's not part of the boundary</span>
0323 b = unique(edges(:));
0324 rm(ismember(rm,b)) = [];
0325 
0326 <span class="comment">% remove and remap</span>
0327 PN(rm,:) = [];
0328 used_nodes(rm) = [];
0329 
0330 n = size(flat.nodes,1);
0331 nodelist = 1:n;
0332 nodelist(rm) = [];
0333 map = zeros(n,1);
0334 map(nodelist) = 1:numel(nodelist);
0335 edges = map(edges); 
0336 
0337 points = [PN; elec_pts(:,1:2)];
0338 
0339 <span class="comment">% constrained Delaunay triangulation in 2D</span>
0340 f = length(PN) + (1:2);
0341 C = bsxfun(@plus, (0:length(elecs.points)-2)', f);
0342 [wtxt, wid] = lastwarn;
0343 lastwarn(<span class="string">''</span>,<span class="string">''</span>);
0344 warning off <span class="string">'MATLAB:DelaunayTri:ConsConsSplitWarnId'</span>;
0345 D = DelaunayTri(points,[edges; C]);
0346 els = D.Triangulation(D.inOutStatus,:);
0347 [txt, id] = lastwarn;
0348 <span class="keyword">if</span> strcmp(id,<span class="string">'MATLAB:DelaunayTri:ConsConsSplitWarnId'</span>)
0349     <span class="keyword">if</span> do_debug
0350         keyboard
0351     <span class="keyword">else</span>
0352         error(txt); <span class="comment">% no point continuing</span>
0353     <span class="keyword">end</span>
0354 <span class="keyword">else</span>
0355     lastwarn(wtxt,wid); <span class="comment">% restore</span>
0356 <span class="keyword">end</span>
0357 warning on <span class="string">'MATLAB:DelaunayTri:ConsConsSplitWarnId'</span>;
0358 <span class="comment">% project all electrode points on the faces below them, using the normal of</span>
0359 <span class="comment">% the central face</span>
0360 Ne = mdl.normals(fc,:);
0361 FN = TR.pointLocation(elec_nodes(:,1:2)); <span class="comment">% face num under each electrode point</span>
0362 FC = fcs(FN); <span class="comment">% same, in original numbering</span>
0363 <span class="keyword">for</span> j = 1:length(elecs.nodes)
0364    Pe = elecs.nodes(j,:);
0365    Nf = mdl.normals(fcs(FN(j)),:);
0366    Cf = mdl.face_centre(fcs(FN(j)),:);
0367    Proj(j,:) = Pe + Ne * dot(Cf-Pe,Nf) / dot(Ne,Nf) ;
0368 <span class="keyword">end</span>
0369 
0370 
0371 <span class="comment">% this is just output</span>
0372 EL1 = Proj(1:length(elecs.points),:);
0373 
0374 <span class="comment">% remove any nodes inside the electrode</span>
0375 ln = length(used_nodes);
0376 <span class="comment">% IN = inpolygon(x(1:ln),y(1:ln),x(ln+1:end),y(ln+1:end));</span>
0377 <span class="comment">% nodes(IN) = [];</span>
0378 
0379 add = elecs.maxh;
0380 
0381 nn = mdl.nodes(used_nodes,:);<span class="comment">% + add * repmat(IN,1,3) .* repmat(Ne,ln,1);</span>
0382 le = length(elecs.nodes);
0383 ne = Proj + add * repmat(Ne,le,1);
0384 
0385 <span class="comment">%this is just output</span>
0386 EL2 = ne(1:length(elecs.points),:);
0387 V = add*Ne;
0388 
0389 <span class="comment">% the nodes of the electrode</span>
0390 <span class="comment">% IN = [IN; ones(le,1)];</span>
0391 el_c = D.incenters;
0392 el_c(~D.inOutStatus,:) = [];
0393 e_el = inpolygon(el_c(:,1),el_c(:,2),points(ln+1:<span class="keyword">end</span>,1),points(ln+1:<span class="keyword">end</span>,2));
0394 els(e_el,:) = []; <span class="comment">% els(e_el,:) + (els(e_el,:)&gt;ln ) .* le;</span>
0395 
0396 <span class="comment">% add connecting elements</span>
0397 E = [];
0398 le = length(elecs.points);
0399 f = ln + [ 1 le+1 le+2; le+2 2 1];
0400 <span class="keyword">for</span> j = 0:(le-2)
0401    E = [E; j+f];
0402 <span class="keyword">end</span>
0403 M = ln + [le+1 le 2*le; le le+1 1];
0404 E = [E; M];
0405 
0406 jnk.nodes = [nn ; Proj(1:le,:);  ne];
0407 jnk.elems = [ els; E; elecs.elems+ln+le];
0408 jnk.boundary = jnk.elems;
0409 <span class="keyword">if</span> do_debug
0410    <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(jnk);
0411 <span class="keyword">end</span>
0412 
0413 <span class="comment">% remove the patch we're replacing</span>
0414 big = mdl;
0415 big.boundary(N,:) = [];
0416 big.faces(N,:) = [];
0417 big.normals(N,:) = [];
0418 big.face_centre(N,:) = [];
0419 
0420 big.elems = big.boundary;
0421 
0422 joint = <a href="merge_meshes.html" class="code" title="function out = merge_meshes(M1,varargin)">merge_meshes</a>(big,jnk,0.001);
0423 joint.boundary = joint.elems;
0424 joint.faces = joint.boundary;
0425 opt.normals = true;
0426 opt.face_centre = true;
0427 joint = <a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>(joint,opt);
0428 
0429 
0430 <a name="_sub10" href="#_subfunctions" class="code">function PN = project_nodes_on_elec(mdl,elecs,nodes)</a>
0431 fc = <a href="#_sub16" class="code" title="subfunction [e p] = find_face_under_elec(mdl, elec_pos)">find_face_under_elec</a>(mdl,elecs.pos);
0432 Ne = mdl.normals(fc,:);
0433 Pe = elecs.pos;
0434 <span class="comment">% for i = 1:length(nodes)</span>
0435 <span class="comment">%    P = mdl.nodes(nodes(i),:);</span>
0436 <span class="comment">%    PN(i,:) = P + dot(Pe - P, Ne) * Ne;</span>
0437 <span class="comment">% end</span>
0438 N = mdl.nodes(nodes,:);
0439 <span class="comment">% PN = N + sum((Pe-N) .* Ne,2) .* Ne;</span>
0440 PN = N + bsxfun(@times,sum(bsxfun(@times,bsxfun(@minus,Pe,N), Ne),2), Ne);
0441 
0442 
0443 
0444 <span class="comment">% OUTPUT:</span>
0445 <span class="comment">%  elecs(i).pos   = [x,y,z]</span>
0446 <span class="comment">%  elecs(i).shape = 'C' or 'R'</span>
0447 <span class="comment">%  elecs(i).dims  = [radius] or [width,height]</span>
0448 <span class="comment">%  elecs(i).maxh  = '-maxh=#' or '';</span>
0449 <span class="comment">%  elecs(i).points= list of points around the perimeter</span>
0450 <span class="comment">% Angles (th) are interpreted with the mean of boundary nodes as origin</span>
0451 <a name="_sub11" href="#_subfunctions" class="code">function [elecs] = parse_elecs(mdl, elec_pos, elec_shape )</a>
0452 elecs = [];
0453 
0454 <span class="keyword">if</span> size(elec_shape,2) &lt; 3
0455    elec_shape(:,3) = elec_shape(:,1)/10;
0456 <span class="keyword">end</span>
0457 
0458 have_xyz = 0;
0459 
0460 <span class="keyword">if</span> size(elec_pos,1) == 1
0461    <span class="comment">% Parse elec_pos = [n_elecs_per_plane,(0=equal angles,1=equal dist),z_planes]</span>
0462    n_elecs= elec_pos(1); <span class="comment">% per plane</span>
0463    offset = elec_pos(2) - floor(elec_pos(2));
0464    <span class="keyword">switch</span> floor(elec_pos(2))
0465       <span class="keyword">case</span> 0
0466          th = linspace(0,2*pi, n_elecs+1)'; th(end)=[];
0467          th = th + offset*2*pi;
0468          ind = th &gt;= 2*pi;
0469          th(ind) = th(ind) - 2*pi;
0470       <span class="keyword">case</span> 1
0471          error(<span class="string">'not implemented yet'</span>);
0472    <span class="keyword">end</span>
0473    on_elecs = ones(n_elecs, 1);
0474    el_th = [];
0475    el_z  = [];
0476    <span class="keyword">for</span> i=3:length(elec_pos)
0477       el_th = [el_th; th];
0478       el_z  = [el_z ; on_elecs*elec_pos(i)];
0479    <span class="keyword">end</span>
0480 <span class="keyword">elseif</span> size(elec_pos,2) == 2
0481    <span class="comment">% elec_pos = [theta z];</span>
0482    el_th = elec_pos(:,1)*2*pi/360;
0483    el_z  = elec_pos(:,2);
0484 <span class="keyword">elseif</span> size(elec_pos,2) == 3
0485    <span class="comment">% elec_pos = [x y z];</span>
0486    have_xyz = 1;
0487    el_z  = elec_pos(:,3);
0488 <span class="keyword">end</span>
0489 
0490 <span class="keyword">if</span> ~have_xyz
0491    el_th(el_th&gt;pi) =  el_th(el_th&gt;pi) - 2*pi;
0492    el_th(el_th&lt;-pi) = el_th(el_th&lt;-pi) + 2*pi;
0493 <span class="keyword">end</span>
0494 n_elecs= size(el_z,1);
0495 
0496 <span class="keyword">if</span> size(elec_shape,1) == 1
0497    elec_shape = ones(n_elecs,1) * elec_shape;
0498 <span class="keyword">end</span>
0499 
0500 <span class="keyword">for</span> i = 1:n_elecs
0501    <span class="keyword">if</span> ~have_xyz
0502       [fc elecs(i).pos] = <a href="#_sub13" class="code" title="subfunction [fc pos] = find_elec_centre(mdl, el_th,el_z)">find_elec_centre</a>(mdl,el_th(i),el_z(i));
0503    <span class="keyword">else</span>
0504       elecs(i).pos = elec_pos(i,:);
0505    <span class="keyword">end</span>
0506 <span class="comment">%    elecs(i).face = fc; % this changes too often to store!</span>
0507    elecs(i).dims = elec_shape(i,1:2);
0508    elecs(i).dims(elecs(i).dims==0) = [];
0509    elecs(i).maxh = elec_shape(i,3);
0510    
0511    <span class="keyword">if</span> elec_shape(i,2) == 0
0512       elecs(i).shape = <span class="string">'C'</span>;
0513       r = elec_shape(i,1);
0514       n = ceil(2*pi*elec_shape(i,1) / elec_shape(i,3));
0515       t = linspace(0,2*pi,n+1); t(end) = [];
0516       x = r*sin(t); y = r*cos(t);
0517    <span class="keyword">else</span>
0518       elecs(i).shape = <span class="string">'R'</span>;
0519       height = elec_shape(i,1); width = elec_shape(i,2); d_org = elec_shape(i,3);
0520       <span class="comment">% enforce a minimum of 5 nodes per side</span>
0521       d = min( [ d_org , height/5, width/5]);
0522       <span class="keyword">if</span> d &lt; d_org
0523          elecs(i).maxh = d;
0524          <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ Decreased maxh of electrode %d from %f to %f'</span>,i,d_org, d,2);
0525       <span class="keyword">end</span>
0526       nh = ceil(height/d)+1; nw = ceil(width/d)+1; 
0527       ph = linspace(-height/2,height/2,nh);
0528       pw = linspace(-width/2,width/2,nw);
0529       y = [ph, ph(end)*ones(1,nw-2), fliplr(ph), ph(1)*ones(1,nw-2)];
0530       x = [pw(1)*ones(1,nh-1), pw, pw(end)*ones(1,nh-2), fliplr(pw(2:end))];
0531       <span class="comment">%    % we don't want real rectangles, because Netgen will merge coplanar</span>
0532       <span class="comment">%    % faces, so we create a nice superellipse instead</span>
0533       n = 2*(nh+nw);
0534       <span class="comment">%    t = linspace(2*pi,0,n); t(end) = [];</span>
0535       <span class="comment">%    N = 8;</span>
0536       <span class="comment">%    x = abs(cos(t)).^(2/N) * width/2  .* sign(cos(t));</span>
0537       <span class="comment">%    y = abs(sin(t)).^(2/N) * height/2 .* sign(sin(t));</span>
0538       <span class="comment">% superellipses are also bad, what about a wavy rectange?</span>
0539 <span class="comment">%       [pp] = fourier_fit([x; y]', min(size(x,2),18) );</span>
0540 <span class="comment">%       t = linspace(0,1,n+1); t(end) = [];</span>
0541 <span class="comment">%       xy = fourier_fit(pp,t);</span>
0542 <span class="comment">%       x = xy(:,1)'; y = xy(:,2)';</span>
0543       <span class="comment">% wavy rectangles are nice but don't guarantee absence of co-planar</span>
0544       <span class="comment">% faces</span>
0545       <span class="comment">% let's try a brute-force approach</span>
0546       e = tand(0.5)*d;
0547       x = x + e* [0 power(-1,0:nh-3) zeros(1,nw)  power(-1,0:nh-3) zeros(1,nw-1)];
0548       y = y + e* [zeros(1,nh) power(-1,0:nw-3) zeros(1,nh) power(-1,0:nw-3)];
0549    <span class="keyword">end</span>
0550    fc = <a href="#_sub16" class="code" title="subfunction [e p] = find_face_under_elec(mdl, elec_pos)">find_face_under_elec</a>(mdl,elecs(i).pos);
0551    [u v s] = <a href="#_sub12" class="code" title="subfunction [u v s] = get_face_basis(mdl, fc)">get_face_basis</a>(mdl, fc);
0552    
0553    np = length(x);
0554 <span class="comment">%    elecs(i).points = flipud(ones(size(x))' * elecs(i).pos + x'*s + y'*v);</span>
0555 
0556    <a href="../../eidors/meshing/netgen/ng_write_opt.html" class="code" title="function opt = ng_write_opt(varargin)">ng_write_opt</a>(<span class="string">'meshoptions.fineness'</span>,1,<span class="string">'options.meshsize'</span>,1.2*elecs(i).maxh);
0557    emdl = <a href="../../eidors/meshing/netgen/ng_mk_2d_model.html" class="code" title="function mdl = ng_mk_2d_model(varargin)">ng_mk_2d_model</a>(flipud([x', y']));
0558    x = emdl.nodes(:,1); y = emdl.nodes(:,2);
0559    elecs(i).nodes = ones(size(x)) * elecs(i).pos + x*s + y*v;
0560    elecs(i).elems = emdl.elems(:,[1 3 2]); <span class="comment">% flip orientation to the outside</span>
0561    elecs(i).points = elecs(i).nodes(1:np,:); <span class="comment">% this must be the boundary</span>
0562    <span class="comment">% TODO: write code to check if this is true</span>
0563    
0564 <span class="keyword">end</span>
0565 delete(<span class="string">'ng.opt'</span>);
0566 
0567 <a name="_sub12" href="#_subfunctions" class="code">function [u v s] = get_face_basis(mdl, fc)</a>
0568    u = mdl.normals(fc,:); <span class="comment">% unit normal</span>
0569 
0570    <span class="comment">% project each coordinate axis on the plane</span>
0571    I = eye(3);
0572    <span class="keyword">for</span> i = 1:3
0573        proj(:,i) = I(:,i) - (dot(I(:,i),u')) * u';
0574    <span class="keyword">end</span>
0575    norm_proj = <a href="../../eidors/overloads/vecnorm/vecnorm.html" class="code" title="function out = vecnorm(x, p, dim)">vecnorm</a>(proj);
0576    min_norm = min(norm_proj);
0577    
0578    <span class="comment">% vertical vector on the plane of that surface triangle</span>
0579    <span class="keyword">if</span> norm_proj(3) ~= min_norm
0580       v = [0 0 1] - dot([0 0 1],u) *u;
0581    <span class="keyword">else</span>
0582       <span class="comment">% the element is essentially horizontal</span>
0583 <span class="comment">%       v = [0 1 0] - dot([0 1 0],u)*u;</span>
0584 <span class="comment">%TODO: need to expose an option to decide which it should be</span>
0585       v = [1 0 0] - dot([1 0 0],u)*u;
0586    <span class="keyword">end</span>
0587    v = v/norm(v);
0588    s = cross(u,v); s= s/norm(s);
0589 
0590 <a name="_sub13" href="#_subfunctions" class="code">function [fc pos] = find_elec_centre(mdl, el_th,el_z)</a>
0591 fc = [];
0592 pos = [];
0593 
0594 Ctr = mean(mdl.nodes(mdl.boundary,:));
0595 Ctr(3) = el_z;
0596 
0597 <span class="comment">%1. Find edges that cross the z plane</span>
0598 n_above = mdl.nodes(:,3) &gt;= el_z;
0599 sum_above = sum(n_above(mdl.edges),2) ;
0600 edg = sum_above == 1;
0601 
0602 <span class="comment">%2. Find an edge that crosses el_th</span>
0603 n = unique(mdl.edges(edg,:));
0604 nn = mdl.nodes(n,1:2);
0605 nn = nn - repmat(Ctr(:,1:2),length(nn),1);
0606 th = cart2pol(nn(:,1),nn(:,2));
0607 th(:,2) = 1:length(th);
0608 th = sortrows(th);
0609 idx = find(th(:,1) &gt; el_th,1,<span class="string">'first'</span>);
0610 <span class="keyword">if</span> isempty(idx) || idx == 1
0611    n1 = n(th(1,2));
0612    n2 = n(th(<span class="keyword">end</span>,2));
0613    <span class="comment">% edges in edg that contain these nodes (they don't need to be on the</span>
0614    <span class="comment">% same element)</span>
0615    ed = edg &amp; sum( (mdl.edges == n1) + (mdl.edges == n2) ,2) &gt; 0;
0616 <span class="keyword">else</span>
0617 <span class="comment">%    to_the_left = false(length(mdl.nodes),1);</span>
0618 <span class="comment">%    to_the_left(n(th(1:idx-1,2))) = true;</span>
0619 <span class="comment">%    sum_left = sum( to_the_left(mdl.boundary), 2);</span>
0620 <span class="comment">%    el = els &amp; sum_left &gt; 0 &amp; sum_left &lt; 3;</span>
0621    n1 = n(th(idx-1,2));
0622    n2 = n(th(idx,  2));
0623    ed = edg &amp; sum( (mdl.edges == n1) + (mdl.edges == n2) ,2) &gt; 0;
0624 <span class="keyword">end</span>
0625 
0626 el = false(length(mdl.boundary),1);
0627 <span class="keyword">for</span> i = find(ed)'
0628    n1 = mdl.edges(i,1);
0629    n2 = mdl.edges(i,2);
0630    el = el | sum( (mdl.boundary == n1) + (mdl.boundary == n2), 2) == 2;
0631 <span class="keyword">end</span>
0632 el = find(el);
0633 <span class="comment">% fcs = find(mdl.boundary_face);</span>
0634 <span class="comment">% fcs = fcs(el);</span>
0635 
0636 [De(1) De(2) De(3)]  = pol2cart(el_th,1, 0); 
0637 <span class="keyword">for</span> i = 1:length(el)
0638    Nf = mdl.normals(el(i),:);
0639    Cf = mdl.face_centre(el(i),:);
0640    <span class="comment">% the plane is (X - Cf).Nf = 0</span>
0641    <span class="comment">% the line is X = Ctr + tDe (through Ctr along De</span>
0642    <span class="comment">% We want X that satisfies both.</span>
0643    <span class="comment">% (Ctr +tDe -  Cf).Nf = 0</span>
0644    <span class="comment">% (Ctr - Cf).Nf + tDe.Nf = 0</span>
0645    <span class="comment">% t =</span>
0646    <span class="comment">% X = Ctr + De * (Cf-Ctr).Nf / (De.Nf)</span>
0647    t = dot(Cf-Ctr,Nf) / dot(De,Nf);
0648    <span class="keyword">if</span> t &lt; 0, <span class="keyword">continue</span>, <span class="keyword">end</span>
0649    X = Ctr + De * t ;
0650    <span class="keyword">if</span> <a href="point_in_triangle.html" class="code" title="function out = point_in_triangle(P,E,V,epsilon, str)">point_in_triangle</a>(X, mdl.faces(el(i),:), mdl.nodes)
0651       pos = X;
0652       fc = el(i);
0653       <span class="keyword">break</span>;
0654    <span class="keyword">end</span>
0655    
0656    <span class="comment">% project the line on this element</span>
0657    <span class="comment">% check if it falls inside</span>
0658 <span class="keyword">end</span>
0659 <span class="keyword">if</span> isempty(pos)
0660    keyboard
0661 <span class="keyword">end</span>
0662 
0663 <a name="_sub14" href="#_subfunctions" class="code">function [out, fc] = grow_neighbourhood(mdl, varargin)</a>
0664 use_elec = false;
0665 <span class="keyword">if</span> length(varargin) == 1
0666    use_elec = true;
0667    elecs = varargin{1};
0668    fc = <a href="#_sub16" class="code" title="subfunction [e p] = find_face_under_elec(mdl, elec_pos)">find_face_under_elec</a>(mdl,elecs.pos);
0669    p = elecs.pos;
0670    <span class="keyword">switch</span> elecs.shape
0671       <span class="keyword">case</span> <span class="string">'R'</span>
0672          r = sqrt(sum(elecs.dims.^2,2));
0673       <span class="keyword">case</span> <span class="string">'C'</span>
0674          r = 2 * elecs.dims(1);
0675    <span class="keyword">end</span>
0676 <span class="keyword">else</span>
0677    fc = varargin{1};
0678    p = varargin{2};
0679    r = varargin{3};
0680 <span class="keyword">end</span>
0681 
0682 done = false(length(mdl.boundary),1);
0683 todo = false(length(mdl.boundary),1);
0684 todo(fc) = true;
0685 bb = mdl.boundary;
0686 vv = mdl.nodes;
0687 <span class="comment">% distance of each vertex to the line perpendicular to face fc passing</span>
0688 <span class="comment">% through p</span>
0689 dv = vv - repmat(p,length(vv),1);
0690 nl = mdl.normals;
0691 nl = repmat(nl(fc,:),length(vv),1);
0692 dd = sqrt(sum( (dv - repmat(dot(dv,nl,2),1,3) .* nl).^2,2));
0693 dim = size(bb,2);
0694 first = true; <span class="comment">% at first iteration, add all neighbours</span>
0695 <span class="keyword">if</span> use_elec
0696    PN = <a href="../../eidors/graphics/matlab/level_model_slice.html" class="code" title="function [out, out2, out3] = level_model_slice(varargin)">level_model_slice</a>(mdl.nodes,struct(<span class="string">'centre'</span>,mdl.face_centre(fc,:),<span class="string">'normal'</span>,mdl.normals(fc,:)));
0697    elec_pts = <a href="../../eidors/graphics/matlab/level_model_slice.html" class="code" title="function [out, out2, out3] = level_model_slice(varargin)">level_model_slice</a>(elecs.points,struct(<span class="string">'centre'</span>,mdl.face_centre(fc,:),<span class="string">'normal'</span>,mdl.normals(fc,:)));
0698    elec_pts = elec_pts(:,1:2);
0699    PN = PN(:,1:2);
0700    emin = min(elec_pts);
0701    emax = max(elec_pts);
0702    rng = emax-emin;
0703    emin = emin - 0.1*rng;
0704    emax = emax + 0.1*rng;
0705    toofar = false(size(mdl.boundary,1),1);
0706    
0707    <span class="keyword">for</span> i = 1:2
0708       nodes = reshape(PN(mdl.boundary,i),[],3);
0709       toofar =  toofar |  sum(nodes &gt; emax(i),2) == 3 | sum(nodes &lt; emin(i),2) == 3;
0710    <span class="keyword">end</span>
0711 <span class="keyword">end</span>
0712 <span class="keyword">while</span> any(todo)
0713    id = find(todo,1,<span class="string">'first'</span>);
0714    done(id) = 1;
0715    nn = <a href="#_sub15" class="code" title="subfunction nn =  find_neighbours(fc, bb);">find_neighbours</a>(id,bb);
0716    <span class="keyword">if</span> use_elec
0717       nn = nn &amp; ~toofar;
0718    <span class="keyword">elseif</span> first
0719       <span class="comment">% include all neighbours</span>
0720       first = false;
0721    <span class="keyword">else</span>
0722       <span class="comment">% at least one node must be close enough</span>
0723       nn = nn &amp; sum(dd(bb) &lt;= r,2) &gt; 0;
0724    <span class="keyword">end</span>
0725    todo = todo | nn;
0726    todo(done) = 0;
0727 <span class="comment">%    disp(sprintf('id: %d done: %d todo: %d',id, nnz(done),nnz(todo)));</span>
0728 <span class="comment">%    disp(find(todo)');</span>
0729 <span class="comment">%    disp(find(done)');</span>
0730 <span class="keyword">end</span>
0731 out = find(done);
0732 
0733 
0734 <a name="_sub15" href="#_subfunctions" class="code">function nn =  find_neighbours(fc, bb);</a>
0735 dim = size(bb,2);
0736 nn = false(length(bb),1);
0737 <span class="keyword">for</span> i = 1:dim
0738    node = bb(fc,i);
0739    nn = nn | sum(bb == node,2) &gt; 0;
0740 <span class="keyword">end</span>
0741 nn(fc) = 0;
0742 
0743 <a name="_sub16" href="#_subfunctions" class="code">function [e p] = find_face_under_elec(mdl, elec_pos)</a>
0744 <span class="keyword">for</span> i = 1:size(elec_pos,1)
0745    <span class="comment">% 1. Project electrode on all faces</span>
0746    ee = repmat(elec_pos(i,:),length(mdl.faces),1);
0747    fc = mdl.face_centre;
0748    n  = mdl.normals;
0749    proj1 = ee - repmat(dot(ee-fc, n,2),1,3) .* n;
0750    in1 = <a href="point_in_triangle.html" class="code" title="function out = point_in_triangle(P,E,V,epsilon, str)">point_in_triangle</a>(proj1,mdl.faces,mdl.nodes, <span class="string">'match'</span>);
0751    dis1 = sqrt(sum((ee-proj1).^2,2));
0752    <span class="comment">% 2. Project electrode on all edges</span>
0753    edg = [mdl.faces(:,1:2);mdl.faces(:,2:3);mdl.faces(:,[3 1])];
0754    edg = sort(edg,2);
0755    [edg jnk e2f] = unique(edg,<span class="string">'rows'</span>);
0756    ee = repmat(elec_pos(i,:),length(edg),1);
0757    s = mdl.nodes(edg(:,2),:) - mdl.nodes(edg(:,1),:); <span class="comment">%edge direction vector</span>
0758    t = dot(ee-mdl.nodes(edg(:,1),:),s,2)./dot(s,s,2);
0759    in2 = t&gt;=0 &amp; t &lt;=1;
0760    in2 = any(reshape(in2(e2f),[],3),2);
0761    proj2 = mdl.nodes(edg(:,1),:) + repmat(t,1,3).*s;
0762    dis = sqrt(sum((ee - proj2).^2,2));
0763    dis = repmat(dis,2,1);
0764    dis(t&lt;0 | t &gt; 1) = Inf;
0765    dis = reshape(dis(e2f),[],3);
0766    [jnk, pos] = min(dis,[],2);
0767    idx = <a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(1:length(pos),pos,1);
0768    dis = dis';
0769    dis2 = dis(logical(idx'));
0770 
0771    in = in1 | in2;
0772    <span class="keyword">if</span> nnz(in) == 1
0773          e(i) = find(in1);  <span class="comment">% this should be an index into mdl.boundary</span>
0774          p(i,:) = proj1(in1,:);
0775    <span class="keyword">else</span>
0776       <span class="comment">% take the element that is closest to ee</span>
0777       cand = find(in);
0778       dd(in1(cand)) = dis1(in1);
0779       dd(in2(cand)) = dis2(in2);
0780       [jnk pos] = min(dd);
0781       e(i) = cand(pos);
0782       p(i,:) = proj1(e(i),:);
0783    <span class="keyword">end</span>
0784 
0785 <span class="keyword">end</span>
0786 
0787 
0788 <a name="_sub17" href="#_subfunctions" class="code">function do_unit_test</a>
0789 xy= [ -0.89 -0.74 -0.21  0.31  0.79  0.96  0.67  0.05 -0.36 -0.97;
0790        0.14  0.51  0.35  0.50  0.27 -0.23 -0.86 -0.69 -0.85 -0.46]';
0791 [fmdl] = <a href="../../eidors/meshing/netgen/ng_mk_extruded_model.html" class="code" title="function [fmdl,mat_idx] = ng_mk_extruded_model(shape, elec_pos, elec_shape,extra_ng_code)">ng_mk_extruded_model</a>({2,xy,[4,80],},[],[]);
0792 elec_pos = [-0.5, -0.8, 1];
0793 <span class="comment">% place_elec_on_surf(fmdl, elec_pos, [0.1 0 0.01]);</span>
0794 <span class="comment">% place_elec_on_surf(fmdl, elec_pos, [0.15 0.1 0.01]);</span>
0795 mdl = <a href="place_elec_on_surf.html" class="code" title="function mdl2 = place_elec_on_surf(mdl,elec_pos, elec_spec,ng_opt_file, maxh)">place_elec_on_surf</a>(fmdl, [16 0 1], [0.15 0.1 0.01]);
0796 <span class="comment">% place_elec_on_surf(fmdl, [16 0 1], [0.1 0 0.01]);</span>
0797 subplot(121)
0798 <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(mdl);
0799 
0800 mdl = <a href="place_elec_on_surf.html" class="code" title="function mdl2 = place_elec_on_surf(mdl,elec_pos, elec_spec,ng_opt_file, maxh)">place_elec_on_surf</a>(fmdl, [16 0 1], [0.15 0.1 0.01],[],0.1);
0801 <span class="comment">% place_elec_on_surf(fmdl, [16 0 1], [0.1 0 0.01]);</span>
0802 subplot(122)
0803 <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(mdl);</pre></div>
<hr><address>Generated on Fri 30-Dec-2022 20:46:51 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>
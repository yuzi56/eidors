<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of mk_pixel_slice</title>
  <meta name="keywords" content="mk_pixel_slice">
  <meta name="description" content="MK_PIXEL_SLICE create a pixel model to reconstruct on">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">eidors</a> &gt; <a href="index.html">models</a> &gt; mk_pixel_slice.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/models&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>mk_pixel_slice
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>MK_PIXEL_SLICE create a pixel model to reconstruct on</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [imdl fmdl] = mk_pixel_slice(imdl,level,opt) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">MK_PIXEL_SLICE create a pixel model to reconstruct on
 OUT = MK_PIXEL_SLICE(MDL, LEVEL, OPT) creates a slice of pixels as a
 model to reconstruct on. 

 Inputs:
  MDL   = an EIDORS forward or inverse model structure
  LEVEL = any definition accepted by LEVEL_MODEL_SLICE for a single slice
  OPT   = an option structure with the following fields and defaults:
     opt.imgsz = [32 32];    % dimensions of the pixel grid
     opt.square_pixels = 0;  % adjust imgsz to get square pixels
     opt.do_coarse2fine = 1; % calcuate c2f on the forward model
     opt.z_depth = inf;      % z_depth to use with mk_coarse_fine_mapping

 Output depends on the type of model suplied. If MDL is a fwd_model
 structure then OUT is a rec_model. If MDL is an inv_model, then OUT is a
 modified version of it, with the pixel slice in inv_model.rec_model and
 updated inv_model.fwd_model.coarse2fine
 
 [OUT FMDL] = MK_PIXEL_SLICE(MDL, ...) also returns the forward model
 structure with the coarse2fine field.

 See also <a href="mk_coarse_fine_mapping.html" class="code" title="function [mapping, outside] = mk_coarse_fine_mapping(varargin)">MK_COARSE_FINE_MAPPING</a>, <a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">MK_GRID_MODEL</a>, LEVEL_MODEL_SLICE</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../eidors/graphics/matlab/calc_slices.html" class="code" title="function rimg = calc_slices( img, levels );">calc_slices</a>	calc_slices (img, levels, clim  ) show slices at levels of an</li><li><a href="../../eidors/graphics/matlab/level_model_slice.html" class="code" title="function [out, out2, out3] = level_model_slice(varargin)">level_model_slice</a>	LEVEL_MODEL_SLICE - level 3D points for slicing at z=0</li><li><a href="../../eidors/graphics/matlab/mdl_slice_mesher.html" class="code" title="function [nimg out] = mdl_slice_mesher(fmdl,level,varargin)">mdl_slice_mesher</a>	MDL_SLICE_MESHER A slice of a 3D FEM as a 2D FEM</li><li><a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>	SHOW_FEM: show the EIDORS3D finite element model</li><li><a href="../../eidors/graphics/matlab/show_slices.html" class="code" title="function out_img= show_slices( img, levels, vh )">show_slices</a>	out_img = show_slices (img, levels ) show slices at levels of an</li><li><a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>	MK_GRID_MODEL: Create reconstruction model on pixelated grid</li><li><a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>	MK_IMAGE: create eidors image object</li><li><a href="mk_library_model.html" class="code" title="function out = mk_library_model(shape,elec_pos,elec_shape,maxsz,nfft,scale)">mk_library_model</a>	MK_LIBRARY_MODEL - FEM models based on library shapes</li><li><a href="mk_pixel_slice.html" class="code" title="function [imdl fmdl] = mk_pixel_slice(imdl,level,opt)">mk_pixel_slice</a>	MK_PIXEL_SLICE create a pixel model to reconstruct on</li><li><a href="point_in_triangle.html" class="code" title="function out = point_in_triangle(P,E,V,epsilon, str)">point_in_triangle</a>	POINT_IN_TRIANGLE tests points for membership in triangles</li><li><a href="../../eidors/solvers/forward/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>	[srf, idx] = find_boundary(simp);</li><li><a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>	EIDORS_CACHE Control eidors caching</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="mk_GREIT_model.html" class="code" title="function [imdl, weight]= mk_GREIT_model( fmdl, radius, weight, options )">mk_GREIT_model</a>	MK_GREIT_MODEL: make EIDORS inverse models using the GREIT approach</li><li><a href="mk_pixel_slice.html" class="code" title="function [imdl fmdl] = mk_pixel_slice(imdl,level,opt)">mk_pixel_slice</a>	MK_PIXEL_SLICE create a pixel model to reconstruct on</li><li><a href="../../eidors/solvers/inverse/mk_GN_model.html" class="code" title="function imdl = mk_GN_model(img, opt, lambda)">mk_GN_model</a>	MK_GN_MODEL: make EIDORS inverse models using the GREIT approach</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [rmdl fmdl] = do_pixel_slice(fmdl, opt);</a></li><li><a href="#_sub2" class="code">function mat_idx = calc_mat_idx(rmdl,fmdl,ff,opt)</a></li><li><a href="#_sub3" class="code">function opt = parse_opts(fmdl, opt)</a></li><li><a href="#_sub4" class="code">function elec_lev = get_elec_level(fmdl)</a></li><li><a href="#_sub5" class="code">function do_unit_test</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [imdl fmdl] = mk_pixel_slice(imdl,level,opt)</a>
0002 <span class="comment">%MK_PIXEL_SLICE create a pixel model to reconstruct on</span>
0003 <span class="comment">% OUT = MK_PIXEL_SLICE(MDL, LEVEL, OPT) creates a slice of pixels as a</span>
0004 <span class="comment">% model to reconstruct on.</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% Inputs:</span>
0007 <span class="comment">%  MDL   = an EIDORS forward or inverse model structure</span>
0008 <span class="comment">%  LEVEL = any definition accepted by LEVEL_MODEL_SLICE for a single slice</span>
0009 <span class="comment">%  OPT   = an option structure with the following fields and defaults:</span>
0010 <span class="comment">%     opt.imgsz = [32 32];    % dimensions of the pixel grid</span>
0011 <span class="comment">%     opt.square_pixels = 0;  % adjust imgsz to get square pixels</span>
0012 <span class="comment">%     opt.do_coarse2fine = 1; % calcuate c2f on the forward model</span>
0013 <span class="comment">%     opt.z_depth = inf;      % z_depth to use with mk_coarse_fine_mapping</span>
0014 <span class="comment">%</span>
0015 <span class="comment">% Output depends on the type of model suplied. If MDL is a fwd_model</span>
0016 <span class="comment">% structure then OUT is a rec_model. If MDL is an inv_model, then OUT is a</span>
0017 <span class="comment">% modified version of it, with the pixel slice in inv_model.rec_model and</span>
0018 <span class="comment">% updated inv_model.fwd_model.coarse2fine</span>
0019 <span class="comment">%</span>
0020 <span class="comment">% [OUT FMDL] = MK_PIXEL_SLICE(MDL, ...) also returns the forward model</span>
0021 <span class="comment">% structure with the coarse2fine field.</span>
0022 <span class="comment">%</span>
0023 <span class="comment">% See also MK_COARSE_FINE_MAPPING, MK_GRID_MODEL, LEVEL_MODEL_SLICE</span>
0024 
0025 <span class="comment">% (C) 2013 Bartlomiej Grychtol. License: GPL version 2 or 3</span>
0026 <span class="comment">% $Id: mk_pixel_slice.m 6373 2022-05-13 16:46:17Z bgrychtol $</span>
0027 
0028 <span class="keyword">if</span> ischar(imdl) &amp;&amp; strcmp(imdl,<span class="string">'UNIT_TEST'</span>),<a href="#_sub5" class="code" title="subfunction do_unit_test">do_unit_test</a>;<span class="keyword">return</span>;<span class="keyword">end</span>;
0029 
0030 <span class="keyword">switch</span>(imdl.type)
0031     <span class="keyword">case</span> <span class="string">'inv_model'</span>
0032         fmdl = imdl.fwd_model;
0033     <span class="keyword">case</span> <span class="string">'fwd_model'</span>
0034         fmdl = imdl;
0035     <span class="keyword">otherwise</span>
0036         error(<span class="string">'An EIDORS inverse or forward model struct required'</span>);
0037 <span class="keyword">end</span>
0038 
0039 <span class="keyword">if</span> nargin &lt; 2, opt = struct; <span class="keyword">end</span>
0040 <span class="keyword">if</span> nargin &gt; 1 
0041    <span class="keyword">if</span> ~isstruct(level)
0042       opt.level = level;
0043    <span class="keyword">else</span>
0044       opt = level;
0045    <span class="keyword">end</span>
0046 <span class="keyword">end</span>
0047 opt = <a href="#_sub3" class="code" title="subfunction opt = parse_opts(fmdl, opt)">parse_opts</a>(fmdl,opt);
0048 
0049 [rmdl fmdl] = <a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub1" class="code" title="subfunction [rmdl fmdl] = do_pixel_slice(fmdl, opt);">do_pixel_slice</a>,{fmdl, opt},<span class="string">'mk_pixel_slice'</span>);
0050 
0051 <span class="keyword">switch</span> imdl.type
0052    <span class="keyword">case</span> <span class="string">'inv_model'</span>
0053       imdl.rec_model = rmdl;
0054       imdl.fwd_model = fmdl;
0055    <span class="keyword">case</span> <span class="string">'fwd_model'</span>
0056       imdl = rmdl;
0057 <span class="keyword">end</span>
0058 
0059 <a name="_sub1" href="#_subfunctions" class="code">function [rmdl fmdl] = do_pixel_slice(fmdl, opt);</a>
0060 [tmp, T, R] =<a href="../../eidors/graphics/matlab/level_model_slice.html" class="code" title="function [out, out2, out3] = level_model_slice(varargin)">level_model_slice</a>(fmdl,opt.level);
0061 slc = <a href="../../eidors/graphics/matlab/mdl_slice_mesher.html" class="code" title="function [nimg out] = mdl_slice_mesher(fmdl,level,varargin)">mdl_slice_mesher</a>(tmp,[inf inf 0]);
0062 slc = slc.fwd_model;
0063 mingrid = min(slc.nodes);
0064 maxgrid = max(slc.nodes);
0065 bnd = <a href="../../eidors/solvers/forward/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>(slc);
0066 <span class="comment">% contour_boundary = order_loop(slc.nodes(unique(bnd),:));</span>
0067 
0068 <span class="keyword">if</span> opt.square_pixels ==1
0069     mdl_sz = maxgrid - mingrid;
0070     mdl_AR = mdl_sz(1)/mdl_sz(2);
0071     img_AR = opt.imgsz(1)/opt.imgsz(2);
0072     <span class="keyword">if</span> mdl_AR &lt; img_AR
0073         delta = (mdl_sz(2) * img_AR - mdl_sz(1)) /2;
0074         mingrid(1) = mingrid(1) - delta;
0075         maxgrid(1) = maxgrid(1) + delta;
0076     <span class="keyword">elseif</span> mdl_AR &gt; img_AR
0077         delta = (mdl_sz(1)/img_AR - mdl_sz(2)) / 2;
0078         mingrid(2) = mingrid(2) - delta;
0079         maxgrid(2) = maxgrid(2) + delta;
0080     <span class="keyword">end</span>
0081 <span class="keyword">end</span>
0082 
0083 xgrid = linspace(mingrid(1),maxgrid(1),opt.imgsz(1)+1);
0084 ygrid = linspace(mingrid(2),maxgrid(2),opt.imgsz(2)+1);
0085 rmdl = <a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>([],xgrid,ygrid);
0086 x_pts = xgrid(1:end-1) + 0.5*diff(xgrid);
0087 y_pts = ygrid(1:end-1) + 0.5*diff(ygrid);
0088 <span class="comment">% y_pts = fliplr(y_pts); %medical</span>
0089 
0090 <span class="comment">% NOTE: This controls the image resolution. If you want higher res, you</span>
0091 <span class="comment">% need to either specify it in opt.imgsz or manually overwrite (or remove)</span>
0092 <span class="comment">% the imdl.rec_model.mdl_slice_mapper.</span>
0093 rmdl.mdl_slice_mapper.x_pts = x_pts;
0094 rmdl.mdl_slice_mapper.y_pts = y_pts;
0095 rmdl.mdl_slice_mapper.level = opt.level;
0096 rmdl.mdl_slice_mapper.model_2d = 1;
0097 x_avg = conv2(xgrid, [1,1]/2,<span class="string">'valid'</span>);
0098 y_avg = conv2(ygrid, [1,1]/2,<span class="string">'valid'</span>);
0099 [x,y] = ndgrid( x_avg, y_avg);
0100 
0101 <span class="comment">% 20141119: The inpolygon approach fails on non-simply-connected domains</span>
0102 <span class="comment">% inside = inpolygon(x(:),y(:),contour_boundary(:,1),contour_boundary(:,2) );</span>
0103 P = [x(:) y(:)]; <span class="comment">% P(end,3) = 0;</span>
0104 inside = any(<a href="point_in_triangle.html" class="code" title="function out = point_in_triangle(P,E,V,epsilon, str)">point_in_triangle</a>(P, slc.elems, slc.nodes(:,1:2)),2);
0105 <span class="comment">% inside = full(inside);</span>
0106 
0107 ff = find(~inside);
0108 
0109 <span class="keyword">if</span> opt.do_coarse2fine
0110 <span class="comment">%     rmdl.mk_coarse_fine_mapping.z_depth = opt.z_depth;</span>
0111 <span class="comment">%     fmdl.coarse2fine = mk_coarse_fine_mapping(tmp,rmdl);</span>
0112 <span class="comment">%     fmdl.coarse2fine(:,ff) = [];</span>
0113     <span class="keyword">if</span> isinf(opt.z_depth)
0114        zgrid = [min(tmp.nodes(:,3))-1 max(tmp.nodes(:,3))+1];
0115     <span class="keyword">else</span>
0116        zgrid = [-opt.z_depth opt.z_depth];
0117     <span class="keyword">end</span>
0118     [jnk, fmdl.coarse2fine] = <a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>(tmp,xgrid,ygrid,zgrid);
0119     fmdl.coarse2fine(:,ff);
0120 <span class="keyword">end</span>
0121 
0122 rmdl.elems([2*ff, 2*ff-1],:)= [];
0123 rmdl.coarse2fine([2*ff, 2*ff-1],:)= [];
0124 rmdl.coarse2fine(:,ff)= [];
0125 <span class="comment">% rmdl.boundary = find_boundary(rmdl);</span>
0126 <span class="comment">% show individual elements (more like how the 2d grid models display)</span>
0127 rmdl.boundary = rmdl.elems;
0128 rmdl.inside   = inside; <span class="comment">% the inside array is useful in other functions</span>
0129 
0130 
0131 <span class="keyword">if</span> isfield(fmdl,<span class="string">'mat_idx'</span>)
0132    rmdl.mat_idx = <a href="#_sub2" class="code" title="subfunction mat_idx = calc_mat_idx(rmdl,fmdl,ff,opt)">calc_mat_idx</a>(rmdl,fmdl,ff,opt);
0133 <span class="keyword">end</span>
0134 
0135 <span class="comment">% map electrodes</span>
0136 rmdl.nodes(:,3) = 0;
0137 rmdl.nodes =  (R\rmdl.nodes' + T'*ones(1,length(rmdl.nodes)))';
0138 slc.nodes =  (R\slc.nodes' + T'*ones(1,length(slc.nodes)))';
0139 
0140 isf = ~isinf(opt.level);
0141 <span class="keyword">if</span> nnz(isf) == 1
0142    rmdl.nodes(:,isf) = opt.level(:,isf);
0143 <span class="keyword">end</span>
0144 
0145 <span class="keyword">if</span> isfield(slc, <span class="string">'electrode'</span>)
0146    <span class="keyword">for</span> i = flipud(1:numel(slc.electrode))
0147         tmp = rmfield(slc.electrode(i), <span class="string">'nodes'</span>);
0148         x_elec = slc.nodes( [slc.electrode(i).nodes], 1);
0149         y_elec = slc.nodes( [slc.electrode(i).nodes], 2);
0150         z_elec = slc.nodes( [slc.electrode(i).nodes], 3);
0151         tmp.pos       = [x_elec, y_elec, z_elec];
0152         elec(i) = tmp;
0153     <span class="keyword">end</span>
0154     rmdl.electrode = elec;
0155 <span class="keyword">end</span>
0156    
0157 
0158 rmdl.show_slices.levels = opt.level;
0159       
0160 
0161 <a name="_sub2" href="#_subfunctions" class="code">function mat_idx = calc_mat_idx(rmdl,fmdl,ff,opt)</a>
0162    <span class="comment">% calculate mat_idx for the rec_model</span>
0163    fmdl.mdl_slice_mapper = rmfield(rmdl.mdl_slice_mapper,<span class="string">'model_2d'</span>);
0164    fmdl.mdl_slice_mapper.level = opt.level;
0165    img = <a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(fmdl,0);
0166    <span class="keyword">for</span> i = 1:length(fmdl.mat_idx);
0167       img.elem_data(fmdl.mat_idx{i}) = i;
0168    <span class="keyword">end</span>
0169    slice = <a href="../../eidors/graphics/matlab/calc_slices.html" class="code" title="function rimg = calc_slices( img, levels );">calc_slices</a>(img,opt.level);
0170    slice = slice';
0171    mat = reshape([slice(:)'; slice(:)'],1,[]);
0172    mat([2*ff, 2*ff-1])= [];
0173    mat_idx = cell(max(mat),1);
0174    <span class="keyword">for</span> i = 1:max(mat)
0175       mat_idx(i) = {find(mat==i)'};
0176    <span class="keyword">end</span>
0177 
0178 
0179  <a name="_sub3" href="#_subfunctions" class="code">function opt = parse_opts(fmdl, opt)</a>
0180     <span class="keyword">if</span> ~isfield(opt, <span class="string">'imgsz'</span>),     
0181         opt.imgsz = [32 32]; 
0182     <span class="keyword">end</span>
0183     <span class="keyword">if</span> ~isfield(opt, <span class="string">'square_pixels'</span>)
0184         opt.square_pixels = 0;
0185     <span class="keyword">end</span>
0186     <span class="keyword">if</span> ~isfield(opt, <span class="string">'level'</span>)
0187         opt.level = <a href="#_sub4" class="code" title="subfunction elec_lev = get_elec_level(fmdl)">get_elec_level</a>(fmdl);
0188     <span class="keyword">else</span>
0189         <span class="keyword">if</span> numel(opt.level) ==1
0190             opt.level = [inf inf opt.level];
0191         <span class="keyword">end</span>
0192     <span class="keyword">end</span>
0193     <span class="keyword">if</span> ~isfield(opt, <span class="string">'do_coarse2fine'</span>)
0194         opt.do_coarse2fine = 1;
0195     <span class="keyword">end</span>
0196     <span class="keyword">if</span> ~isfield(opt, <span class="string">'z_depth'</span>)
0197         opt.z_depth = inf;
0198     <span class="keyword">end</span>
0199     
0200 <a name="_sub4" href="#_subfunctions" class="code">function elec_lev = get_elec_level(fmdl)</a>
0201     z_elec= fmdl.nodes( [fmdl.electrode(:).nodes], 3);
0202     min_e = min(z_elec); max_e = max(z_elec);
0203     elec_lev = [inf,inf,mean([min_e,max_e])];
0204 
0205     
0206 <a name="_sub5" href="#_subfunctions" class="code">function do_unit_test</a>
0207     imdl = <a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'n3r2'</span>,[16,2]);
0208     opt.square_pixels = 1;
0209     opt.imgsz = [16 16];
0210     mdl = <a href="mk_pixel_slice.html" class="code" title="function [imdl fmdl] = mk_pixel_slice(imdl,level,opt)">mk_pixel_slice</a>(imdl.fwd_model,[inf 2 2.5], opt);
0211     img = <a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(mdl,1);
0212     
0213     subplot(231)
0214     <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imdl.fwd_model);
0215     view([-50 10])
0216 
0217     subplot(232)
0218     <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img);
0219     zlim([0 3]);
0220     ylim([-1 1])
0221     xlim([-1 1]);
0222     view([-50 10])
0223     
0224     subplot(233)
0225     <a href="../../eidors/graphics/matlab/show_slices.html" class="code" title="function out_img= show_slices( img, levels, vh )">show_slices</a>(img);
0226     
0227     subplot(234)
0228     imdl = <a href="mk_pixel_slice.html" class="code" title="function [imdl fmdl] = mk_pixel_slice(imdl,level,opt)">mk_pixel_slice</a>(imdl);
0229     img = <a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(imdl.rec_model,1);
0230     <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img);
0231     zlim([0 3]);
0232     ylim([-1 1])
0233     xlim([-1 1]);
0234     view([-50 10])
0235     
0236     subplot(235)
0237     mdl = <a href="mk_library_model.html" class="code" title="function out = mk_library_model(shape,elec_pos,elec_shape,maxsz,nfft,scale)">mk_library_model</a>(<span class="string">'pig_23kg_16el_lungs'</span>);
0238     img = <a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(mdl,1);
0239     <span class="keyword">for</span> i = 1:length(mdl.mat_idx)
0240        img.elem_data(mdl.mat_idx{i}) = i;
0241     <span class="keyword">end</span>
0242     <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img)
0243     view(2)
0244     
0245     subplot(236)
0246     clear opt
0247     opt.imgsz = [64 64];
0248     opt.square_pixels = 1;
0249     opt.do_coarse2fine = 0;
0250     mdl = <a href="mk_library_model.html" class="code" title="function out = mk_library_model(shape,elec_pos,elec_shape,maxsz,nfft,scale)">mk_library_model</a>(<span class="string">'pig_23kg_16el_lungs'</span>);
0251     rmdl = <a href="mk_pixel_slice.html" class="code" title="function [imdl fmdl] = mk_pixel_slice(imdl,level,opt)">mk_pixel_slice</a>(mdl,opt);
0252     img = <a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(rmdl,1);
0253     <span class="keyword">for</span> i = 1:length(rmdl.mat_idx)
0254        img.elem_data(rmdl.mat_idx{i}) = i;
0255     <span class="keyword">end</span>
0256     <a href="../../eidors/graphics/matlab/show_slices.html" class="code" title="function out_img= show_slices( img, levels, vh )">show_slices</a>(img);</pre></div>
<hr><address>Generated on Fri 30-Dec-2022 20:46:51 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>
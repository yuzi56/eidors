<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of fix_model</title>
  <meta name="keywords" content="fix_model">
  <meta name="description" content="FIX_MODEL: Add useful fields to a model">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">eidors</a> &gt; <a href="index.html">models</a> &gt; fix_model.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/models&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>fix_model
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>FIX_MODEL: Add useful fields to a model</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [mdl] = fix_model(mdl,opt) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> FIX_MODEL: Add useful fields to a model
    [mdl] = fix_model(mdl,options)
 INPUT:
    mdl - an FEM model with at least the following fields:
       .name
       .nodes
       .elem
    options - a struct with logical values specifying which fields to
        compute. Defaults to false for absent fields. 

 Run fix_model('options') to get an all-false options struct, or
 fix_model('options',true) to get an all-true one.
 mdl.faces is only replaced if necessary. mdl.boundary is never replaced.

 OUTPUT:
    mdl - a copy of the input model with these additional fields:
       .boundary
       .boundary_face
       .faces
       .face2elem
       .elem2face
       .elem_centre
       .face_centre
       .face_area
       .normals
       .max_edge_len (per elem)
       .edges
       .edge_length
       .edge2elem
       .elem2edge
       .face2edge
       .node2elem

 For triangular meshes, edges and faces are the same.

 The elems will be reordered so that all faces are counter-clockwise.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG eidors progress and status messages</li><li><a href="../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>	EIDORS_OBJ: maintains EIDORS internals</li><li><a href="elem_dim.html" class="code" title="function num = elem_dim( mdl );">elem_dim</a>	ELEM_DIM: dimension of elements in space (are elements in 2D or 3D space)</li><li><a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>	FIX_MODEL: Add useful fields to a model</li><li><a href="get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>	GET_ELEM_VOLUME: VOL = get_elem_volume(fwd_model, map_node )</li><li><a href="interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>	INTERP_MESH: calculate interpolation points onto mdl elements</li><li><a href="linear_reorder.html" class="code" title="function [fwd_model] = linear_reorder(fwd_model,ccw)">linear_reorder</a>	[fwd_model] = linear_reorder(fwd_model,ccw)</li><li><a href="mdl_dim.html" class="code" title="function num = mdl_dim( mdl );">mdl_dim</a>	MDL_DIM: dimension of model space (are nodes in 2D or 3D space)</li><li><a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="num_elems.html" class="code" title="function num = num_elems( mdl );">num_elems</a>	NUM_ELEMS: number of elemnts in a (fwd or inv model or image)</li><li><a href="num_nodes.html" class="code" title="function num = num_nodes( mdl );">num_nodes</a>	NUM_NODES: number of elemnts in a (fwd or inv model or image)</li><li><a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>	SPARSE Create sparse matrix (EIDORS overload).</li><li><a href="../../eidors/solvers/forward/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>	[srf, idx] = find_boundary(simp);</li><li><a href="../../eidors/tools/cross3.html" class="code" title="function c = cross3(a,b)">cross3</a>	CROSS3  3D cross parallel cross product</li><li><a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>	EIDORS_CACHE Control eidors caching</li><li><a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>	UNIT_TEST_CMP: compare matrices in eidors output</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../eidors/graphics/matlab/calc_grid_points.html" class="code" title="function val = calc_grid_points(img, xpts, ypts, zpts)">calc_grid_points</a>	CALC_GRID_POINTS - image values at points in grid</li><li><a href="../../eidors/graphics/matlab/mdl_slice_mesher.html" class="code" title="function [nimg out] = mdl_slice_mesher(fmdl,level,varargin)">mdl_slice_mesher</a>	MDL_SLICE_MESHER A slice of a 3D FEM as a 2D FEM</li><li><a href="../../eidors/meshing/calc_mesh_quality.html" class="code" title="function [Q mdl] = calc_mesh_quality(mdl, show)">calc_mesh_quality</a>	CALC_MESH_QUALITY Various measures of mesh quality.</li><li><a href="../../eidors/meshing/netgen/ng_mk_2d_model.html" class="code" title="function mdl = ng_mk_2d_model(varargin)">ng_mk_2d_model</a>	NG_MG_2D_MODELS create a 2D mesh with Netgen via the in2d interface</li><li><a href="GREIT3D_distribution.html" class="code" title="function [imdl,distr] = GREIT3D_distribution(fmdl, vopt)">GREIT3D_distribution</a>	GREIT3D_distribution: create target distributions for 3D GREIT</li><li><a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>	FIX_MODEL: Add useful fields to a model</li><li><a href="mk_c2f_circ_mapping.html" class="code" title="function [mapping failed] = mk_c2f_circ_mapping( mdl, xyzr );">mk_c2f_circ_mapping</a>	MK_C2F_CIRC_MAPPING: create a mapping matrix from circles/spheres to FEM</li><li><a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>	MK_GRID_C2F - calculate a coarse2fine mapping for grid coarse models.</li><li><a href="mk_tet_c2f.html" class="code" title="function [c2f] = mk_tet_c2f(fmdl, rmdl, opt)">mk_tet_c2f</a>	MK_TET_C2F - calculate a coarse2fine mapping for two tet-based models.</li><li><a href="mk_thorax_model.html" class="code" title="function out = mk_thorax_model(str, varargin)">mk_thorax_model</a>	MK_THORAX_MODEL FEM models of the thorax</li><li><a href="mk_tri2tet_c2f.html" class="code" title="function c2f = mk_tri2tet_c2f(fmdl,rmdl, opt)">mk_tri2tet_c2f</a>	MK_TRI2TET_C2F - coarse2fine mapping between tri-based and tet-based models</li><li><a href="mk_tri_c2f.html" class="code" title="function c2f = mk_tri_c2f(fmdl,rmdl,opt)">mk_tri_c2f</a>	MK_TRI_C2F - calculate a coarse2fine mapping for triangle-based models.</li><li><a href="place_elec_on_surf.html" class="code" title="function mdl2 = place_elec_on_surf(mdl,elec_pos, elec_spec,ng_opt_file, maxh)">place_elec_on_surf</a>	PLACE_ELEC_ON_SURF Place electrodes on the surface of a model</li><li><a href="../../eidors/solvers/inverse/prior_laplace.html" class="code" title="function Reg= prior_laplace( inv_model )">prior_laplace</a>	PRIOR_LAPLACE calculate image prior</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function fmdl = remove_unused_nodes( fmdl );</a></li><li><a href="#_sub2" class="code">function mdl = do_fix_model(mdl, doall, opt)</a></li><li><a href="#_sub3" class="code">function inner_normal = test_inner_normal( mdl )</a></li><li><a href="#_sub4" class="code">function [faces,  elem2face] = calc_faces(mdl, facedim)</a></li><li><a href="#_sub5" class="code">function edge2elem = calc_edge2elem(elem2edge,n_edges)</a></li><li><a href="#_sub6" class="code">function f2e = calc_face2edge(mdl)</a></li><li><a href="#_sub7" class="code">function face2elem = calc_face2elem(elem2face)</a></li><li><a href="#_sub8" class="code">function elem2face = calc_elem2face(face2elem, face_per_elem)</a></li><li><a href="#_sub9" class="code">function normals = calc_normals(mdl)</a></li><li><a href="#_sub10" class="code">function A = calc_face_area(mdl)</a></li><li><a href="#_sub11" class="code">function L = calc_edge_length(mdl)</a></li><li><a href="#_sub12" class="code">function len = calc_longest_edge(elems,nodes)</a></li><li><a href="#_sub13" class="code">function out = fix_options(mdl, opt)</a></li><li><a href="#_sub14" class="code">function out = list_options(val)</a></li><li><a href="#_sub15" class="code">function do_unit_test</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [mdl] = fix_model(mdl,opt)</a>
0002 <span class="comment">% FIX_MODEL: Add useful fields to a model</span>
0003 <span class="comment">%    [mdl] = fix_model(mdl,options)</span>
0004 <span class="comment">% INPUT:</span>
0005 <span class="comment">%    mdl - an FEM model with at least the following fields:</span>
0006 <span class="comment">%       .name</span>
0007 <span class="comment">%       .nodes</span>
0008 <span class="comment">%       .elem</span>
0009 <span class="comment">%    options - a struct with logical values specifying which fields to</span>
0010 <span class="comment">%        compute. Defaults to false for absent fields.</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% Run fix_model('options') to get an all-false options struct, or</span>
0013 <span class="comment">% fix_model('options',true) to get an all-true one.</span>
0014 <span class="comment">% mdl.faces is only replaced if necessary. mdl.boundary is never replaced.</span>
0015 <span class="comment">%</span>
0016 <span class="comment">% OUTPUT:</span>
0017 <span class="comment">%    mdl - a copy of the input model with these additional fields:</span>
0018 <span class="comment">%       .boundary</span>
0019 <span class="comment">%       .boundary_face</span>
0020 <span class="comment">%       .faces</span>
0021 <span class="comment">%       .face2elem</span>
0022 <span class="comment">%       .elem2face</span>
0023 <span class="comment">%       .elem_centre</span>
0024 <span class="comment">%       .face_centre</span>
0025 <span class="comment">%       .face_area</span>
0026 <span class="comment">%       .normals</span>
0027 <span class="comment">%       .max_edge_len (per elem)</span>
0028 <span class="comment">%       .edges</span>
0029 <span class="comment">%       .edge_length</span>
0030 <span class="comment">%       .edge2elem</span>
0031 <span class="comment">%       .elem2edge</span>
0032 <span class="comment">%       .face2edge</span>
0033 <span class="comment">%       .node2elem</span>
0034 <span class="comment">%</span>
0035 <span class="comment">% For triangular meshes, edges and faces are the same.</span>
0036 <span class="comment">%</span>
0037 <span class="comment">% The elems will be reordered so that all faces are counter-clockwise.</span>
0038 
0039 <span class="comment">% (C) 2011 Bartlomiej Grychtol. Licensed under GPL v2 or v3</span>
0040 <span class="comment">% $Id: fix_model.m 5822 2018-08-27 13:03:01Z aadler $</span>
0041 
0042 <span class="keyword">if</span> ischar(mdl) &amp;&amp; strcmp(mdl,<span class="string">'UNIT_TEST'</span>); <a href="#_sub15" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0043 
0044 <span class="keyword">if</span> ischar(mdl) &amp;&amp; strcmp(mdl,<span class="string">'options'</span>); 
0045    <span class="keyword">if</span> nargin &lt; 2, opt = false; <span class="keyword">end</span>
0046    mdl = <a href="#_sub14" class="code" title="subfunction out = list_options(val)">list_options</a>(opt); 
0047    <span class="keyword">return</span> 
0048 <span class="keyword">end</span>
0049 doall = false;
0050 <span class="keyword">if</span> nargin &gt; 1
0051    opt = <a href="#_sub13" class="code" title="subfunction out = fix_options(mdl, opt)">fix_options</a>(mdl,opt);
0052 <span class="keyword">else</span>
0053    doall = true; opt=struct;
0054 <span class="keyword">end</span>
0055 
0056 <span class="comment">% prepare a model with geometry only</span>
0057 tmp.nodes = mdl.nodes;
0058 tmp.elems = mdl.elems;
0059 tmp.type  = mdl.type;
0060 <span class="keyword">try</span>, tmp.boundary = mdl.boundary; <span class="keyword">end</span>
0061 <span class="keyword">try</span>, tmp.faces = mdl.faces; <span class="keyword">end</span>
0062 
0063 copt.cache_obj = {tmp, doall, opt};
0064 copt.fstr      = <span class="string">'fix_model'</span>;
0065 
0066 tmp = <a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>( @<a href="#_sub2" class="code" title="subfunction mdl = do_fix_model(mdl, doall, opt)">do_fix_model</a>, {tmp, doall, opt}, copt);
0067 
0068 <span class="comment">% copy new fields to mdl</span>
0069 flds = fieldnames(tmp); flds(1:3) = []; <span class="comment">% ignore nodes, elems and type</span>
0070 <span class="keyword">for</span> i = 1:numel(flds)
0071    mdl.(flds{i}) = tmp.(flds{i});
0072 <span class="keyword">end</span>
0073 
0074 <span class="comment">% This code may not stay here. Think about where to put it</span>
0075 <a name="_sub1" href="#_subfunctions" class="code">function fmdl = remove_unused_nodes( fmdl );</a>
0076    usednodes = unique(fmdl.elems(:));
0077    <span class="keyword">if</span> max(usednodes) &gt; <a href="num_nodes.html" class="code" title="function num = num_nodes( mdl );">num_nodes</a>(fmdl)
0078       error(<span class="string">'more nodes are used than exist'</span>);
0079    <span class="keyword">end</span>
0080    nidx = zeros(<a href="num_nodes.html" class="code" title="function num = num_nodes( mdl );">num_nodes</a>(fmdl),1);
0081    nidx(usednodes) = 1:length(usednodes);
0082    fmdl.nodes(nidx==0,:) = [];
0083    fmdl.elems = reshape(nidx(fmdl.elems),[],size(fmdl.elems,2));
0084 
0085    <span class="keyword">for</span> i=1:length(fmdl.electrode)
0086       fmdl.electrode(i).nodes =  nidx( <span class="keyword">...</span>
0087          fmdl.electrode(i).nodes);
0088    <span class="keyword">end</span>
0089    fmdl.boundary = <a href="../../eidors/solvers/forward/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>(fmdl);
0090    fmdl.gnd_node = usednodes(fmdl.gnd_node);
0091 
0092 
0093 <span class="comment">% Complete the function</span>
0094 <a name="_sub2" href="#_subfunctions" class="code">function mdl = do_fix_model(mdl, doall, opt)</a>
0095 
0096 <span class="keyword">if</span> doall || opt.boundary
0097    <span class="keyword">if</span> ~isfield(mdl,<span class="string">'boundary'</span>)
0098       mdl.boundary = <a href="../../eidors/solvers/forward/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>(mdl);
0099    <span class="keyword">end</span>
0100 <span class="keyword">end</span>
0101 <span class="keyword">if</span> doall || opt.faces
0102    <span class="keyword">if</span> <a href="elem_dim.html" class="code" title="function num = elem_dim( mdl );">elem_dim</a>(mdl) == <a href="mdl_dim.html" class="code" title="function num = mdl_dim( mdl );">mdl_dim</a>(mdl);
0103       [mdl.faces mdl.elem2face] = <a href="#_sub4" class="code" title="subfunction [faces,  elem2face] = calc_faces(mdl, facedim)">calc_faces</a>(mdl);
0104    <span class="keyword">else</span>
0105       <span class="comment">% surface mesh</span>
0106       mdl.faces = sort(mdl.elems,2);
0107       mdl.elem2face = (1:length(mdl.faces))';
0108    <span class="keyword">end</span>
0109 <span class="keyword">end</span>
0110 <span class="keyword">if</span> doall || opt.face2elem
0111     mdl.face2elem = <a href="#_sub7" class="code" title="subfunction face2elem = calc_face2elem(elem2face)">calc_face2elem</a>(mdl.elem2face);
0112 <span class="keyword">end</span>
0113 <span class="keyword">if</span> doall || opt.boundary_face
0114    mdl.boundary_face = mdl.face2elem(:,2)==0;
0115 <span class="keyword">end</span>
0116 <span class="keyword">if</span> doall || opt.elem_centre
0117    mdl.elem_centre = <a href="interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>(mdl, 0);
0118 <span class="keyword">end</span>
0119 <span class="keyword">if</span> doall || opt.face_centre
0120    tmp = mdl;
0121    tmp.elems = tmp.faces;
0122    mdl.face_centre = <a href="interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>(tmp,0);
0123 <span class="keyword">end</span>
0124 <span class="keyword">if</span> doall || opt.max_edge_len
0125    mdl.max_edge_len = <a href="#_sub12" class="code" title="subfunction len = calc_longest_edge(elems,nodes)">calc_longest_edge</a>(mdl.elems,mdl.nodes);
0126 <span class="keyword">end</span>
0127 <span class="keyword">if</span> doall || opt.elem_volume
0128    mdl.elem_volume = <a href="get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>(mdl);
0129 <span class="keyword">end</span>
0130 <span class="keyword">if</span> doall || opt.face_area
0131    <span class="keyword">if</span> <a href="elem_dim.html" class="code" title="function num = elem_dim( mdl );">elem_dim</a>(mdl) == 2
0132       mdl.face_area = <a href="get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>(mdl);
0133    <span class="keyword">else</span>
0134       mdl.face_area = <a href="#_sub10" class="code" title="subfunction A = calc_face_area(mdl)">calc_face_area</a>(mdl);
0135    <span class="keyword">end</span>
0136 <span class="keyword">end</span>
0137 el_dim = <a href="elem_dim.html" class="code" title="function num = elem_dim( mdl );">elem_dim</a>(mdl);
0138 <span class="keyword">if</span> doall || opt.edges
0139     <span class="keyword">if</span> <a href="mdl_dim.html" class="code" title="function num = mdl_dim( mdl );">mdl_dim</a>(mdl)==3 <span class="comment">%that's unlikely to work for higher order elements</span>
0140         [mdl.edges mdl.elem2edge] = <a href="#_sub4" class="code" title="subfunction [faces,  elem2face] = calc_faces(mdl, facedim)">calc_faces</a>(mdl,2);
0141     <span class="keyword">else</span> 
0142         mdl.edges = mdl.faces;
0143         mdl.elem2edge = mdl.elem2face;
0144     <span class="keyword">end</span>
0145 <span class="keyword">end</span>
0146 <span class="keyword">if</span> doall || opt.node2elem
0147     mdl.node2elem = <a href="#_sub5" class="code" title="subfunction edge2elem = calc_edge2elem(elem2edge,n_edges)">calc_edge2elem</a>(mdl.elems,size(mdl.nodes,1));
0148 <span class="keyword">end</span>
0149 <span class="keyword">if</span> doall || opt.edge2elem
0150     mdl.edge2elem = <a href="#_sub5" class="code" title="subfunction edge2elem = calc_edge2elem(elem2edge,n_edges)">calc_edge2elem</a>(mdl.elem2edge, size(mdl.edges,1));
0151 <span class="keyword">end</span>
0152 
0153 <span class="keyword">if</span> doall || opt.face2edge
0154    <span class="keyword">if</span> el_dim &lt;3
0155       mdl.face2edge = mdl.elem2edge;
0156    <span class="keyword">else</span>
0157       mdl.face2edge = uint32(<a href="#_sub6" class="code" title="subfunction f2e = calc_face2edge(mdl)">calc_face2edge</a>(mdl));
0158    <span class="keyword">end</span>
0159 <span class="keyword">end</span>
0160 
0161 <span class="keyword">if</span> doall || opt.edge_length
0162    mdl.edge_length = <a href="#_sub11" class="code" title="subfunction L = calc_edge_length(mdl)">calc_edge_length</a>(mdl);
0163 <span class="keyword">end</span>
0164 
0165 <span class="keyword">if</span> doall || opt.linear_reorder
0166    mdl = <a href="linear_reorder.html" class="code" title="function [fwd_model] = linear_reorder(fwd_model,ccw)">linear_reorder</a>(mdl); <span class="comment">%counter-clockwise</span>
0167 <span class="keyword">end</span>
0168 <span class="keyword">if</span> doall || opt.normals
0169    mdl.normals = <a href="#_sub9" class="code" title="subfunction normals = calc_normals(mdl)">calc_normals</a>(mdl);
0170 <span class="keyword">end</span>
0171 <span class="keyword">if</span> doall || opt.inner_normal
0172    <span class="keyword">if</span> <a href="mdl_dim.html" class="code" title="function num = mdl_dim( mdl );">mdl_dim</a>(mdl) == <a href="elem_dim.html" class="code" title="function num = elem_dim( mdl );">elem_dim</a>(mdl);
0173       mdl.inner_normal = <a href="#_sub3" class="code" title="subfunction inner_normal = test_inner_normal( mdl )">test_inner_normal</a>( mdl );
0174    <span class="keyword">else</span>
0175       <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ Inner normal test for surface meshes not implemented.'</span>,1);
0176    <span class="keyword">end</span>
0177 <span class="keyword">end</span>
0178 
0179 <span class="comment">% decrease memory footprint</span>
0180 mdl.elems = uint32(mdl.elems);
0181 <span class="keyword">if</span> doall || opt.faces
0182    mdl.faces = uint32(mdl.faces);
0183    mdl.elem2face = uint32(mdl.elem2face);
0184 <span class="keyword">end</span>
0185 <span class="keyword">if</span> doall || opt.face2elem
0186    mdl.face2elem = uint32(mdl.face2elem);
0187 <span class="keyword">end</span>     
0188 <span class="keyword">if</span> doall || opt.edges
0189    mdl.edges = uint32(mdl.edges);
0190    mdl.elem2edge = uint32(mdl.elem2edge);
0191 <span class="keyword">end</span>
0192 <span class="keyword">if</span> doall || opt.edge2elem
0193    mdl.edge2elem = logical(mdl.edge2elem);
0194 <span class="keyword">end</span>     
0195 
0196 <span class="comment">% Test whether normal points into or outside</span>
0197 <span class="comment">% mdl.inner_normal(i,j) = 1 if face j of elem i points in</span>
0198 <a name="_sub3" href="#_subfunctions" class="code">function inner_normal = test_inner_normal( mdl )</a>
0199    inner_normal = false(size(mdl.elem2face));
0200    d = <a href="elem_dim.html" class="code" title="function num = elem_dim( mdl );">elem_dim</a>(mdl) + 1;
0201    <span class="keyword">for</span> i=1:<a href="num_elems.html" class="code" title="function num = num_elems( mdl );">num_elems</a>(mdl);
0202       el_faces = mdl.elem2face(i,:);
0203       el_ctr   = repmat( mdl.elem_centre(i,:), d, 1);
0204       vec_fa_el= el_ctr -  mdl.face_centre(el_faces,:);
0205       normal_i  = mdl.normals(el_faces,:);
0206       dot_prod = sum( normal_i.*vec_fa_el, 2 );
0207       inner_normal(i,:) = dot_prod' &gt; 0;
0208    <span class="keyword">end</span>
0209 
0210 <a name="_sub4" href="#_subfunctions" class="code">function [faces,  elem2face] = calc_faces(mdl, facedim)</a>
0211 
0212 e_dim = <a href="elem_dim.html" class="code" title="function num = elem_dim( mdl );">elem_dim</a>(mdl);
0213 <span class="keyword">if</span> nargin == 1
0214     facedim = e_dim;
0215 <span class="keyword">end</span>
0216 
0217 idx = nchoosek(1:e_dim+1, facedim);
0218 elem_sorted = sort(mdl.elems,2);
0219 [faces ib ia] = unique(reshape(elem_sorted(:,idx),[],facedim),<span class="string">'rows'</span>);
0220 elem2face = reshape(ia,[],size(idx,1));
0221 
0222 <a name="_sub5" href="#_subfunctions" class="code">function edge2elem = calc_edge2elem(elem2edge,n_edges)</a>
0223 
0224     [n_elems, el_faces] = size(elem2edge);
0225     elem2edgeno = (1:n_elems)'*ones(1,el_faces);
0226     elem2edgeno = elem2edgeno(:);
0227     elem2edge   = elem2edge(:);
0228     edge2elem = <a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(elem2edge,elem2edgeno,ones(size(elem2edgeno)),n_edges,n_elems);
0229 
0230 <a name="_sub6" href="#_subfunctions" class="code">function f2e = calc_face2edge(mdl)</a>
0231 <span class="comment">%faces and edges are both row-wise sorted</span>
0232 nf = length(mdl.faces);
0233 list(1:3:3*nf,:) = mdl.faces(:,1:2);
0234 list(2:3:3*nf,:) = mdl.faces(:,[1 3]);
0235 list(3:3:3*nf,:) = mdl.faces(:,2:3);
0236 [jnk f2e] = ismember(list, mdl.edges, <span class="string">'rows'</span>);
0237 f2e = reshape(f2e,3,[])';
0238 
0239 <a name="_sub7" href="#_subfunctions" class="code">function face2elem = calc_face2elem(elem2face)</a>
0240 <span class="comment">% This is easier to understand but very slow</span>
0241 <span class="comment">%     n_face = max(elem2face(:));</span>
0242 <span class="comment">%     face2elem = zeros(n_face,2);</span>
0243 <span class="comment">%     for i= 1:n_face</span>
0244 <span class="comment">%         [el jnk] = find(elem2face==i);</span>
0245 <span class="comment">%         if numel(el)==1, el(2) = 0; end</span>
0246 <span class="comment">%         face2elem(i,:) = el;</span>
0247 <span class="comment">%     end</span>
0248 <span class="comment">%     bck = face2elem; face2elem=[];</span>
0249     [n_elems, el_faces] = size(elem2face);
0250     elem2faceno = (1:n_elems)'*ones(1,el_faces);
0251     elem2faceno = elem2faceno(:);
0252     elem2face   = elem2face(:);
0253     face2elem(elem2face,2) = elem2faceno;
0254     <span class="comment">% flipping will give us the other element for shared faces</span>
0255     elem2faceno = flipud(elem2faceno);
0256     elem2face   = flipud(elem2face);
0257     face2elem(elem2face,1) = elem2faceno;
0258     <span class="comment">% replace with zeros repeated entries (boundary faces)</span>
0259     face2elem( face2elem(:,1) == face2elem(:,2), 2) = 0;
0260 
0261 <span class="comment">% This function is obsolete</span>
0262 <a name="_sub8" href="#_subfunctions" class="code">function elem2face = calc_elem2face(face2elem, face_per_elem)</a>
0263     n_elem = max(face2elem(:));
0264     elem2face = zeros(n_elem,face_per_elem);
0265     <span class="keyword">for</span> i = 1:n_elem
0266         [f jnk] = find(face2elem==i);
0267         elem2face(i,:) = f;
0268     <span class="keyword">end</span>
0269     
0270 <a name="_sub9" href="#_subfunctions" class="code">function normals = calc_normals(mdl)</a>
0271     [n_faces face_dim] = size(mdl.faces);
0272     <span class="keyword">switch</span> face_dim
0273         <span class="keyword">case</span> 2
0274             A = mdl.nodes(mdl.faces(:,1),:);
0275             B = mdl.nodes(mdl.faces(:,2),:);
0276             normals = (B-A)*[0 1; -1 0];
0277         <span class="keyword">case</span> 3
0278             <span class="comment">% vectorise cross product</span>
0279             x1 = mdl.nodes(mdl.faces(:,2),1) - mdl.nodes(mdl.faces(:,1),1);
0280             y1 = mdl.nodes(mdl.faces(:,2),2) - mdl.nodes(mdl.faces(:,1),2);
0281             z1 = mdl.nodes(mdl.faces(:,2),3) - mdl.nodes(mdl.faces(:,1),3);
0282             x2 = mdl.nodes(mdl.faces(:,3),1) - mdl.nodes(mdl.faces(:,1),1);
0283             y2 = mdl.nodes(mdl.faces(:,3),2) - mdl.nodes(mdl.faces(:,1),2);
0284             z2 = mdl.nodes(mdl.faces(:,3),3) - mdl.nodes(mdl.faces(:,1),3);
0285             <span class="comment">%(a2b3 ? a3b2, a3b1 ? a1b3, a1b2 ? a2b1).</span>
0286             normals = zeros(n_faces,3);
0287             normals(:,1) = y1.*z2 - z1.*y2;
0288             normals(:,2) = z1.*x2 - x1.*z2;
0289             normals(:,3) = x1.*y2 - y1.*x2;
0290         <span class="keyword">otherwise</span>;
0291             error(<span class="string">'not 2D or 3D'</span>)
0292     <span class="keyword">end</span>
0293     normals = normals./ repmat(sqrt(sum(normals.^2,2))',face_dim,1)';
0294     
0295  <a name="_sub10" href="#_subfunctions" class="code">function A = calc_face_area(mdl)</a>
0296 A = mdl.nodes(mdl.faces(:,2),:) - mdl.nodes(mdl.faces(:,1),:);
0297 B = mdl.nodes(mdl.faces(:,3),:) - mdl.nodes(mdl.faces(:,1),:);
0298 A = sqrt(sum(<a href="../../eidors/tools/cross3.html" class="code" title="function c = cross3(a,b)">cross3</a>(A,B).^2,2))/2;
0299 
0300 <a name="_sub11" href="#_subfunctions" class="code">function L = calc_edge_length(mdl)</a>
0301 L = sqrt(sum( (mdl.nodes(mdl.edges(:,1),:) <span class="keyword">...</span>
0302              - mdl.nodes(mdl.edges(:,2),:) ).^2 ,2 ));
0303     
0304 <a name="_sub12" href="#_subfunctions" class="code">function len = calc_longest_edge(elems,nodes)</a>
0305     [E_num E_dim] = size(elems);
0306 
0307     pairs = nchoosek(1:E_dim,2);
0308     len = zeros(E_num,1);
0309     <span class="keyword">for</span> i = 1:size(pairs,1)
0310         a = nodes(elems(:,pairs(i,1)),:);
0311         b = nodes(elems(:,pairs(i,2)),:);
0312         tmp = sqrt(sum((a-b).^2,2));
0313         len = max(len,tmp);  
0314     <span class="keyword">end</span>
0315     
0316 <a name="_sub13" href="#_subfunctions" class="code">function out = fix_options(mdl, opt)</a>
0317     out = <a href="#_sub14" class="code" title="subfunction out = list_options(val)">list_options</a>(false);
0318 <span class="comment">%     out.linear_reorder = 1;</span>
0319     flds = fieldnames(opt);
0320     <span class="keyword">for</span> i = 1:length(flds)
0321        <span class="keyword">try</span>
0322        out.(flds{i}) = opt.(flds{i});
0323        <span class="keyword">catch</span>
0324           warning(sprintf(<span class="string">'Option %s not recognised. Ignoring'</span>, flds{i}));
0325        <span class="keyword">end</span>
0326     <span class="keyword">end</span> 
0327     <span class="keyword">if</span> out.boundary_face
0328        out.face2elem = true;
0329     <span class="keyword">end</span>
0330     <span class="keyword">if</span> out.inner_normal
0331        out.normals = true;
0332        out.elem_centre = true;
0333        out.face_centre = true;
0334     <span class="keyword">end</span>
0335     <span class="keyword">if</span> any([ out.boundary_face out.face_centre out.normals]) &amp;&amp; ~isfield(mdl,<span class="string">'faces'</span>)
0336           out.faces = true;
0337     <span class="keyword">end</span>
0338     <span class="keyword">if</span> any([out.face2elem out.elem2face out.face_area])
0339        out.faces = true;
0340     <span class="keyword">end</span>
0341     <span class="keyword">if</span> any([out.edge2elem out.elem2edge out.edge_length out.face2edge])
0342         out.edges = true;
0343     <span class="keyword">end</span>
0344     <span class="keyword">if</span> out.edges &amp;&amp; <a href="elem_dim.html" class="code" title="function num = elem_dim( mdl );">elem_dim</a>(mdl) &lt; 4
0345         out.faces = true;
0346     <span class="keyword">end</span>
0347 
0348     
0349 <a name="_sub14" href="#_subfunctions" class="code">function out = list_options(val)</a>
0350     nodes = [0 0; 0 1; 1 1; 1 0];
0351     elems = [1 2 3; 1 3 4];
0352     mdl = <a href="../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>(<span class="string">'fwd_model'</span>,<span class="string">'square'</span>,<span class="string">'nodes'</span>, nodes, <span class="string">'elems'</span>, elems);
0353     out = <a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>(mdl);
0354     out = rmfield(out,{<span class="string">'elems'</span>,<span class="string">'nodes'</span>,<span class="string">'name'</span>,<span class="string">'type'</span>});
0355     flds = fieldnames(out);
0356     <span class="keyword">for</span> i = 1:length(flds)
0357        out.(flds{i}) = val;
0358     <span class="keyword">end</span>
0359     out.linear_reorder = 0;
0360     
0361 <a name="_sub15" href="#_subfunctions" class="code">function do_unit_test</a>
0362     <span class="comment">% square</span>
0363     nodes = [0 0; 0 1; 1 1; 1 0];
0364     elems = [1 2 3; 1 3 4];
0365     mdl = <a href="../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>(<span class="string">'fwd_model'</span>,<span class="string">'square'</span>,<span class="string">'nodes'</span>, nodes, <span class="string">'elems'</span>, elems);
0366     out = <a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>(mdl);
0367     <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'2d: faces'</span>    ,out.faces    ,[1,2;1,3;1,4;2,3;3,4]);
0368     <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'2d: elem2face'</span>,out.elem2face,[1,2,4;2,3,5]);
0369     <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'2d: face2elem'</span>,out.face2elem,[1,0;2,1;2,0;1,0;2,0]);
0370 
0371     <span class="comment">%cube</span>
0372     nodes = [0 0 0; 0 1 0; 1 1 0; 1 0 0;<span class="keyword">...</span>
0373              0 0 1; 0 1 1; 1 1 1; 1 0 1];
0374     elems = [1 2 3 6; 3 6 7 8; 1 5 6 8; 1 3 4 8; 1 3 6 8];
0375     mdl = <a href="../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>(<span class="string">'fwd_model'</span>,<span class="string">'cube'</span>,<span class="string">'nodes'</span>, nodes, <span class="string">'elems'</span>, elems);
0376     out = <a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>(mdl);
0377     <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'3d: faces'</span>    ,out.faces(1:4,:), [1,2,3;1,2,6;1,3,4;1,3,6]);
0378     <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'3d: elem2face'</span>,out.elem2face, [1,2,4,10; 12,13,14,16;
0379             7,8,9,15; 3,5,6,11; 4,5,9,13]);
0380     <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'3d: face2elem'</span>,out.face2elem(1:5,:), [1,0; 1,0; 4,0; 5,1; 4,5]);
0381 
0382     
0383     <span class="comment">% test options</span>
0384     opt = <a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>(<span class="string">'options'</span>,false);
0385     flds = fieldnames(opt);
0386     <span class="comment">% if there are no errors, option interdependence is dealt with</span>
0387     <span class="comment">% correctly</span>
0388     <span class="keyword">for</span> i = 1:length(flds)
0389        opt.(flds{i}) = true;
0390        out = <a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>(mdl, opt);
0391        opt.(flds{i}) = false;
0392     <span class="keyword">end</span>
0393     
0394     mdl = <a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'n3r2'</span>,[16,2]); mdl= mdl.fwd_model;
0395     out = <a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>(mdl);
0396</pre></div>
<hr><address>Generated on Fri 30-Dec-2022 20:46:51 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>
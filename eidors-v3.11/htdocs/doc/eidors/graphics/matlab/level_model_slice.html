<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of level_model_slice</title>
  <meta name="keywords" content="level_model_slice">
  <meta name="description" content="LEVEL_MODEL_SLICE - level 3D points for slicing at z=0">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">eidors</a> &gt; <a href="#">graphics</a> &gt; <a href="index.html">matlab</a> &gt; level_model_slice.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/graphics/matlab&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>level_model_slice
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>LEVEL_MODEL_SLICE - level 3D points for slicing at z=0</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [out, out2, out3] = level_model_slice(varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">LEVEL_MODEL_SLICE - level 3D points for slicing at z=0
 
 XYZ = LEVEL_MODEL_SLICE(NODES, LEVEL)
 XYZ = LEVEL_MODEL_SLICE(NODES, LEVEL, SN)
 Transforms a list of 3D points such that level is a slice at z=0.
    NODES: n_nodes x 3 list of point coordinates 
    LEVEL: definition of the slice(s). Can be:
     - scalar: number of slices along the z axis ordered max to min
     - vector (N x 3): intercepts with the coordinate axis
     - struct:
       .centre (N x 3): centre point for transformation
        .normal_angle (1 x 4) [nx, ny, nz, theta]: normal vector and angle 
          of rotation around the axis defined by it (right hand rule).
         The model will be rotated such that the normal vector becomes 
         [0,0,1].         
        .rotation_matrix (3 x 3)
        An error is thrown if both normal_angle and rotation_matrix are present.
   SN     : slice number to use if level defines multiple slices (default: 1).
    XYZ     : NODES transformed such that level is a slice at z=0.

 MDL = LEVEL_MODEL_SLICE(MDL,__) 
 Modifies the nodes of an EIDORS fwd_model structure MDL. Can be used in
 place of NODES with every other syntax.

 {XYZ} = LEVEL_MODEL_SLICE(MDL, LEVEL, 'all') 
 {XYZ} = LEVEL_MODEL_SLICE(NODES, LEVEL, 'all') 
 Returns a cell array (one per slice) of transformed NODES (or MDL.nodes).

 N = LEVEL_MODEL_SLICE(LEVEL) returns the number of slices defined in LEVEL.

 [C,M] = LEVEL_MODEL_SLICE(LEVEL, SN) (discouraged) returns the center C and
 rotation matrix M of slice SN (optional, default 1). An error is thrown if
 level is scalar. Note that two outputs must always be requested for this 
 syntax.  

 [C,M] = LEVEL_MODEL_SLICE(NODES, LEVEL, SN) (discouraged) allows to obtain C
 and M when LEVEL is scalar. Note that two outputs must always be requested for
 this syntax.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="level_model_slice.html" class="code" title="function [out, out2, out3] = level_model_slice(varargin)">level_model_slice</a>	LEVEL_MODEL_SLICE - level 3D points for slicing at z=0</li><li><a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="../../../eidors/overloads/vecnorm/vecnorm.html" class="code" title="function out = vecnorm(x, p, dim)">vecnorm</a>	Vectorwise norm: overload for matlab pre 2017b</li><li><a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>	UNIT_TEST_CMP: compare matrices in eidors output</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="calc_slices.html" class="code" title="function rimg = calc_slices( img, levels );">calc_slices</a>	calc_slices (img, levels, clim  ) show slices at levels of an</li><li><a href="level_model_slice.html" class="code" title="function [out, out2, out3] = level_model_slice(varargin)">level_model_slice</a>	LEVEL_MODEL_SLICE - level 3D points for slicing at z=0</li><li><a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype )">mdl_slice_mapper</a>	MDL_SLICE_MAPPER: map pixels to FEM elements or nodes</li><li><a href="mdl_slice_mesher.html" class="code" title="function [nimg out] = mdl_slice_mesher(fmdl,level,varargin)">mdl_slice_mesher</a>	MDL_SLICE_MESHER A slice of a 3D FEM as a 2D FEM</li><li><a href="../../../eidors/models/mk_pixel_slice.html" class="code" title="function [imdl fmdl] = mk_pixel_slice(imdl,level,opt)">mk_pixel_slice</a>	MK_PIXEL_SLICE create a pixel model to reconstruct on</li><li><a href="../../../eidors/models/place_elec_on_surf.html" class="code" title="function mdl2 = place_elec_on_surf(mdl,elec_pos, elec_spec,ng_opt_file, maxh)">place_elec_on_surf</a>	PLACE_ELEC_ON_SURF Place electrodes on the surface of a model</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function N = get_number_of_slices(level)</a></li><li><a href="#_sub2" class="code">function [C,M] = matrix_from_level(varargin)</a></li><li><a href="#_sub3" class="code">function [C, M] = matrix_from_number(nodes, num_levels, sn)</a></li><li><a href="#_sub4" class="code">function [C, M] = matrix_from_intercept(level, sn)</a></li><li><a href="#_sub5" class="code">function [C, M] = matrix_from_struct(level, sn)</a></li><li><a href="#_sub6" class="code">function do_unit_test</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [out, out2, out3] = level_model_slice(varargin)</a>
0002 <span class="comment">%LEVEL_MODEL_SLICE - level 3D points for slicing at z=0</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% XYZ = LEVEL_MODEL_SLICE(NODES, LEVEL)</span>
0005 <span class="comment">% XYZ = LEVEL_MODEL_SLICE(NODES, LEVEL, SN)</span>
0006 <span class="comment">% Transforms a list of 3D points such that level is a slice at z=0.</span>
0007 <span class="comment">%    NODES: n_nodes x 3 list of point coordinates</span>
0008 <span class="comment">%    LEVEL: definition of the slice(s). Can be:</span>
0009 <span class="comment">%     - scalar: number of slices along the z axis ordered max to min</span>
0010 <span class="comment">%     - vector (N x 3): intercepts with the coordinate axis</span>
0011 <span class="comment">%     - struct:</span>
0012 <span class="comment">%       .centre (N x 3): centre point for transformation</span>
0013 <span class="comment">%        .normal_angle (1 x 4) [nx, ny, nz, theta]: normal vector and angle</span>
0014 <span class="comment">%          of rotation around the axis defined by it (right hand rule).</span>
0015 <span class="comment">%         The model will be rotated such that the normal vector becomes</span>
0016 <span class="comment">%         [0,0,1].</span>
0017 <span class="comment">%        .rotation_matrix (3 x 3)</span>
0018 <span class="comment">%        An error is thrown if both normal_angle and rotation_matrix are present.</span>
0019 <span class="comment">%   SN     : slice number to use if level defines multiple slices (default: 1).</span>
0020 <span class="comment">%    XYZ     : NODES transformed such that level is a slice at z=0.</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% MDL = LEVEL_MODEL_SLICE(MDL,__)</span>
0023 <span class="comment">% Modifies the nodes of an EIDORS fwd_model structure MDL. Can be used in</span>
0024 <span class="comment">% place of NODES with every other syntax.</span>
0025 <span class="comment">%</span>
0026 <span class="comment">% {XYZ} = LEVEL_MODEL_SLICE(MDL, LEVEL, 'all')</span>
0027 <span class="comment">% {XYZ} = LEVEL_MODEL_SLICE(NODES, LEVEL, 'all')</span>
0028 <span class="comment">% Returns a cell array (one per slice) of transformed NODES (or MDL.nodes).</span>
0029 <span class="comment">%</span>
0030 <span class="comment">% N = LEVEL_MODEL_SLICE(LEVEL) returns the number of slices defined in LEVEL.</span>
0031 <span class="comment">%</span>
0032 <span class="comment">% [C,M] = LEVEL_MODEL_SLICE(LEVEL, SN) (discouraged) returns the center C and</span>
0033 <span class="comment">% rotation matrix M of slice SN (optional, default 1). An error is thrown if</span>
0034 <span class="comment">% level is scalar. Note that two outputs must always be requested for this</span>
0035 <span class="comment">% syntax.</span>
0036 <span class="comment">%</span>
0037 <span class="comment">% [C,M] = LEVEL_MODEL_SLICE(NODES, LEVEL, SN) (discouraged) allows to obtain C</span>
0038 <span class="comment">% and M when LEVEL is scalar. Note that two outputs must always be requested for</span>
0039 <span class="comment">% this syntax.</span>
0040 
0041 <span class="comment">% (C) 2006-2022 Andy Adler and Bartek Grychtol</span>
0042 <span class="comment">% License: GPL version 2 or version 3</span>
0043 <span class="comment">% $Id: level_model_slice.m 6350 2022-04-25 20:40:24Z bgrychtol $</span>
0044 
0045 <span class="keyword">if</span> nargin==1 &amp;&amp; ischar(varargin{1}) &amp;&amp; strcmp(varargin{1}, <span class="string">'UNIT_TEST'</span>)
0046   <a href="#_sub6" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>
0047 <span class="keyword">end</span>
0048 
0049 <span class="keyword">if</span> nargout == 1 || nargout == 3
0050     <span class="keyword">if</span> nargin == 1
0051         <span class="comment">% N = LEVEL_MODEL_SLICE(LEVEL) returns the number of slices defined in LEVEL</span>
0052         out = <a href="#_sub1" class="code" title="subfunction N = get_number_of_slices(level)">get_number_of_slices</a>(varargin{1});
0053     <span class="keyword">else</span>
0054         <span class="comment">% XYZ = LEVEL_MODEL_SLICE(NODES, LEVEL)</span>
0055         <span class="comment">% XYZ = LEVEL_MODEL_SLICE(NODES, LEVEL, SN)</span>
0056         <span class="keyword">if</span> nargin == 3 &amp;&amp; ischar(varargin{3}) &amp;&amp; strcmp(varargin{3},<span class="string">'all'</span>)
0057            n_slices = <a href="#_sub1" class="code" title="subfunction N = get_number_of_slices(level)">get_number_of_slices</a>(varargin{2});
0058            <span class="keyword">if</span> isstruct(varargin{1}), varargin{1}=varargin{1}.nodes; <span class="keyword">end</span>
0059            <span class="keyword">for</span> i = n_slices:-1:1
0060               out(i,1) = cell(1);
0061               [out{i,1}, C(i,:), M] = <a href="level_model_slice.html" class="code" title="function [out, out2, out3] = level_model_slice(varargin)">level_model_slice</a>(varargin{1},varargin{2}, i);
0062            <span class="keyword">end</span>
0063         <span class="keyword">else</span> <span class="comment">% nargin==3</span>
0064             [C, M] = <a href="#_sub2" class="code" title="subfunction [C,M] = matrix_from_level(varargin)">matrix_from_level</a>(varargin{:});
0065             SHIFT = [C(1), C(2), C(3)] * M';
0066             SHIFT(3) = 0;
0067             <span class="comment">% accept fwd_model as input</span>
0068             <span class="keyword">if</span> isstruct(varargin{1})
0069                out = varargin{1};
0070                <span class="comment">% (nodes - C) * M' + SHIFT</span>
0071                out.nodes = bsxfun(@plus, bsxfun(@minus, out.nodes, C ) * M', SHIFT);
0072             <span class="keyword">else</span>
0073                <span class="comment">% (nodes - C) * M' + SHIFT</span>
0074                out = bsxfun(@plus, bsxfun(@minus, varargin{1}, C ) * M', SHIFT);
0075             <span class="keyword">end</span>
0076             <span class="keyword">if</span> nargout == 3
0077                 out2 = C;
0078                 out3 = M;
0079             <span class="keyword">end</span>
0080         <span class="keyword">end</span>
0081     <span class="keyword">end</span>
0082 <span class="keyword">elseif</span> nargout == 2
0083     <span class="keyword">if</span> nargin &lt; 3
0084         <span class="comment">% [C,M] = LEVEL_MODEL_SLICE(LEVEL)</span>
0085         <span class="comment">% [C,M] = LEVEL_MODEL_SLICE(LEVEL, SN)</span>
0086         [out, out2] = <a href="#_sub2" class="code" title="subfunction [C,M] = matrix_from_level(varargin)">matrix_from_level</a>(varargin{:});
0087     <span class="keyword">else</span>
0088         <span class="comment">% [C,M] = LEVEL_MODEL_SLICE(NODES, LEVEL, SN)</span>
0089         [out, out2] = <a href="#_sub3" class="code" title="subfunction [C, M] = matrix_from_number(nodes, num_levels, sn)">matrix_from_number</a>(varargin{:});
0090     <span class="keyword">end</span>
0091 <span class="keyword">end</span>
0092 
0093 <a name="_sub1" href="#_subfunctions" class="code">function N = get_number_of_slices(level)  </a>
0094     <span class="keyword">if</span> isnumeric(level) &amp;&amp; isscalar(level)
0095         N = level;
0096     <span class="keyword">elseif</span> isnumeric(level)
0097         N = size(level,1);
0098     <span class="keyword">elseif</span> isstruct(level) &amp;&amp; isscalar(level)
0099         N = size(level.centre, 1);
0100     <span class="keyword">else</span>
0101         error(<span class="string">'level must be numeric or a scalar struct'</span>);
0102     <span class="keyword">end</span>
0103 
0104 <a name="_sub2" href="#_subfunctions" class="code">function [C,M] = matrix_from_level(varargin)</a>
0105     nodes = []; sn = 1;
0106     <span class="keyword">switch</span> nargin
0107         <span class="keyword">case</span> 3 <span class="comment">% nodes, level, sn</span>
0108             nodes = varargin{1}; level = varargin{2}; sn = varargin{3};
0109         <span class="keyword">case</span> 2 <span class="comment">% level &amp; sn or nodes &amp; level</span>
0110             <span class="keyword">if</span> isnumeric(varargin{2}) &amp;&amp; isscalar(varargin{2}) 
0111                 level = varargin{1}; sn = varargin{2};
0112             <span class="keyword">else</span>
0113                 nodes = varargin{1}; level = varargin{2};
0114             <span class="keyword">end</span>
0115         <span class="keyword">case</span> 1 <span class="comment">% level</span>
0116             level = varargin{1};
0117     <span class="keyword">end</span>
0118 
0119     <span class="keyword">if</span> isnumeric(level) &amp;&amp; isscalar(level)
0120         <span class="keyword">if</span> isempty(nodes)
0121             error(<span class="string">'Need nodes to calculate with scalar numeric level'</span>);
0122         <span class="keyword">else</span>
0123             [C, M] = <a href="#_sub3" class="code" title="subfunction [C, M] = matrix_from_number(nodes, num_levels, sn)">matrix_from_number</a>(nodes, level, sn);
0124         <span class="keyword">end</span>
0125     <span class="keyword">elseif</span> isnumeric(level)
0126         [C, M] = <a href="#_sub4" class="code" title="subfunction [C, M] = matrix_from_intercept(level, sn)">matrix_from_intercept</a>(level, sn);
0127     <span class="keyword">elseif</span> isstruct(level) &amp;&amp; isscalar(level)
0128         [C, M] = <a href="#_sub5" class="code" title="subfunction [C, M] = matrix_from_struct(level, sn)">matrix_from_struct</a>(level, sn);
0129     <span class="keyword">else</span>
0130         error(<span class="string">'level must be numeric or a scalar struct'</span>);
0131     <span class="keyword">end</span>
0132 
0133     
0134 <a name="_sub3" href="#_subfunctions" class="code">function [C, M] = matrix_from_number(nodes, num_levels, sn)</a>
0135     <span class="keyword">if</span> isstruct(nodes)
0136         nodes = nodes.nodes;
0137     <span class="keyword">end</span>
0138     M = diag([1,1,1]);
0139     
0140     zmax= max(nodes(:,3));
0141     zmin= min(nodes(:,3));
0142     levels = linspace(zmax,zmin, num_levels+2);
0143     levels = levels(2:end-1);
0144     
0145     C = (max(nodes) + min(nodes))/2;
0146     C(3) = levels(sn);
0147     
0148     
0149     
0150   
0151 <a name="_sub4" href="#_subfunctions" class="code">function [C, M] = matrix_from_intercept(level, sn)   </a>
0152    <span class="keyword">if</span> nargin &lt; 2
0153      sn = 1;
0154    <span class="keyword">end</span>
0155    level = level(sn, :);
0156    R = eye(3);
0157    <span class="keyword">if</span> length(level)==4
0158      theta = -level(4); <span class="comment">% we rotate the model, user thinks of the image</span>
0159      R = [cos(theta), -sin(theta), 0; sin(theta), cos(theta), 0; 0,0,1;];
0160    <span class="keyword">end</span>
0161    
0162    <span class="comment">% Infinities tend to cause issues -&gt; replace with realmax</span>
0163    <span class="comment">% Don't need to worry about the sign of the inf</span>
0164    level( isinf(level) | isnan(level) ) = realmax;
0165    level( level==0 ) =     1e-10; <span class="comment">%eps;</span>
0166 
0167    <span class="comment">% Step 1: Choose a centre point in the plane</span>
0168    <span class="comment">%  Weight the point by it's inv axis coords</span>
0169    invlev= 1./level;
0170    ctr= invlev / sum( invlev.^2 );
0171 
0172    <span class="comment">% Step 2: Choose basis vectors in the plane</span>
0173    <span class="comment">%  First is the axis furthest from ctr</span>
0174    [jnk, s_ax]= sort( - abs(level - ctr) );
0175    v1= [0,0,0]; v1(s_ax(1))= level(s_ax(1));
0176    v1= v1 - ctr;
0177    v1= v1 / norm(v1);
0178 
0179    <span class="comment">% Step 3: Get off-plane vector, by cross product</span>
0180    v2= [0,0,0]; v2(s_ax(2))= level(s_ax(2));
0181    v2= v2 - ctr;
0182    v2= v2 / norm(v2);
0183    v3= cross(v1,v2);
0184 
0185    <span class="comment">% Step 4: Get orthonormal basis. Replace v2</span>
0186    v2= cross(v1,v3);
0187 
0188    <span class="comment">% Step 5: Get bases to point in 'positive directions'</span>
0189    v1= v1 * (1-2*(sum(v1)&lt;0));
0190    v2= v2 * (1-2*(sum(v2)&lt;0));
0191    v3= v3 * (1-2*(sum(v3)&lt;0));
0192    
0193    C = ctr;
0194    M = R * [v1;v2;v3];
0195 <span class="comment">%   NODE= [v1;v2;v3] * (vtx' - ctr'*ones(1,nn) );</span>
0196   
0197     
0198 <a name="_sub5" href="#_subfunctions" class="code">function [C, M] = matrix_from_struct(level, sn)</a>
0199   <span class="keyword">if</span> nargin &lt; 2
0200     sn = 1;
0201   <span class="keyword">end</span>
0202   <span class="keyword">if</span> ~isfield(level,<span class="string">'centre'</span>)
0203       error(<span class="string">'Struct input ''level'' not understood.'</span>);
0204   <span class="keyword">end</span>
0205   ctr = level.centre;
0206   <span class="keyword">if</span> numel(ctr) == 3
0207       C = ctr; <span class="comment">% make row</span>
0208   <span class="keyword">elseif</span> size(ctr,2) == 3 &amp;&amp; size(ctr, 1) ~= 3
0209       C = ctr(:,sn);
0210   <span class="keyword">else</span>
0211       C = ctr(sn,:);
0212   <span class="keyword">end</span>
0213   C = C(:)'; <span class="comment">% make row</span>
0214   
0215   <span class="keyword">if</span> isfield(level, <span class="string">'rotation_matrix'</span>)
0216       M = level.rotation_matrix;
0217       <span class="keyword">return</span> <span class="comment">% no questions asked</span>
0218   <span class="keyword">end</span>
0219   
0220   <span class="keyword">if</span> isfield(level, <span class="string">'normal'</span>) &amp;&amp; ~isfield(level,<span class="string">'normal_angle'</span>)
0221       level.normal_angle = level.normal; <span class="comment">%quietly accept</span>
0222   <span class="keyword">end</span>
0223  
0224   <span class="keyword">if</span> ~isfield(level,<span class="string">'normal_angle'</span>)
0225       error(<span class="string">'Struct input ''level'' not understood.'</span>);
0226   <span class="keyword">end</span>
0227   
0228   A = level.normal_angle(1:3);
0229   normA = norm(A);
0230   <span class="keyword">if</span> normA == 0
0231     error(<span class="string">'Normal vector has zero norm'</span>)
0232   <span class="keyword">end</span>
0233   A = A(:) / normA; <span class="comment">% normalize and make column</span>
0234   B = [0,0,1]';
0235   R = eye(3);
0236   <span class="keyword">if</span> length(level.normal_angle) == 4
0237     theta = level.normal_angle(4);
0238     R = [cos(theta), -sin(theta), 0; sin(theta), cos(theta), 0; 0,0,1;];
0239   <span class="keyword">end</span>
0240    
0241   cross_AB = cross(A,B);
0242   <span class="keyword">if</span> norm(cross_AB) == 0 <span class="comment">% parallel vectors</span>
0243     <span class="keyword">if</span> A(3) &gt; 0
0244       M = R*eye(3);
0245     <span class="keyword">elseif</span> A(3) &lt; 0
0246       M = R*diag([1,-1,-1]);
0247     <span class="keyword">end</span>
0248     <span class="keyword">return</span>
0249   <span class="keyword">end</span>
0250   
0251   <span class="keyword">if</span> 0
0252       <span class="comment">% from https://math.stackexchange.com/questions/180418/</span>
0253       <span class="comment">% calculate-rotation-matrix-to-align-vector-a-to-vector-b-in-3d</span>
0254       <span class="comment">% works well, but leaves a rotation that's hard to control</span>
0255       dot_AB = A(3);
0256       ssc = @(v) [0 -v(3) v(2); v(3) 0 -v(1); -v(2) v(1) 0];
0257       M = eye(3) + ssc(cross_AB) + <span class="keyword">...</span>
0258           ssc(cross_AB)^2*(1-dot_AB)/(norm(cross_AB)^2);
0259   <span class="keyword">else</span>
0260       <span class="comment">% here we define a nice coordinate system on the plane, and then</span>
0261       <span class="comment">% transform it to become the identity (ie. invert).</span>
0262       
0263       <span class="comment">% project each coordinate axis on the plane</span>
0264       I = eye(3);
0265       <span class="keyword">for</span> i = 1:3
0266           proj(:,i) = I(:,i) - (dot(I(:,i),A) / normA^2) * A;
0267       <span class="keyword">end</span>
0268       norm_proj = <a href="../../../eidors/overloads/vecnorm/vecnorm.html" class="code" title="function out = vecnorm(x, p, dim)">vecnorm</a>(proj);
0269       max_norm = max(norm_proj);
0270       
0271       <span class="comment">% choose what happens based on which projection is longest</span>
0272       M = zeros(3);
0273       M(:,3) = A;
0274       <span class="keyword">if</span> norm_proj(3) == max_norm
0275           <span class="comment">% projection of z becomes y</span>
0276           M(:,2) = proj(:,3);
0277           M(:,1) = cross(M(:,2),M(:,3));
0278       <span class="keyword">elseif</span> norm_proj(2) == max_norm
0279           <span class="comment">% projection of y becomes y</span>
0280           M(:,2) = proj(:,2);
0281           M(:,1) = cross(M(:,2),M(:,3));
0282       <span class="keyword">else</span>
0283           <span class="comment">% projection of x becomes x</span>
0284           M(:,1) = proj(:,1);
0285           M(:,2) = cross(M(:,3),M(:,1));
0286       <span class="keyword">end</span>
0287       M = inv(M);  
0288   <span class="keyword">end</span>
0289   M = R*M ;  
0290   
0291 
0292   
0293 <a name="_sub6" href="#_subfunctions" class="code">function do_unit_test</a>
0294   <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Scalar level'</span>, <a href="level_model_slice.html" class="code" title="function [out, out2, out3] = level_model_slice(varargin)">level_model_slice</a>(5),5);
0295   <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Vector level'</span>, <a href="level_model_slice.html" class="code" title="function [out, out2, out3] = level_model_slice(varargin)">level_model_slice</a>([inf, inf, 3]),1);
0296   <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Matrix level'</span>, <a href="level_model_slice.html" class="code" title="function [out, out2, out3] = level_model_slice(varargin)">level_model_slice</a>([inf, inf, 3; inf, inf, 5]),2);
0297   LVL = [inf, inf, 3; inf, inf, 5];
0298   LVL(:,4) = rand(1,2);
0299   <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Matrix level angle'</span>, <a href="level_model_slice.html" class="code" title="function [out, out2, out3] = level_model_slice(varargin)">level_model_slice</a>(LVL),2);
0300   lvl.centre = [ 0,0,0];
0301   <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Struct level'</span>, <a href="level_model_slice.html" class="code" title="function [out, out2, out3] = level_model_slice(varargin)">level_model_slice</a>(lvl),1);
0302   lvl.centre(2,:) = [0,0,3];
0303   <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Struct level'</span>, <a href="level_model_slice.html" class="code" title="function [out, out2, out3] = level_model_slice(varargin)">level_model_slice</a>(lvl),2);
0304   lvl.normal_angle = rand(3,1)-.5;
0305   lvl.normal_angle = lvl.normal_angle / norm(lvl.normal_angle);
0306   lvl.normal_angle(4) = 2*pi * rand(1);
0307   [C, M] = <a href="level_model_slice.html" class="code" title="function [out, out2, out3] = level_model_slice(varargin)">level_model_slice</a>(lvl);
0308   <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Normal -&gt; Matrix'</span>, M*lvl.normal_angle(1:3),[0,0,1]', 5*eps);
0309   [C, M] = <a href="level_model_slice.html" class="code" title="function [out, out2, out3] = level_model_slice(varargin)">level_model_slice</a>([inf 5 inf]);
0310   lvl.normal_angle = [0,0,-1];
0311   [C, M] = <a href="level_model_slice.html" class="code" title="function [out, out2, out3] = level_model_slice(varargin)">level_model_slice</a>(lvl);
0312   <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Parallel normal'</span>, M,diag([1,-1,-1]));
0313   
0314   lvl.normal_angle = [0,0,0];
0315   <span class="keyword">try</span>
0316     [C, M] = <a href="level_model_slice.html" class="code" title="function [out, out2, out3] = level_model_slice(varargin)">level_model_slice</a>(lvl);
0317     fprintf(<span class="string">'TEST: %20s = %4s \n'</span>,<span class="string">'Expect error'</span>, <span class="string">'Fail'</span>);  
0318   <span class="keyword">catch</span>
0319     fprintf(<span class="string">'TEST: %20s = %4s \n'</span>,<span class="string">'Expect error'</span>, <span class="string">'OK'</span>); 
0320   <span class="keyword">end</span>
0321   imdl = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'n3r2'</span>,[16,2]); fmdl = imdl.fwd_model;
0322   nodes = <a href="level_model_slice.html" class="code" title="function [out, out2, out3] = level_model_slice(varargin)">level_model_slice</a>(fmdl,[inf, inf, 1; inf, inf, 2],1);</pre></div>
<hr><address>Generated on Fri 30-Dec-2022 20:46:51 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of mdl_slice_mapper</title>
  <meta name="keywords" content="mdl_slice_mapper">
  <meta name="description" content="MDL_SLICE_MAPPER: map pixels to FEM elements or nodes">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">eidors</a> &gt; <a href="#">graphics</a> &gt; <a href="index.html">matlab</a> &gt; mdl_slice_mapper.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/graphics/matlab&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>mdl_slice_mapper
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>MDL_SLICE_MAPPER: map pixels to FEM elements or nodes</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function map = mdl_slice_mapper( fmdl, maptype ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> MDL_SLICE_MAPPER: map pixels to FEM elements or nodes
    map = mdl_slice_mapper( fmdl, maptype );

 USAGE:
 fmdl = fwd_model object
     required fields
   fmdl.mdl_slice_mapper.npx   - number of points in horizontal direction
   fmdl.mdl_slice_mapper.npy   - number of points in vertical 
    or
   fmdl.mdl_slice_mapper.x_pts - vector of points in horizontal direction
   fmdl.mdl_slice_mapper.y_pts - vector of points in vertical
     x_pts starts at the left, and y_pts starts at the top, this means
     that y_pts normally would run from max to min
    or
   fmdl.mdl_slice_mapper.npoints    - number of points across the larger
                                      dimension of the model (square)
    or
   fmdl.mdl_slice_mapper.resolution - number of points per unit
   
   fmdl.mdl_slice_mapper.level - any definition accepted by
          LEVEL_MODEL_SLICE for a single slice
   OR (deprecated)
   fmdl.mdl_slice_mapper.centre and .rotate
          are the centre point and rotation matrices around the point

      Optional fields
   fmdl.mdl_slice_mapper.model_2d - indicate a 2D model in 3D space.

 maptype
    for 'elem' map is FEM element nearest the point
    for 'node' map is FEM vertex nearest the point
    for 'nodeinterp' map a npx x npy x (Nd+1) matrix such that for each point i,j
       the nearby nodes are weighted with the corresponding element in the map(i,j).
    for 'get_points' map contains the x an y vectors of points used for
       for mapping as {x, y}. No mapping is performed.


 See also <a href="level_model_slice.html" class="code" title="function [out, out2, out3] = level_model_slice(varargin)">LEVEL_MODEL_SLICE</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG eidors progress and status messages</li><li><a href="../../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>	EIDORS_OBJ: maintains EIDORS internals</li><li><a href="level_model_slice.html" class="code" title="function [out, out2, out3] = level_model_slice(varargin)">level_model_slice</a>	LEVEL_MODEL_SLICE - level 3D points for slicing at z=0</li><li><a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype )">mdl_slice_mapper</a>	MDL_SLICE_MAPPER: map pixels to FEM elements or nodes</li><li><a href="mdl_slice_mesher.html" class="code" title="function [nimg out] = mdl_slice_mesher(fmdl,level,varargin)">mdl_slice_mesher</a>	MDL_SLICE_MESHER A slice of a 3D FEM as a 2D FEM</li><li><a href="show_3d_slices.html" class="code" title="function h = show_3d_slices(img, varargin);">show_3d_slices</a>	show_3d_slices(img, z_cuts, x_cuts, y_cuts, any_cuts)</li><li><a href="show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>	SHOW_FEM: show the EIDORS3D finite element model</li><li><a href="show_slices.html" class="code" title="function out_img= show_slices( img, levels, vh )">show_slices</a>	out_img = show_slices (img, levels ) show slices at levels of an</li><li><a href="../../../eidors/models/mdl_dim.html" class="code" title="function num = mdl_dim( mdl );">mdl_dim</a>	MDL_DIM: dimension of model space (are nodes in 2D or 3D space)</li><li><a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>	MK_IMAGE: create eidors image object</li><li><a href="../../../eidors/solvers/forward/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>	[srf, idx] = find_boundary(simp);</li><li><a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>	FWD_SOLVE: calculate data from a fwd_model object and an image</li><li><a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>	EIDORS_CACHE Control eidors caching</li><li><a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>	UNIT_TEST_CMP: compare matrices in eidors output</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="calc_slices.html" class="code" title="function rimg = calc_slices( img, levels );">calc_slices</a>	calc_slices (img, levels, clim  ) show slices at levels of an</li><li><a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype )">mdl_slice_mapper</a>	MDL_SLICE_MAPPER: map pixels to FEM elements or nodes</li><li><a href="show_current.html" class="code" title="function quiv = show_current( img, vv )">show_current</a>	SHOW_CURRENT: show current or other quantity defined</li><li><a href="show_slices.html" class="code" title="function out_img= show_slices( img, levels, vh )">show_slices</a>	out_img = show_slices (img, levels ) show slices at levels of an</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function map = do_mdl_slice_mapper(fmdl, maptype)</a></li><li><a href="#_sub2" class="code">function elem_ptr = mdl_elem_mapper(NODE, ELEM, x, y)</a></li><li><a href="#_sub3" class="code">function val = use_triangulation</a></li><li><a href="#_sub4" class="code">function ninterp_ptr = mdl_nodeinterp_mapper(NODE, ELEM, x, y)</a></li><li><a href="#_sub5" class="code">function ninterp_ptr = mdl_nodeinterp_mapper_triangulation(NODE, ELEM, x, y)</a></li><li><a href="#_sub6" class="code">function node_ptr = mdl_node_mapper(NODE, ELEM, bnd, x, y)</a></li><li><a href="#_sub7" class="code">function node_ptr = node_mapper_dsearchn( NODE, ELEM, x, y)</a></li><li><a href="#_sub8" class="code">function node_ptr = node_mapper_triangulation( NODE, ELEM, x, y)</a></li><li><a href="#_sub9" class="code">function NPTR= node_mapper( NODE, ELEM, bdy, x, y);</a></li><li><a href="#_sub10" class="code">function EPTR= img_mapper2(NODE, ELEM, x, y );</a></li><li><a href="#_sub11" class="code">function EPTR= img_mapper2_old(NODE, ELEM, x, y );</a></li><li><a href="#_sub12" class="code">function EPTR= img_mapper2a(NODE, ELEM, npx, npy );</a></li><li><a href="#_sub13" class="code">function EPTR= img_mapper3(NODE, ELEM, x, y );</a></li><li><a href="#_sub14" class="code">function EPTR= img_mapper3_old(NODE, ELEM, x, y );</a></li><li><a href="#_sub15" class="code">function [NODE, ELEM, use_nodes, use_elem] = limit_3dmodel_to_slice(NODE,ELEM)</a></li><li><a href="#_sub16" class="code">function [img2d, use_nodes] = mdl_3d_to_2d(NODE, ELEM)</a></li><li><a href="#_sub17" class="code">function [NODE, ELEM] = level_model( fwd_model )</a></li><li><a href="#_sub18" class="code">function pts = get_points(fwd_model);</a></li><li><a href="#_sub19" class="code">function  [x,y] = grid_the_space( fmdl, flag);</a></li><li><a href="#_sub20" class="code">function do_unit_test</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function map = mdl_slice_mapper( fmdl, maptype )</a>
0002 <span class="comment">% MDL_SLICE_MAPPER: map pixels to FEM elements or nodes</span>
0003 <span class="comment">%    map = mdl_slice_mapper( fmdl, maptype );</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% USAGE:</span>
0006 <span class="comment">% fmdl = fwd_model object</span>
0007 <span class="comment">%     required fields</span>
0008 <span class="comment">%   fmdl.mdl_slice_mapper.npx   - number of points in horizontal direction</span>
0009 <span class="comment">%   fmdl.mdl_slice_mapper.npy   - number of points in vertical</span>
0010 <span class="comment">%    or</span>
0011 <span class="comment">%   fmdl.mdl_slice_mapper.x_pts - vector of points in horizontal direction</span>
0012 <span class="comment">%   fmdl.mdl_slice_mapper.y_pts - vector of points in vertical</span>
0013 <span class="comment">%     x_pts starts at the left, and y_pts starts at the top, this means</span>
0014 <span class="comment">%     that y_pts normally would run from max to min</span>
0015 <span class="comment">%    or</span>
0016 <span class="comment">%   fmdl.mdl_slice_mapper.npoints    - number of points across the larger</span>
0017 <span class="comment">%                                      dimension of the model (square)</span>
0018 <span class="comment">%    or</span>
0019 <span class="comment">%   fmdl.mdl_slice_mapper.resolution - number of points per unit</span>
0020 <span class="comment">%</span>
0021 <span class="comment">%   fmdl.mdl_slice_mapper.level - any definition accepted by</span>
0022 <span class="comment">%          LEVEL_MODEL_SLICE for a single slice</span>
0023 <span class="comment">%   OR (deprecated)</span>
0024 <span class="comment">%   fmdl.mdl_slice_mapper.centre and .rotate</span>
0025 <span class="comment">%          are the centre point and rotation matrices around the point</span>
0026 <span class="comment">%</span>
0027 <span class="comment">%      Optional fields</span>
0028 <span class="comment">%   fmdl.mdl_slice_mapper.model_2d - indicate a 2D model in 3D space.</span>
0029 <span class="comment">%</span>
0030 <span class="comment">% maptype</span>
0031 <span class="comment">%    for 'elem' map is FEM element nearest the point</span>
0032 <span class="comment">%    for 'node' map is FEM vertex nearest the point</span>
0033 <span class="comment">%    for 'nodeinterp' map a npx x npy x (Nd+1) matrix such that for each point i,j</span>
0034 <span class="comment">%       the nearby nodes are weighted with the corresponding element in the map(i,j).</span>
0035 <span class="comment">%    for 'get_points' map contains the x an y vectors of points used for</span>
0036 <span class="comment">%       for mapping as {x, y}. No mapping is performed.</span>
0037 <span class="comment">%</span>
0038 <span class="comment">%</span>
0039 <span class="comment">% See also LEVEL_MODEL_SLICE</span>
0040 
0041 <span class="comment">% (C) 2006-2022 Andy Adler and Bartek Grychtol.</span>
0042 <span class="comment">% License: GPL version 2 or version 3</span>
0043 <span class="comment">% $Id: mdl_slice_mapper.m 6513 2022-12-30 19:20:08Z aadler $</span>
0044 
0045 <span class="keyword">if</span> ischar(fmdl) &amp;&amp; strcmp(fmdl,<span class="string">'UNIT_TEST'</span>); <a href="#_sub20" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0046 
0047 <span class="keyword">if</span> nargin &lt; 3, lev_no = 1; <span class="keyword">end</span>
0048 
0049 copt.log_level = 4;
0050 params = {fmdl, maptype};
0051 copt.cache_obj = {fmdl.nodes, fmdl.elems, fmdl.mdl_slice_mapper, maptype};
0052 copt.fstr = <span class="string">'mdl_slice_mapper'</span>;
0053 <span class="keyword">switch</span> maptype
0054    <span class="keyword">case</span> {<span class="string">'elem'</span>, <span class="string">'node'</span>, <span class="string">'nodeinterp'</span>}
0055       map = <a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub1" class="code" title="subfunction map = do_mdl_slice_mapper(fmdl, maptype)">do_mdl_slice_mapper</a>,      params, copt);
0056    <span class="keyword">case</span> <span class="string">'get_points'</span>
0057       map = <a href="#_sub18" class="code" title="subfunction pts = get_points(fwd_model);">get_points</a>(fmdl);  
0058    <span class="keyword">otherwise</span>
0059       error(<span class="string">'expecting maptype = elem or node'</span>);
0060 <span class="keyword">end</span>
0061 
0062 <a name="_sub1" href="#_subfunctions" class="code">function map = do_mdl_slice_mapper(fmdl, maptype)</a>
0063 
0064     [NODE, ELEM] = <a href="#_sub17" class="code" title="subfunction [NODE, ELEM] = level_model( fwd_model )">level_model</a>( fmdl);
0065     <span class="keyword">if</span> isfield(fmdl.mdl_slice_mapper,<span class="string">'model_2d'</span>) &amp;&amp; <span class="keyword">...</span>
0066           fmdl.mdl_slice_mapper.model_2d &amp;&amp; <span class="keyword">...</span>
0067           size(fmdl.nodes,2) == 3
0068        NODE(3,:) = [];
0069     <span class="keyword">end</span>
0070     fmdl.nodes = NODE';
0071     [x, y] = <a href="#_sub19" class="code" title="subfunction  [x,y] = grid_the_space( fmdl, flag);">grid_the_space</a>( fmdl);
0072    
0073     <span class="keyword">switch</span> maptype
0074        <span class="keyword">case</span> <span class="string">'elem'</span>
0075           map = <a href="#_sub2" class="code" title="subfunction elem_ptr = mdl_elem_mapper(NODE, ELEM, x, y)">mdl_elem_mapper</a>(NODE, ELEM, x, y);
0076        <span class="keyword">case</span> <span class="string">'node'</span>
0077           bnd = [];
0078           <span class="keyword">try</span> bnd = fmdl.boundary; <span class="keyword">end</span>
0079           map = <a href="#_sub6" class="code" title="subfunction node_ptr = mdl_node_mapper(NODE, ELEM, bnd, x, y)">mdl_node_mapper</a>(NODE, ELEM, bnd, x, y);
0080        <span class="keyword">case</span> <span class="string">'nodeinterp'</span>
0081           map = <a href="#_sub4" class="code" title="subfunction ninterp_ptr = mdl_nodeinterp_mapper(NODE, ELEM, x, y)">mdl_nodeinterp_mapper</a>(NODE, ELEM, x, y);
0082     <span class="keyword">end</span>
0083 
0084 <a name="_sub2" href="#_subfunctions" class="code">function elem_ptr = mdl_elem_mapper(NODE, ELEM, x, y)</a>
0085    <span class="keyword">if</span> size(NODE,1) ==2 <span class="comment">%2D</span>
0086       elem_ptr= <a href="#_sub10" class="code" title="subfunction EPTR= img_mapper2(NODE, ELEM, x, y );">img_mapper2</a>( NODE, ELEM, x, y);
0087    <span class="keyword">else</span>
0088       elem_ptr= <a href="#_sub13" class="code" title="subfunction EPTR= img_mapper3(NODE, ELEM, x, y );">img_mapper3</a>( NODE, ELEM, x, y);
0089    <span class="keyword">end</span>
0090 
0091 <a name="_sub3" href="#_subfunctions" class="code">function val = use_triangulation</a>
0092    ver = <a href="../../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>(<span class="string">'interpreter_version'</span>);
0093    val = ~ver.isoctave &amp;&amp; ver.ver &gt;= 9.013; <span class="comment">% pointLocation was slow/buggy before</span>
0094    
0095    
0096 <a name="_sub4" href="#_subfunctions" class="code">function ninterp_ptr = mdl_nodeinterp_mapper(NODE, ELEM, x, y)</a>
0097    <span class="keyword">if</span> <a href="#_sub3" class="code" title="subfunction val = use_triangulation">use_triangulation</a>
0098      ninterp_ptr = <a href="#_sub5" class="code" title="subfunction ninterp_ptr = mdl_nodeinterp_mapper_triangulation(NODE, ELEM, x, y)">mdl_nodeinterp_mapper_triangulation</a>( <span class="keyword">...</span>
0099         double(NODE), double(ELEM), x, y);
0100      <span class="keyword">return</span>
0101    <span class="keyword">end</span>
0102    elem_ptr = <a href="#_sub2" class="code" title="subfunction elem_ptr = mdl_elem_mapper(NODE, ELEM, x, y)">mdl_elem_mapper</a>(NODE, ELEM, x, y);
0103    
0104    ndims = size(NODE,1);
0105    <span class="keyword">if</span>  ndims == 2;  NODEz = []; <span class="keyword">else</span>; NODEz= 0; <span class="keyword">end</span>
0106    ninterp_ptr = zeros(length(x(:)),ndims+1); <span class="comment">% reshape later</span>
0107    
0108    elems = ELEM';
0109    <span class="keyword">for</span> i= find( elem_ptr(:)&gt;0 )' <span class="comment">% look for all x,y inside elements</span>
0110      nodes_i = elems(elem_ptr(i),:);
0111      ninterp_ptr(i,:) = ( [ones(1,ndims+1);NODE(:,nodes_i)] \ [1;x(i);y(i);NODEz] )';
0112    <span class="keyword">end</span>
0113    ninterp_ptr = reshape( ninterp_ptr, size(x,1), size(x,2), ndims + 1);
0114 
0115 <a name="_sub5" href="#_subfunctions" class="code">function ninterp_ptr = mdl_nodeinterp_mapper_triangulation(NODE, ELEM, x, y)</a>
0116    ndims = size(NODE,1);
0117    pts = [x(:),y(:)];
0118    <span class="keyword">if</span> size(NODE,1) == 3, pts(:,3) = 0; <span class="keyword">end</span>
0119       
0120    s = warning(<span class="string">'off'</span>, <span class="string">'MATLAB:triangulation:PtsNotInTriWarnId'</span>);
0121    TR = triangulation(ELEM', NODE');
0122    warning(s.state, <span class="string">'MATLAB:triangulation:PtsNotInTriWarnId'</span>);
0123    [el, bc] =   TR.pointLocation(pts);
0124    bc(isnan(el),:) = 0;
0125    ninterp_ptr = reshape(bc,size(x,1), size(x,2), ndims + 1);
0126    
0127 <a name="_sub6" href="#_subfunctions" class="code">function node_ptr = mdl_node_mapper(NODE, ELEM, bnd, x, y)</a>
0128 
0129    <span class="keyword">if</span> <a href="#_sub3" class="code" title="subfunction val = use_triangulation">use_triangulation</a>
0130        node_ptr = <a href="#_sub8" class="code" title="subfunction node_ptr = node_mapper_triangulation( NODE, ELEM, x, y)">node_mapper_triangulation</a>( NODE, ELEM, x, y);
0131    <span class="keyword">else</span>
0132        ndims = size(NODE,1);
0133        <span class="keyword">if</span> ndims == 2
0134          <span class="comment">% old code</span>
0135          <span class="keyword">if</span> isempty(bnd), bnd = <a href="../../../eidors/solvers/forward/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>(ELEM'); <span class="keyword">end</span>
0136          node_ptr= <a href="#_sub9" class="code" title="subfunction NPTR= node_mapper( NODE, ELEM, bdy, x, y);">node_mapper</a>( NODE, ELEM, bnd, x, y);
0137        <span class="keyword">else</span>
0138          node_ptr= <a href="#_sub7" class="code" title="subfunction node_ptr = node_mapper_dsearchn( NODE, ELEM, x, y)">node_mapper_dsearchn</a>( NODE, ELEM, x, y);
0139        <span class="keyword">end</span>
0140    <span class="keyword">end</span>
0141    
0142 <span class="comment">% in 3D this is somewhat faster in matlab. Perfomance in octave varies with size</span>
0143 <a name="_sub7" href="#_subfunctions" class="code">function node_ptr = node_mapper_dsearchn( NODE, ELEM, x, y)</a>
0144    <span class="keyword">if</span> size(NODE,1) == 2
0145       node_ptr = dsearchn(NODE', ELEM', [x(:),y(:)], 0);
0146    <span class="keyword">else</span>
0147       pts = [x(:),y(:)];
0148       pts(:,3) = 0;
0149       [NODE, ELEM, use_nodes] = <a href="#_sub15" class="code" title="subfunction [NODE, ELEM, use_nodes, use_elem] = limit_3dmodel_to_slice(NODE,ELEM)">limit_3dmodel_to_slice</a>(NODE,ELEM);
0150       node_ptr = dsearchn(NODE', ELEM', pts , 0);
0151       in = node_ptr&gt;0;
0152       node_ptr(in) = use_nodes(node_ptr(in));
0153    <span class="keyword">end</span>
0154    node_ptr = reshape(node_ptr, size(x));
0155    
0156 <a name="_sub8" href="#_subfunctions" class="code">function node_ptr = node_mapper_triangulation( NODE, ELEM, x, y)</a>
0157     s = warning(<span class="string">'off'</span>, <span class="string">'MATLAB:triangulation:PtsNotInTriWarnId'</span>);
0158     TR = triangulation(ELEM', NODE');
0159     warning(s.state, <span class="string">'MATLAB:triangulation:PtsNotInTriWarnId'</span>);
0160     pts = [x(:), y(:)];
0161     <span class="keyword">if</span> size(NODE,1) == 3
0162         pts(:,3) = 0;
0163     <span class="keyword">end</span>
0164     id = TR.pointLocation(pts);
0165     in = ~isnan(id);
0166     node_ptr = zeros(size(in));
0167     node_ptr(in) = TR.nearestNeighbor(pts(in,:));
0168     node_ptr = reshape(node_ptr, size(x));
0169     
0170 
0171    
0172 <span class="comment">% Search through each element and find the points which</span>
0173 <span class="comment">% are in that element</span>
0174 <span class="comment">% NPTR is matrix npx x npy with a pointer to the</span>
0175 <span class="comment">% node closest to it.</span>
0176 <a name="_sub9" href="#_subfunctions" class="code">function NPTR= node_mapper( NODE, ELEM, bdy, x, y);</a>
0177   [npy,npx] = size(x);
0178 
0179   NODEx= NODE(1,:);
0180   NODEy= NODE(2,:);
0181   <span class="keyword">if</span> size(NODE,1) == 2
0182      NODEz2= 0;
0183      bdy= unique(bdy(:));
0184      in = inpolygon(x(:),y(:),NODE(1,bdy)',NODE(2,bdy)');
0185   <span class="keyword">else</span>
0186      NODEz2= NODE(3,:).^2;
0187      <span class="comment">% This is a slow way to get the elems outside the space, but I don't see another</span>
0188      EPTR= <a href="#_sub13" class="code" title="subfunction EPTR= img_mapper3(NODE, ELEM, x, y );">img_mapper3</a>(NODE, ELEM, x, y );
0189      in = EPTR&gt;0;
0190   <span class="keyword">end</span>
0191   NPTR=zeros(npy,npx);
0192 
0193 <span class="comment">% This next operation can be vectorized, but we don't</span>
0194 <span class="comment">%  do it because that can make really big matrices</span>
0195 
0196   <span class="keyword">for</span> i= 1: npy
0197      <span class="keyword">for</span> j= 1: npx
0198         dist2 = (NODEx-x(i,j)).^2 + (NODEy-y(i,j)).^2 + NODEz2;
0199         [~, ff] = min(dist2);
0200         NPTR(i,j) = ff;
0201      <span class="keyword">end</span>
0202   <span class="keyword">end</span>
0203   NPTR(~in)= 0; <span class="comment">% outside</span>
0204 
0205 <span class="comment">% Search through each element and find the points which</span>
0206 <span class="comment">% are in that element</span>
0207 <span class="comment">% EPTR is matrix npx x npy with a pointer to the</span>
0208 <span class="comment">% element which contains it.</span>
0209 <a name="_sub10" href="#_subfunctions" class="code">function EPTR= img_mapper2(NODE, ELEM, x, y );</a>
0210   ver = <a href="../../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>(<span class="string">'interpreter_version'</span>);
0211   <span class="keyword">if</span> ver.isoctave
0212     id = tsearch(NODE(1,:),NODE(2,:), ELEM', x(:),y(:));
0213   <span class="keyword">else</span>
0214     <span class="keyword">if</span> <a href="#_sub3" class="code" title="subfunction val = use_triangulation">use_triangulation</a> 
0215        s = warning(<span class="string">'off'</span>, <span class="string">'MATLAB:triangulation:PtsNotInTriWarnId'</span>);
0216        TR = triangulation(ELEM', NODE');
0217        warning(s.state, <span class="string">'MATLAB:triangulation:PtsNotInTriWarnId'</span>);
0218        id = TR.pointLocation([x(:), y(:)]);
0219     <span class="keyword">else</span>
0220        EPTR = <a href="#_sub11" class="code" title="subfunction EPTR= img_mapper2_old(NODE, ELEM, x, y );">img_mapper2_old</a>(NODE, ELEM, x, y );
0221        <span class="keyword">return</span>
0222     <span class="keyword">end</span>
0223   <span class="keyword">end</span>
0224   id(isnan(id)) = 0;
0225   EPTR = reshape(id,size(x));
0226 
0227 <span class="comment">% Search through each element and find the points which</span>
0228 <span class="comment">% are in that element</span>
0229 <span class="comment">% EPTR is matrix npx x npy with a pointer to the</span>
0230 <span class="comment">% element which contains it.</span>
0231 <a name="_sub11" href="#_subfunctions" class="code">function EPTR= img_mapper2_old(NODE, ELEM, x, y );</a>
0232   [npy,npx] = size(x);
0233   v_yx= [-y(:),x(:)];
0234   turn= [0 -1 1;1 0 -1;-1 1 0];
0235   EPTR=zeros(npy,npx);
0236   <span class="comment">% for each element j, we get points on the simplex a,b,c</span>
0237   <span class="comment">%   area A = abc</span>
0238   <span class="comment">%   for each candidate point d,</span>
0239   <span class="comment">%      area AA = abd + acd + bcd</span>
0240   <span class="comment">%      d is in j if AA = A</span>
0241   <span class="keyword">for</span> j= 1: size(ELEM,2)
0242     <span class="comment">% calculate area of three subtrianges to each candidate point.</span>
0243     xy= NODE(:,ELEM(:,j))';
0244     <span class="comment">% come up with a limited set of candidate points which</span>
0245     <span class="comment">% may be within the simplex</span>
0246     endr=find( y(:)&lt;=max(xy(:,2)) &amp; y(:)&gt;=min(xy(:,2)) <span class="keyword">...</span>
0247              &amp; x(:)&lt;=max(xy(:,1)) &amp; x(:)&gt;=min(xy(:,1)) );
0248     <span class="comment">% a is determinant of matrix [i,j,k, xy]</span>
0249     a= xy([2;3;1],1).*xy([3;1;2],2)- xy([3;1;2],1).*xy([2;3;1],2);
0250 
0251     aa= sum(abs(ones(length(endr),1)*a'+ <span class="keyword">...</span>
0252                 v_yx(endr,:)*xy'*turn)');
0253     endr( abs( (abs(sum(a))-aa) ./ sum(a)) &gt;1e-8)=[];
0254     EPTR(endr)= j;
0255   <span class="keyword">end</span> <span class="comment">%for j=1:ELEM</span>
0256   
0257   
0258 <span class="comment">% 2D mapper of points to elements. First, we assume that</span>
0259 <span class="comment">% The vertex geometry (NODE) has been rotated and translated</span>
0260 <span class="comment">% so that the imaging plane is on the z-axis. Then we iterate</span>
0261 <span class="comment">% through elements to find the containing each pixel</span>
0262 <a name="_sub12" href="#_subfunctions" class="code">function EPTR= img_mapper2a(NODE, ELEM, npx, npy );</a>
0263   [x,y] = <a href="#_sub19" class="code" title="subfunction  [x,y] = grid_the_space( fmdl, flag);">grid_the_space</a>(npx, npy);
0264 
0265   EPTR=zeros(npy,npx);
0266   <span class="comment">% for each element j, we get points on the simplex a,b,c</span>
0267   <span class="comment">%   area A = abc</span>
0268   <span class="comment">%   for each candidate point d,</span>
0269   <span class="comment">%      area AA = abd + acd + bcd</span>
0270   <span class="comment">%      d is in j if AA = A</span>
0271   <span class="keyword">for</span> j= 1: size(ELEM,2)
0272     xyz= NODE(:,ELEM(:,j))';
0273     min_x= min(xyz(:,1)); max_x= max(xyz(:,1));
0274     min_y= min(xyz(:,2)); max_y= max(xyz(:,2));
0275 
0276     <span class="comment">% Simplex volume is det([v2-v1,v3-v1, ...])</span>
0277     VOL= abs(det(xyz'*[-1,1,0;-1,0,1]'));
0278 
0279     <span class="comment">% come up with a limited set of candidate points which</span>
0280     <span class="comment">% may be within the simplex</span>
0281     endr=find( y(:)&lt;=max_y &amp; y(:)&gt;=min_y <span class="keyword">...</span>
0282              &amp; x(:)&lt;=max_x &amp; x(:)&gt;=min_x );
0283 
0284     nn=  size(ELEM,1); <span class="comment">%Simplex vertices</span>
0285     ll=  length(endr);
0286     vol=zeros(ll,nn);
0287     <span class="keyword">for</span> i=1:nn
0288        i1= i; i2= rem(i,nn)+1;
0289        x1= xyz(i1,1) - x(endr);
0290        y1= xyz(i1,2) - y(endr);
0291        x2= xyz(i2,1) - x(endr);
0292        y2= xyz(i2,2) - y(endr);
0293        vol(:,i)= x1.*y2 - x2.*y1;  <span class="comment">% determinant</span>
0294     <span class="keyword">end</span>
0295 
0296     endr( sum(abs(vol),2) - VOL &gt;1e-8 )=[];
0297     EPTR(endr)= j;
0298   <span class="keyword">end</span> <span class="comment">%for j=1:ELEM</span>
0299 
0300 
0301 <span class="comment">% 3D mapper of points to elements. First, we assume that</span>
0302 <span class="comment">% The vertex geometry (NODE) has been rotated and translated</span>
0303 <span class="comment">% so that the imaging plane is on the z-axis. Then we iterate</span>
0304 <span class="comment">% through elements to find the containing each pixel</span>
0305 <a name="_sub13" href="#_subfunctions" class="code">function EPTR= img_mapper3(NODE, ELEM, x, y );</a>
0306 
0307   ver = <a href="../../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>(<span class="string">'interpreter_version'</span>);
0308   <span class="keyword">if</span> ver.isoctave 
0309       img2d = <a href="#_sub16" class="code" title="subfunction [img2d, use_nodes] = mdl_3d_to_2d(NODE, ELEM)">mdl_3d_to_2d</a>(NODE, ELEM);  
0310       id = tsearch(img2d.fwd_model.nodes(:,1),img2d.fwd_model.nodes(:,2), <span class="keyword">...</span>
0311                    img2d.fwd_model.elems, x(:),y(:));
0312     <span class="comment">%  id = tsearchn(NODE(:,use_nodes)', map(ELEM(:,use_elem))', [x(:),y(:),zeros(numel(x),1)]);</span>
0313       in = ~isnan(id);
0314       id(in) = img2d.elem_data(id(in));
0315       id(~in) = 0;
0316   <span class="keyword">else</span>
0317       <span class="keyword">if</span> ver.ver &lt;  9.013 <span class="comment">% pointLocation was slow/buggy before</span>
0318           EPTR = <a href="#_sub14" class="code" title="subfunction EPTR= img_mapper3_old(NODE, ELEM, x, y );">img_mapper3_old</a>(NODE, ELEM, x, y);
0319           <span class="keyword">return</span>
0320       <span class="keyword">end</span>
0321       s = warning(<span class="string">'off'</span>, <span class="string">'MATLAB:triangulation:PtsNotInTriWarnId'</span>);
0322       TR = triangulation(double(ELEM'), double(NODE'));
0323       warning(s.state, <span class="string">'MATLAB:triangulation:PtsNotInTriWarnId'</span>);
0324       pts = [x(:),y(:)]; pts(:,3) = 0;
0325       id = pointLocation(TR, pts);
0326       id(isnan(id)) = 0;     
0327   <span class="keyword">end</span> 
0328   EPTR = reshape(id,size(x));
0329 
0330 <a name="_sub14" href="#_subfunctions" class="code">function EPTR= img_mapper3_old(NODE, ELEM, x, y );</a>
0331   [npy,npx] = size(x);
0332 
0333   EPTR=zeros(npy,npx);
0334   <span class="comment">% for each element j, we get points on the simplex a,b,c</span>
0335   <span class="comment">%   area A = abc</span>
0336   <span class="comment">%   for each candidate point d,</span>
0337   <span class="comment">%      area AA = abd + acd + bcd</span>
0338   <span class="comment">%      d is in j if AA = A</span>
0339   idx = 1:size(ELEM,2);
0340   z = reshape(NODE(3,ELEM),size(ELEM));
0341   idx(min(z)&gt;0 | max(z)&lt;0) = [];
0342   <span class="keyword">for</span> j= idx
0343     xyz= NODE(:,ELEM(:,j))';
0344 
0345     min_x= min(xyz(:,1)); max_x= max(xyz(:,1));
0346     min_y= min(xyz(:,2)); max_y= max(xyz(:,2));
0347 
0348     <span class="comment">% Simplex volume is det([v2-v1,v3-v1, ...])</span>
0349     VOL= abs(det(xyz'*[-1,1,0,0;-1,0,1,0;-1,0,0,1]'));
0350 
0351     <span class="comment">% come up with a limited set of candidate points which</span>
0352     <span class="comment">% may be within the simplex</span>
0353     endr=find( y(:)&lt;=max_y &amp; y(:)&gt;=min_y <span class="keyword">...</span>
0354              &amp; x(:)&lt;=max_x &amp; x(:)&gt;=min_x );
0355 
0356     nn=  size(ELEM,1); <span class="comment">%Simplex vertices</span>
0357     ll=  length(endr);
0358     vol=zeros(ll,nn);
0359     xendr = x(endr); yendr = y(endr);
0360     <span class="keyword">for</span> i=1:nn
0361        i1= i; i2= rem(i,nn)+1; i3= rem(i+1,nn)+1;
0362        x1= xyz(i1,1)-xendr; y1= xyz(i1,2)-yendr; z1= xyz(i1,3);
0363        x2= xyz(i2,1)-xendr; y2= xyz(i2,2)-yendr; z2= xyz(i2,3);
0364        x3= xyz(i3,1)-xendr; y3= xyz(i3,2)-yendr; z3= xyz(i3,3);
0365        vol(:,i)= x1.*y2.*z3 - x1.*y3.*z2 - x2.*y1.*z3 + <span class="keyword">...</span>
0366                  x3.*y1.*z2 + x2.*y3.*z1 - x3.*y2.*z1;
0367     <span class="keyword">end</span>
0368 
0369     endr( sum(abs(vol),2) - VOL &gt;1e-8 )=[];
0370     EPTR(endr)= j;
0371   <span class="keyword">end</span> <span class="comment">%for j=1:ELEM</span>
0372   
0373 <a name="_sub15" href="#_subfunctions" class="code">function [NODE, ELEM, use_nodes, use_elem] = limit_3dmodel_to_slice(NODE,ELEM)</a>
0374     use_elem = 1:size(ELEM,2);
0375     z = reshape(NODE(3,ELEM),size(ELEM));
0376     rng = max(z(:)) - min(z(:));
0377     use_elem(min(z)&gt;0.01*rng | max(z)&lt;-0.01*rng) = [];
0378     use_nodes = unique(ELEM(:,use_elem));
0379     map = zeros(size(NODE,2),1); map(use_nodes) = 1:numel(use_nodes);
0380     NODE = NODE(:,use_nodes);
0381     ELEM = map(ELEM(:,use_elem));
0382   
0383 <span class="comment">% function to be used on a leveled model (slice at z=0)</span>
0384 <a name="_sub16" href="#_subfunctions" class="code">function [img2d, use_nodes] = mdl_3d_to_2d(NODE, ELEM)  </a>
0385   [NODE, ELEM, use_nodes, use_elem] = <a href="#_sub15" class="code" title="subfunction [NODE, ELEM, use_nodes, use_elem] = limit_3dmodel_to_slice(NODE,ELEM)">limit_3dmodel_to_slice</a>(NODE,ELEM);
0386   fmdl.nodes = NODE';
0387   fmdl.elems = ELEM';
0388   fmdl.type = <span class="string">'fwd_model'</span>;
0389   fmdl.mdl_slice_mesher.interp_elems = false;
0390   img.fwd_model = fmdl;
0391   img.elem_data = use_elem;
0392   img.type = <span class="string">'image'</span>;
0393   img2d = <a href="mdl_slice_mesher.html" class="code" title="function [nimg out] = mdl_slice_mesher(fmdl,level,varargin)">mdl_slice_mesher</a>(img,[inf inf 0]);
0394   
0395 <span class="comment">% Level model: usage</span>
0396 <span class="comment">%   NODE= level_model( fwd_model, level );</span>
0397 <span class="comment">%</span>
0398 <span class="comment">% Level is a 1x3 vector specifying the x,y,z axis intercepts</span>
0399 <span class="comment">% NODE describes the vertices in this coord space</span>
0400 
0401 <a name="_sub17" href="#_subfunctions" class="code">function [NODE, ELEM] = level_model( fwd_model )</a>
0402    vtx= fwd_model.nodes;
0403    ELEM = fwd_model.elems';
0404    
0405    <span class="keyword">if</span> <a href="../../../eidors/models/mdl_dim.html" class="code" title="function num = mdl_dim( mdl );">mdl_dim</a>(fwd_model) ==2 || <span class="keyword">...</span><span class="comment"> % 2D case</span>
0406          isfield(fwd_model, <span class="string">'mdl_slice_mapper'</span>) &amp;&amp; <span class="keyword">...</span>
0407          isfield(fwd_model.mdl_slice_mapper, <span class="string">'model_2d'</span>) &amp;&amp; <span class="keyword">...</span>
0408          fwd_model.mdl_slice_mapper.model_2d &amp;&amp; <span class="keyword">...</span>
0409          ~isfield(fwd_model.mdl_slice_mapper, <span class="string">'level'</span>)
0410      
0411        NODE= vtx';
0412        <span class="keyword">return</span>;
0413    <span class="keyword">end</span>
0414          
0415    <span class="keyword">if</span>     isfield(fwd_model.mdl_slice_mapper,<span class="string">'level'</span>)
0416        N_slices = <a href="level_model_slice.html" class="code" title="function [out, out2, out3] = level_model_slice(varargin)">level_model_slice</a>(fwd_model.mdl_slice_mapper.level);
0417        <span class="keyword">if</span> N_slices &gt; 1
0418            <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>([<span class="string">'Multiple slices defined on forward model. '</span><span class="keyword">...</span>
0419                <span class="string">'Using the first slice.'</span>], 2);
0420        <span class="keyword">end</span>
0421        NODE = <a href="level_model_slice.html" class="code" title="function [out, out2, out3] = level_model_slice(varargin)">level_model_slice</a>(vtx, fwd_model.mdl_slice_mapper.level, 1);
0422    <span class="keyword">elseif</span> isfield(fwd_model.mdl_slice_mapper,<span class="string">'centre'</span>)
0423        <span class="comment">% just in case somebody was using that interface</span>
0424        rotate = fwd_model.mdl_slice_mapper.rotate;
0425        centre = fwd_model.mdl_slice_mapper.centre;
0426        warning(<span class="string">'EIDORS:MDL_SLICE_MAPPER:DeprecatedInterface'</span>,<span class="keyword">...</span>
0427             <span class="string">'Specifying mdl_slice_mapper.rotate and .centre is deprecated'</span>)
0428        level = struct(<span class="string">'centre'</span>, centre,<span class="string">'rotation_matrix'</span>,rotate);
0429        N_slices = <a href="level_model_slice.html" class="code" title="function [out, out2, out3] = level_model_slice(varargin)">level_model_slice</a>(level);
0430        <span class="keyword">if</span> N_slices &gt; 1
0431            warning([<span class="string">'Multiple slices defined on forward model. '</span><span class="keyword">...</span>
0432                <span class="string">'Using the first slice.'</span>])
0433        <span class="keyword">end</span>
0434        NODE = <a href="level_model_slice.html" class="code" title="function [out, out2, out3] = level_model_slice(varargin)">level_model_slice</a>(vtx, level , 1);       
0435    <span class="keyword">else</span>   error(<span class="string">'mdl_slice_mapper: no field level or centre provided'</span>);
0436    <span class="keyword">end</span>
0437    
0438    NODE = NODE'; 
0439    
0440 <a name="_sub18" href="#_subfunctions" class="code">function pts = get_points(fwd_model);</a>
0441    NODE = <a href="#_sub17" class="code" title="subfunction [NODE, ELEM] = level_model( fwd_model )">level_model</a>( fwd_model );
0442    <span class="keyword">if</span> isfield(fwd_model.mdl_slice_mapper,<span class="string">'model_2d'</span>) &amp;&amp; <span class="keyword">...</span>
0443            fwd_model.mdl_slice_mapper.model_2d &amp;&amp; size(NODE,1) == 3
0444        NODE(3,:) = [];
0445    <span class="keyword">end</span>
0446    <span class="keyword">if</span> size(NODE,1) ==2 <span class="comment">%2D</span>
0447       [x,y] = <a href="#_sub19" class="code" title="subfunction  [x,y] = grid_the_space( fmdl, flag);">grid_the_space</a>( fwd_model, <span class="string">'only_get_points'</span>);
0448    <span class="keyword">else</span>
0449       fmdl3 = fwd_model; fmdl3.nodes = NODE'; 
0450       [x,y] = <a href="#_sub19" class="code" title="subfunction  [x,y] = grid_the_space( fmdl, flag);">grid_the_space</a>( fmdl3 , <span class="string">'only_get_points'</span>);
0451    <span class="keyword">end</span>
0452    pts = {x, y};
0453   
0454    
0455 <span class="comment">% Create matrices x y which grid the space of NODE</span>
0456 <a name="_sub19" href="#_subfunctions" class="code">function  [x,y] = grid_the_space( fmdl, flag);</a>
0457 
0458   <span class="keyword">if</span> nnz(isfield(fmdl.mdl_slice_mapper, {<span class="string">'x_pts'</span>, <span class="string">'npoints'</span>, <span class="string">'npx'</span>, <span class="string">'resolution'</span>}))&gt;1
0459       warning(<span class="string">'Multiple specifications of points to map provided. Precedence not guaranteed'</span>)
0460   <span class="keyword">end</span>
0461 
0462   xspace = []; yspace = [];
0463   <span class="keyword">try</span> 
0464      xspace =  fmdl.mdl_slice_mapper.x_pts;
0465      yspace =  fmdl.mdl_slice_mapper.y_pts;
0466   <span class="keyword">end</span>
0467   
0468   
0469 
0470   <span class="keyword">if</span> isempty(xspace)
0471 
0472      xmin = min(fmdl.nodes(:,1));    xmax = max(fmdl.nodes(:,1));
0473      xmean= mean([xmin,xmax]); xrange= xmax-xmin;
0474 
0475      ymin = min(fmdl.nodes(:,2));    ymax = max(fmdl.nodes(:,2));
0476      ymean= mean([ymin,ymax]); yrange= ymax-ymin;
0477      
0478     
0479      npx = []; npy = [];
0480      <span class="keyword">if</span> all(isfield(fmdl.mdl_slice_mapper,{<span class="string">'npx'</span>,<span class="string">'npy'</span>}))
0481          npx  = fmdl.mdl_slice_mapper.npx;
0482          npy  = fmdl.mdl_slice_mapper.npy;
0483      <span class="keyword">elseif</span> isfield(fmdl.mdl_slice_mapper, <span class="string">'npoints'</span>)
0484          maxrange = max(xrange,yrange); 
0485          xrange = maxrange; yrange = maxrange;
0486          npx  = fmdl.mdl_slice_mapper.npoints;
0487          npy  = fmdl.mdl_slice_mapper.npoints;
0488      <span class="keyword">else</span>
0489          res = 1;
0490          <span class="keyword">try</span> res =  fmdl.mdl_slice_mapper.resolution; <span class="keyword">end</span>
0491          npx = ceil(xrange*res);
0492          npy = ceil(yrange*res);
0493      <span class="keyword">end</span>
0494      
0495      xdiv = xrange/npx; ydiv = yrange/npy;
0496      xspace = linspace( xmean - xrange/2 - xdiv/2, xmean + xrange*0.5 + xdiv/2, npx + 2);
0497      yspace = linspace( ymean + yrange/2 + ydiv/2, ymean - yrange*0.5 - ydiv/2, npy + 2);
0498      xspace = xspace(2:end-1);
0499      yspace = yspace(2:end-1);
0500 
0501   <span class="keyword">end</span>
0502   <span class="keyword">if</span> nargin &gt; 1 &amp;&amp; ischar(flag) &amp;&amp; strcmp(flag, <span class="string">'only_get_points'</span>)
0503       x = xspace; y = yspace;
0504       <span class="keyword">return</span>
0505   <span class="keyword">end</span>
0506   [x,y]=meshgrid( xspace, yspace );
0507 
0508 <a name="_sub20" href="#_subfunctions" class="code">function do_unit_test</a>
0509 <span class="comment">% 2D NUMBER OF POINTS</span>
0510    imdl = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'a2c2'</span>,8); fmdl = imdl.fwd_model;
0511    fmdl.nodes = 1e-15 * round(1e15*fmdl.nodes);
0512    fmdl.mdl_slice_mapper.level = [inf,inf,0];
0513    fmdl.mdl_slice_mapper.npx = 5;
0514    fmdl.mdl_slice_mapper.npy = 5;
0515    eptr = <a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype )">mdl_slice_mapper</a>(fmdl,<span class="string">'elem'</span>);
0516    
0517    si = @(x,y) sub2ind([5,5],x, y);
0518    <span class="comment">% points lie on nodes and edges, we allow any associated element</span>
0519    els = {si(2,2), [25,34];
0520           si(2,4), [27,30];
0521           si(3,3), [1,2,3,4];
0522           si(4,2), [33,36];
0523           si(4,4), [28,31];
0524           };
0525    
0526    tst = eptr == [    0   37   38   39    0
0527                      46   25    5   27   42
0528                      47    8    1    6   41
0529                      48   33    7   28   40
0530                       0   45   44   43    0];
0531                       
0532    <span class="keyword">for</span> i = 1:size(els,1)
0533     tst(els{i,1}) = ismember(eptr(els{i,1}), els{i,2});
0534    <span class="keyword">end</span>
0535    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'eptr01'</span>,tst,true(5,5));
0536 
0537    nptr = <a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype )">mdl_slice_mapper</a>(fmdl,<span class="string">'node'</span>);
0538    test = [   0   27   28   29    0
0539              41    6    7    8   31
0540              40   13    1    9   32
0541              39   12   11   10   33
0542               0   37   36   35    0];
0543    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'nptr01'</span>,nptr,test);
0544 
0545    nint = <a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype )">mdl_slice_mapper</a>(fmdl,<span class="string">'nodeinterp'</span>);
0546    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'nint01a'</span>,nint(2:4,2:4,1),[ 0.2627, 0.6909, 0.2627; 
0547                                              0.6906, 1,      0.6906;
0548                                              0.2627, 0.6909, 0.2627], 1e-3);
0549 
0550    fmdl.mdl_slice_mapper.npx = 6;
0551    fmdl.mdl_slice_mapper.npy = 4;
0552    eptr = <a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype )">mdl_slice_mapper</a>(fmdl,<span class="string">'elem'</span>);
0553    res = [  0   49   38   38   52    0
0554            62   23    9   10   20   55
0555            63   24   14   13   19   54
0556             0   60   44   44   57    0];
0557    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'eptr02'</span>,eptr,res);
0558 
0559    nptr = <a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype )">mdl_slice_mapper</a>(fmdl,<span class="string">'node'</span>);
0560    res = [  0   27   15   16   29    0
0561            25    6    2    3    8   18
0562            24   12    5    4   10   19
0563             0   37   22   21   35    0];
0564    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'nptr02'</span>,nptr,res);
0565 
0566 <span class="comment">% DIRECT POINT TESTS</span>
0567    imdl = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'a2c2'</span>,8); fmdl = imdl.fwd_model;
0568    fmdl.mdl_slice_mapper.level = [inf,inf,0];
0569    fmdl.mdl_slice_mapper.x_pts = linspace(-.95,.95,4);
0570    fmdl.mdl_slice_mapper.y_pts = [0,0.5];
0571    eptr = <a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype )">mdl_slice_mapper</a>(fmdl,<span class="string">'elem'</span>);
0572    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'eptr03'</span>,eptr,[ 47 8 6 41; 0 25 27 0]);
0573 
0574    nptr = <a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype )">mdl_slice_mapper</a>(fmdl,<span class="string">'node'</span>);
0575    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'nptr03'</span>,nptr,[ 40 13 9 32; 0 6 8 0]);
0576 
0577 <span class="comment">% 3D NPOINTS</span>
0578    imdl = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'n3r2'</span>,[16,2]); fmdl = imdl.fwd_model;
0579    fmdl.mdl_slice_mapper.level = [inf,inf,1]; <span class="comment">% co-planar with faces</span>
0580    fmdl.mdl_slice_mapper.npx = 4;
0581    fmdl.mdl_slice_mapper.npy = 4;
0582    eptr = <a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype )">mdl_slice_mapper</a>(fmdl,<span class="string">'elem'</span>);
0583    si = @(x,y) sub2ind([4,4],x, y);
0584    <span class="comment">% points lie on nodes and edges, we allow any associated element</span>
0585    els = {si(1,2), [ 42,317];
0586           si(1,3), [ 30,305];
0587           si(2,1), [ 66,341];
0588           si(2,2), [243,518];
0589           si(2,3), [231,506];
0590           si(2,4), [  6,281];
0591           si(3,1), [ 78,353];
0592           si(3,2), [252,527];
0593           si(3,3), [264,539];
0594           si(3,4), [138,413];
0595           si(4,2), [102,377];
0596           si(4,3), [114,389];};
0597    tst = eptr == zeros(4); 
0598    <span class="keyword">for</span> i = 1:size(els,1)
0599     tst(els{i,1}) = ismember(eptr(els{i,1}), els{i,2});
0600    <span class="keyword">end</span>
0601    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'eptr04'</span>,tst, true(4));
0602    nptr = <a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype )">mdl_slice_mapper</a>(fmdl,<span class="string">'node'</span>);
0603    test = [   0   101    99     0
0604             103   116   113    97
0605             105   118   121   111
0606               0   107   109     0];
0607    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'nptr04'</span>,nptr, test);
0608 
0609    fmdl.mdl_slice_mapper.level = [inf,0.01,inf];
0610    eptr = <a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype )">mdl_slice_mapper</a>(fmdl,<span class="string">'elem'</span>); 
0611    test = [621   792   777   555
0612            345   516   501   279
0613            343   515   499   277
0614             69   240   225     3];
0615    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'eptr05'</span>,eptr,test);
0616 
0617    nptr = <a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype )">mdl_slice_mapper</a>(fmdl,<span class="string">'node'</span>);
0618    test = [230   250   248   222
0619            167   187   185   159
0620            104   124   122    96
0621             41    61    59    33];
0622    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'nptr05'</span>,nptr,test);
0623 
0624    nint = <a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype )">mdl_slice_mapper</a>(fmdl,<span class="string">'nodeinterp'</span>);
0625    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'nint05a'</span>,nint(2:3,2:3,4),[.1250,.1250;.8225,.8225],1e-3);
0626    
0627 <span class="comment">% Centre and Rotate</span>
0628    fmdl.mdl_slice_mapper = rmfield(fmdl.mdl_slice_mapper,<span class="string">'level'</span>);
0629    fmdl.mdl_slice_mapper.centre = [0,0,0.9];
0630    fmdl.mdl_slice_mapper.rotate = eye(3);
0631    fmdl.mdl_slice_mapper.npx = 4;
0632    fmdl.mdl_slice_mapper.npy = 4;
0633    eptr = <a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype )">mdl_slice_mapper</a>(fmdl,<span class="string">'elem'</span>);
0634    test = [  0    42    30     0
0635             66   243   229     6
0636             78   250   264   138
0637              0   102   114     0];
0638    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'eptr06'</span>,eptr, test);
0639 
0640 <span class="comment">% SLOW</span>
0641    imdl = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'d3cr'</span>,[16,3]); fmdl = imdl.fwd_model;
0642    fmdl.nodes = 1e-15*round(1e15*fmdl.nodes);
0643    fmdl.mdl_slice_mapper.level = [inf,inf,1];
0644    fmdl.mdl_slice_mapper.npx = 64;
0645    fmdl.mdl_slice_mapper.npy = 64;
0646    t = cputime;
0647    eptr = <a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype )">mdl_slice_mapper</a>(fmdl,<span class="string">'elem'</span>);
0648    txt = sprintf(<span class="string">'eptr10 (t=%5.3fs)'</span>,cputime - t);
0649 <span class="comment">% Note that triangulation gives different</span>
0650 <span class="comment">% results near the edge</span>
0651    test = [122872   122872   122748
0652            122809   122749   122689
0653            122749   122749   122689];
0654    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,eptr(10:12,11:13),test);  
0655    
0656 
0657 <span class="comment">% CHECK ORIENTATION</span>
0658    imdl=<a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'a2c0'</span>,16);
0659    img= <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(imdl,1); img.elem_data(26)=1.2;
0660    subplot(231);<a href="show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img);
0661    subplot(232);<a href="show_slices.html" class="code" title="function out_img= show_slices( img, levels, vh )">show_slices</a>(img);
0662    img.fwd_model.mdl_slice_mapper.npx= 20;
0663    img.fwd_model.mdl_slice_mapper.npy= 30;
0664    img.fwd_model.mdl_slice_mapper.level= [inf,inf,0];
0665    subplot(233);<a href="show_slices.html" class="code" title="function out_img= show_slices( img, levels, vh )">show_slices</a>(img);
0666    img.fwd_model.mdl_slice_mapper.x_pts = [linspace(-1,1,23),.5];
0667    img.fwd_model.mdl_slice_mapper.y_pts = [linspace( 1,-1,34),.5];
0668    subplot(234);<a href="show_slices.html" class="code" title="function out_img= show_slices( img, levels, vh )">show_slices</a>(img);
0669    
0670    imdl = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'n3r2'</span>,[16,2]);
0671    img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(imdl,1); vh= <a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(img);
0672    load datacom.mat A B;
0673    img.elem_data(A) = 1.2;
0674    img.elem_data(B) = 0.8;
0675    img.calc_colours.transparency_thresh= 0.25;
0676    <a href="show_3d_slices.html" class="code" title="function h = show_3d_slices(img, varargin);">show_3d_slices</a>(img);
0677  
0678    cuts = [inf, -2.5, 1.5; inf, 10, 1.5];
0679    subplot(235);  <a href="show_3d_slices.html" class="code" title="function h = show_3d_slices(img, varargin);">show_3d_slices</a>(img ,[],[],[],cuts );
0680    
0681    cuts = [inf, inf, 0.5; 
0682            1e-10, 2e-10, inf;1e-10, 1e-10, inf;2e-10, 1e-10, inf;
0683            inf  , 1e-10, inf;1e-10, inf  , inf];
0684    subplot(236);  <a href="show_3d_slices.html" class="code" title="function h = show_3d_slices(img, varargin);">show_3d_slices</a>(img ,[],[],[],cuts );
0685</pre></div>
<hr><address>Generated on Fri 30-Dec-2022 20:46:51 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>